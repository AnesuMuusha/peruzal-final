{
    "docs": [
        {
            "location": "/", 
            "text": "What is Ruby\n\n\nIs a  dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.\n\n\nWhere Ruby is Used\n\n\n\n\nRuby on Rails\n\n\nSinatra\n\n\nMetasploit\n\n\nOpscode Chef\n\n\nPuppet\n\n\n\n\nCompanies Using Ruby\n\n\n\n\nAirBnB\n\n\nGroupOn\n\n\nTwitter\n\n\nGithub\n\n\nShopify", 
            "title": "Home"
        }, 
        {
            "location": "/#what-is-ruby", 
            "text": "Is a  dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.", 
            "title": "What is Ruby"
        }, 
        {
            "location": "/#where-ruby-is-used", 
            "text": "Ruby on Rails  Sinatra  Metasploit  Opscode Chef  Puppet", 
            "title": "Where Ruby is Used"
        }, 
        {
            "location": "/#companies-using-ruby", 
            "text": "AirBnB  GroupOn  Twitter  Github  Shopify", 
            "title": "Companies Using Ruby"
        }, 
        {
            "location": "/setting_up_development_environment/", 
            "text": "Installing Ruby on Linux\n\n\nThe easiest way to install Ruby on a Linux machine is to use the Ruby Version Manager(RVM). On the terminal run the following commands:\n\n\nUpdate the packages\n\n\nsudo apt-get update\n\n\n\n\n\nInstall tools for development\n\n\nsudo apt-get install build-essential make curl\n\n\n\n\n\nInstall RVM and current version of Ruby\n\n\n\\c\nurl -sSL https://get.rvm.io \n|\n bash -s stable --ruby\n\n\n\n\n\nReload the configs before start using RVM\n\n\nsource\n ~/.rvm/scripts/rvm\n\n\n\n\n\nInstalling Ruby on Mac OS X\n\n\nOSX comes with Ruby already installed. The version might be outdated. We can run parallel versions os Ruby using RVM.\n\n\nInstall RVM and latest Ruby version\n\n\n\\c\nurl -sSL https://get.rvm.io \n|\n bash -s stable --ruby\n\n\n\n\n\nRealod the RVM config\n\n\nsource\n ~/.rvm/scripts/rvm\n\n\n\n\n\nInstalling Ruby on Windows\n\n\nThere is an installer available from \nhere\n.\n\n\nInteractive Ruby Shell\n\n\nIRB is an interactive Ruby shell.\n\n\nLanuch IRB\n\n\nFrom the terminal run\n\n\nirb\n\n\n\n\n\nYou can also start the irb terminal without a prompt as follows :\n\n\nirb\n \n--\nnoprompt\n\n\n\n\n\n\nYou can also use the simple prompt option that does not display a lot of information as follows :\n\n\nirb\n \n--\nsimple\n-\nprompt\n\n\n\n\n\n\nYou should now be on the IRB prompt. You can type any valid Ruby commands on the shell\n\n\nirb\n(\nmain\n)\n:001:0\n \nHowdy Ruby\n * \n3\n\n\n\n\n\n\nThe output will be shown starting with the \n=\n symbol\n\n\nSetting Up AutoCompletion from IRB\n\n\nIf there's no auto-complete when you TAB in IRB shell, you can add the following line to the \n~/.irbrc\n file.\n\n\nrequire\n \nirb/completion\n\n\n\n\n\n\nRunning Ruby scripts\n\n\nInstead of using the irb terminal, you can also run ruby from scripts. Add teh following at the beginning of the file :\n\n\n#!/usr/bin/env ruby\n\n\n\n\n\n\nYou can also add the \n-w\n to show warning as follows :\n\n\n#!/usr/bin/env ruby -w\n\n\n\n\n\n\nA simple hello world Ruby script can be as follows :\n\n\n# helloworld.rb\n\n\n#!/usr/bin/env ruby -w\n\n\nputs\n \nHello World\n\n\n\n\n\n\nMake script file executable as follows :\n\n\nchmod\n \n+\nx\n \nhelloworld\n.\nrb\n\n\n\n\n\n\nExecute the script\n\n\n.\n/\nhelloworld\n.\nrb", 
            "title": "Setting Up Environment"
        }, 
        {
            "location": "/setting_up_development_environment/#installing-ruby-on-linux", 
            "text": "The easiest way to install Ruby on a Linux machine is to use the Ruby Version Manager(RVM). On the terminal run the following commands:", 
            "title": "Installing Ruby on Linux"
        }, 
        {
            "location": "/setting_up_development_environment/#update-the-packages", 
            "text": "sudo apt-get update", 
            "title": "Update the packages"
        }, 
        {
            "location": "/setting_up_development_environment/#install-tools-for-development", 
            "text": "sudo apt-get install build-essential make curl", 
            "title": "Install tools for development"
        }, 
        {
            "location": "/setting_up_development_environment/#install-rvm-and-current-version-of-ruby", 
            "text": "\\c url -sSL https://get.rvm.io  |  bash -s stable --ruby", 
            "title": "Install RVM and current version of Ruby"
        }, 
        {
            "location": "/setting_up_development_environment/#reload-the-configs-before-start-using-rvm", 
            "text": "source  ~/.rvm/scripts/rvm", 
            "title": "Reload the configs before start using RVM"
        }, 
        {
            "location": "/setting_up_development_environment/#installing-ruby-on-mac-os-x", 
            "text": "OSX comes with Ruby already installed. The version might be outdated. We can run parallel versions os Ruby using RVM.", 
            "title": "Installing Ruby on Mac OS X"
        }, 
        {
            "location": "/setting_up_development_environment/#install-rvm-and-latest-ruby-version", 
            "text": "\\c url -sSL https://get.rvm.io  |  bash -s stable --ruby", 
            "title": "Install RVM and latest Ruby version"
        }, 
        {
            "location": "/setting_up_development_environment/#realod-the-rvm-config", 
            "text": "source  ~/.rvm/scripts/rvm", 
            "title": "Realod the RVM config"
        }, 
        {
            "location": "/setting_up_development_environment/#installing-ruby-on-windows", 
            "text": "There is an installer available from  here .", 
            "title": "Installing Ruby on Windows"
        }, 
        {
            "location": "/setting_up_development_environment/#interactive-ruby-shell", 
            "text": "IRB is an interactive Ruby shell.", 
            "title": "Interactive Ruby Shell"
        }, 
        {
            "location": "/setting_up_development_environment/#lanuch-irb", 
            "text": "From the terminal run  irb  You can also start the irb terminal without a prompt as follows :  irb   -- noprompt   You can also use the simple prompt option that does not display a lot of information as follows :  irb   -- simple - prompt   You should now be on the IRB prompt. You can type any valid Ruby commands on the shell  irb ( main ) :001:0   Howdy Ruby  *  3   The output will be shown starting with the  =  symbol", 
            "title": "Lanuch IRB"
        }, 
        {
            "location": "/setting_up_development_environment/#setting-up-autocompletion-from-irb", 
            "text": "If there's no auto-complete when you TAB in IRB shell, you can add the following line to the  ~/.irbrc  file.  require   irb/completion", 
            "title": "Setting Up AutoCompletion from IRB"
        }, 
        {
            "location": "/setting_up_development_environment/#running-ruby-scripts", 
            "text": "Instead of using the irb terminal, you can also run ruby from scripts. Add teh following at the beginning of the file :  #!/usr/bin/env ruby   You can also add the  -w  to show warning as follows :  #!/usr/bin/env ruby -w   A simple hello world Ruby script can be as follows :  # helloworld.rb  #!/usr/bin/env ruby -w  puts   Hello World   Make script file executable as follows :  chmod   + x   helloworld . rb   Execute the script  . / helloworld . rb", 
            "title": "Running Ruby scripts"
        }, 
        {
            "location": "/overview/", 
            "text": "Overview of Ruby\n\n\nEverything Is An Object\n\n\nIn Ruby everything is an object. From the IRB shell lets run a couple of examples.\n\n\nirb\n(\nmain\n):\n001\n:\n0\n \n1\n.\nodd?\n\n\n=\n \ntrue\n\n\n\n\n\n\nNotice the output is \ntrue\n. We are able to call methods on the literal 1.\n\n\nirb\n(\nmain\n):\n002\n:\n0\n \n1\n.\neven?\n\n\n=\n \nfalse\n\n\n\n\n\n\nWe can also call methods on strings literals as follows :\n\n\nirb\n(\nmain\n):\n003\n:\n0\n \nHello World\n.\nreverse\n\n\n=\n \ndlroW olleH\n\n\n\n\n\n\nand we can also find the length of the string :\n\n\nirb\n(\nmain\n):\n004\n:\n0\n \nHello World\n.\nlength\n\n\n=\n \n11\n\n\n\n\n\n\nComments\n\n\nComments in Ruby can be single line or multiple line :\n\n\n\n\nSingle line comments start with a \n#\n symbol.\n\n\nMultiple line comments use \n=begin\n and \n=end\n\n\n\n\nSingle line comment\n\n\nAnything after the \n#\n is ignored.\n\n\n# This is an example of a comment\n\n\nputs\n \nHello World\n \n# This comment come after a line of code\n\n\n\n\n\n\nMultiple line comments\n\n\n=begin\n\n\nThis is an example\n\n\nof a multiple line comment.\n\n\nThese type of comments are rare\n\n\n=end\n\n\n\n\n\n\nBlocks and Iterators\n\n\nIterators are methods that act as loop constructs in Ruby. Blocks are pieces of code without names. When working with Ruby you will encounter blocks and iterators, let see some examples.\n\n\nirb\n(\nmain\n):\n005\n:\n0\n \n1\n.\nupto\n(\n5\n)\n\n\n=\n \n#\nEnumerator: 1:upto(5)\n\n\n\n\n\n\nThe \nupto\n is an iterator. We can use to count up to the value in brackets. We can can combine the \nupto\n iterator with a block as follows :\n\n\neach iterator\n\n\nThe \neach\n iterator is used to iterate through a collection.\n\n\nDefine an array\n\n\na\n \n=\n \n[\n1\n,\n2\n]\n\n\n=\n \n[\n1\n,\n \n2\n]\n\n\n\n\n\n\nGet an iterator\n\n\nirb\n(\nmain\n):\n016\n:\n0\n \na\n.\neach\n\n\n=\n \n#\nEnumerator: [1, 2]:each\n\n\n\n\n\n\nirb\n(\nmain\n):\n017\n:\n0\n \na\n.\nmap\n\n\n=\n \n#\nEnumerator: [1, 2]:map\n\n\n\n\n\n\nBlocks\n\n\nWe can use \nBlocks\n in combination with iterators. The blocks are either single line or multiple line.\n\n\nSingle line blocks\n\n\nSingle line blocks start with \n{\n and end with \n}\n e.g \n{ puts \"Hello World\" }\n is a single line block.\n\n\nMultiple line blocks\n\n\nMultiple line block start with a \ndo\n and finish with and \nend\n keyword, e.g\n\n\ndo\n\n    \nputs\n \nHello World\n\n\nend\n\n\n\n\n\n\nWith a single line block :\n\n\n1\n.\nupto\n(\n2\n)\n \n{\n \nputs\n \nHello\n \n}\n\n\nHello\n\n\nHello\n\n\n=\n \n1\n\n\n\n\n\n\nWith a multi-line line block\n\n\n1\n.\nupto\n(\n2\n)\n \ndo\n\n    \np\n \nHello World\n\n\nend\n\n\n\n\n\n\nWe can also generate an iterator from a range and use a block on it as follows :\n\n\nirb\n(\nmain\n):\n033\n:\n0\n \n(\n1\n..\n2\n)\n.\neach\n \n{\n \np\n \nHello World\n \n}\n\n\nHello World\n\n\nHello World\n\n\n=\n \n1\n..\n2\n\n\n\n\n\n\nPassing arguments to blocks\n\n\nWe can pass arguments to blocs using the \n||\n symbols after the first \n{\n bracket as follows :\n\n\n(\n1\n..\n3\n)\n.\neach\n \n{\n|\nvalue\n|\n \np\n \nHello World \n#{\nvalue\n}\n \n}\n\n\n\n\n\n\nRunning this in IRB :\n\n\nirb\n(\nmain\n):\n034\n:\n0\n \n(\n1\n..\n3\n)\n.\neach\n \n{\n|\nvalue\n|\n \np\n \nHello World \n#{\nvalue\n}\n \n}\n\n\nHello World 1\n\n\nHello World 2\n\n\nHello World 3\n\n\n=\n \n1\n..\n3\n\n\n\n\n\n\nThe \n#{}\n is string interpolation in Ruby. In this case the value for \nindex\n will be concatenated with the rest of the string.\n\n\nWe can also use the arguments using the multi-line line block syntax as well. The \n||\n will come after the \ndo\n statement as follows :\n\n\n(\n1\n..\n3\n)\n.\neach\n \ndo\n \n|\nvalue\n|\n\n    \np\n \nHello \n#{\nvalue\n}\n\n\nend\n\n\n\n\n\n\nWith IRB :\n\n\nirb\n(\nmain\n):\n035\n:\n0\n \n(\n1\n..\n3\n)\n.\neach\n \ndo\n \n|\nindex\n|\n\n\nirb\n(\nmain\n):\n036\n:\n1\n*\n \np\n \nHello \n#{\nindex\n}\n\n\nirb\n(\nmain\n):\n037\n:\n1\n \nend\n\n\nHello 1\n\n\nHello 2\n\n\nHello 3\n\n\n=\n \n1\n..\n3\n\n\n\n\n\n\nWe can get the powers of numbers between 1 and 10 using arguments passed within an iterator as follows :\n\n\n(\n1\n..\n10\n)\n.\nmap\n \n{\n \n|\ni\n|\n \n2\n \n**\n \ni\n \n}\n\n\n\n\n\n\nIn IRB we get the following :\n\n\nirb\n(\nmain\n):\n03\n8\n:\n0\n \n(\n1\n..\n10\n)\n.\nmap\n \n{\n \n|\ni\n|\n \n2\n \n**\n \ni\n \n}\n\n\n=\n \n[\n2\n,\n \n4\n,\n \n8\n,\n \n16\n,\n \n32\n,\n \n64\n,\n \n128\n,\n \n256\n,\n \n512\n,\n \n1024\n]\n\n\n\n\n\n\nThe \n**\n is the mathematical power operator.\n\n\nRead a file line by line using block and iterators\n\n\nWe can also take advantage of the \neach\n iterator and use a block to output the contents of a text file as follows :\n\n\nFile\n.\nreadlines\n(\npgadmin.log\n)\n.\neach\n \n{\n \n|\nline\n|\n \np\n \nline\n \n}\n\n\n\n\n\n\nThe file \npgadmin.log\n should be in your current directory you are tunning IRB from.\n\n\nModules\n\n\nModules are used to define a namespace. This creates a sandbox that groups together methods, classes and constants. They are also included to extended class behavior.\n\n\nCreate a module\n\n\nWe use the \nmodule\n keyword to create a module as follows \n\n\nmodule\n \nGreeter\n\n    \ndef\n \ngreet\n\n        \nputs\n \nHello World\n\n    \nend\n\n\nend\n\n\n\n\n\n\nInclude the module in a class\n\n\nWe can now add functionality to a class using the module as follows :\n\n\nclass\n \nPerson\n\n    \ninclude\n \nGreeter\n\n\nend\n\n\n\n\n\n\nusing the \ninclude\n keyword, we can now include all the functionality provided by the module into the class. Now the \nPerson\n class can now \ngreet\n.\n\n\nInstantiate a new Person object\n\n\nWe can now call \ngreet\n method after creating a new \nPerson\n object\n\n\np\n \n=\n \nPerson\n.\nnew\n\n\np\n.\ngreet\n\n\n\n\n\n\nIf we run from within IRB, we get the \nHello World\n as below :\n\n\np\n \n=\n \nPerson\n.\nnew\n\n\n=\n \n#\nPerson:0x007ffc4d9ff730\n\n\nirb\n(\nmain\n):\n013\n:\n0\n \np\n.\ngreet\n\n\nHello\n \nWorld\n\n\n\n\n\n\nDuck Typing\n\n\nIn Ruby, objects are defined by what they can do. The type of an object is defined by its methods and attributes. Objects are not defined by their type.  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n\n\nWe use the \nresponds_to?\n method to check what methods the object responds to as follows :\n\n\nirb\n(\nmain\n):\n01\n9\n:\n0\n \n(\n1\n..\n5\n)\n.\nrespond_to?\n \n:each\n\n\n=\n \ntrue\n\n\n\n\n\n\nWe can see the the (1..5) can respond to the \neach\n method, therefore we can call \neach\n on the object.", 
            "title": "Ruby Overview"
        }, 
        {
            "location": "/overview/#overview-of-ruby", 
            "text": "", 
            "title": "Overview of Ruby"
        }, 
        {
            "location": "/overview/#everything-is-an-object", 
            "text": "In Ruby everything is an object. From the IRB shell lets run a couple of examples.  irb ( main ): 001 : 0   1 . odd?  =   true   Notice the output is  true . We are able to call methods on the literal 1.  irb ( main ): 002 : 0   1 . even?  =   false   We can also call methods on strings literals as follows :  irb ( main ): 003 : 0   Hello World . reverse  =   dlroW olleH   and we can also find the length of the string :  irb ( main ): 004 : 0   Hello World . length  =   11", 
            "title": "Everything Is An Object"
        }, 
        {
            "location": "/overview/#comments", 
            "text": "Comments in Ruby can be single line or multiple line :   Single line comments start with a  #  symbol.  Multiple line comments use  =begin  and  =end", 
            "title": "Comments"
        }, 
        {
            "location": "/overview/#single-line-comment", 
            "text": "Anything after the  #  is ignored.  # This is an example of a comment  puts   Hello World   # This comment come after a line of code", 
            "title": "Single line comment"
        }, 
        {
            "location": "/overview/#multiple-line-comments", 
            "text": "=begin  This is an example  of a multiple line comment.  These type of comments are rare  =end", 
            "title": "Multiple line comments"
        }, 
        {
            "location": "/overview/#blocks-and-iterators", 
            "text": "Iterators are methods that act as loop constructs in Ruby. Blocks are pieces of code without names. When working with Ruby you will encounter blocks and iterators, let see some examples.  irb ( main ): 005 : 0   1 . upto ( 5 )  =   # Enumerator: 1:upto(5)   The  upto  is an iterator. We can use to count up to the value in brackets. We can can combine the  upto  iterator with a block as follows :", 
            "title": "Blocks and Iterators"
        }, 
        {
            "location": "/overview/#each-iterator", 
            "text": "The  each  iterator is used to iterate through a collection.", 
            "title": "each iterator"
        }, 
        {
            "location": "/overview/#define-an-array", 
            "text": "a   =   [ 1 , 2 ]  =   [ 1 ,   2 ]", 
            "title": "Define an array"
        }, 
        {
            "location": "/overview/#get-an-iterator", 
            "text": "irb ( main ): 016 : 0   a . each  =   # Enumerator: [1, 2]:each   irb ( main ): 017 : 0   a . map  =   # Enumerator: [1, 2]:map", 
            "title": "Get an iterator"
        }, 
        {
            "location": "/overview/#blocks", 
            "text": "We can use  Blocks  in combination with iterators. The blocks are either single line or multiple line.", 
            "title": "Blocks"
        }, 
        {
            "location": "/overview/#single-line-blocks", 
            "text": "Single line blocks start with  {  and end with  }  e.g  { puts \"Hello World\" }  is a single line block.", 
            "title": "Single line blocks"
        }, 
        {
            "location": "/overview/#multiple-line-blocks", 
            "text": "Multiple line block start with a  do  and finish with and  end  keyword, e.g  do \n     puts   Hello World  end   With a single line block :  1 . upto ( 2 )   {   puts   Hello   }  Hello  Hello  =   1   With a multi-line line block  1 . upto ( 2 )   do \n     p   Hello World  end   We can also generate an iterator from a range and use a block on it as follows :  irb ( main ): 033 : 0   ( 1 .. 2 ) . each   {   p   Hello World   }  Hello World  Hello World  =   1 .. 2", 
            "title": "Multiple line blocks"
        }, 
        {
            "location": "/overview/#passing-arguments-to-blocks", 
            "text": "We can pass arguments to blocs using the  ||  symbols after the first  {  bracket as follows :  ( 1 .. 3 ) . each   { | value |   p   Hello World  #{ value }   }   Running this in IRB :  irb ( main ): 034 : 0   ( 1 .. 3 ) . each   { | value |   p   Hello World  #{ value }   }  Hello World 1  Hello World 2  Hello World 3  =   1 .. 3   The  #{}  is string interpolation in Ruby. In this case the value for  index  will be concatenated with the rest of the string.  We can also use the arguments using the multi-line line block syntax as well. The  ||  will come after the  do  statement as follows :  ( 1 .. 3 ) . each   do   | value | \n     p   Hello  #{ value }  end   With IRB :  irb ( main ): 035 : 0   ( 1 .. 3 ) . each   do   | index |  irb ( main ): 036 : 1 *   p   Hello  #{ index }  irb ( main ): 037 : 1   end  Hello 1  Hello 2  Hello 3  =   1 .. 3   We can get the powers of numbers between 1 and 10 using arguments passed within an iterator as follows :  ( 1 .. 10 ) . map   {   | i |   2   **   i   }   In IRB we get the following :  irb ( main ): 03 8 : 0   ( 1 .. 10 ) . map   {   | i |   2   **   i   }  =   [ 2 ,   4 ,   8 ,   16 ,   32 ,   64 ,   128 ,   256 ,   512 ,   1024 ]   The  **  is the mathematical power operator.", 
            "title": "Passing arguments to blocks"
        }, 
        {
            "location": "/overview/#read-a-file-line-by-line-using-block-and-iterators", 
            "text": "We can also take advantage of the  each  iterator and use a block to output the contents of a text file as follows :  File . readlines ( pgadmin.log ) . each   {   | line |   p   line   }   The file  pgadmin.log  should be in your current directory you are tunning IRB from.", 
            "title": "Read a file line by line using block and iterators"
        }, 
        {
            "location": "/overview/#modules", 
            "text": "Modules are used to define a namespace. This creates a sandbox that groups together methods, classes and constants. They are also included to extended class behavior.", 
            "title": "Modules"
        }, 
        {
            "location": "/overview/#create-a-module", 
            "text": "We use the  module  keyword to create a module as follows   module   Greeter \n     def   greet \n         puts   Hello World \n     end  end", 
            "title": "Create a module"
        }, 
        {
            "location": "/overview/#include-the-module-in-a-class", 
            "text": "We can now add functionality to a class using the module as follows :  class   Person \n     include   Greeter  end   using the  include  keyword, we can now include all the functionality provided by the module into the class. Now the  Person  class can now  greet .", 
            "title": "Include the module in a class"
        }, 
        {
            "location": "/overview/#instantiate-a-new-person-object", 
            "text": "We can now call  greet  method after creating a new  Person  object  p   =   Person . new  p . greet   If we run from within IRB, we get the  Hello World  as below :  p   =   Person . new  =   # Person:0x007ffc4d9ff730  irb ( main ): 013 : 0   p . greet  Hello   World", 
            "title": "Instantiate a new Person object"
        }, 
        {
            "location": "/overview/#duck-typing", 
            "text": "In Ruby, objects are defined by what they can do. The type of an object is defined by its methods and attributes. Objects are not defined by their type.  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.  We use the  responds_to?  method to check what methods the object responds to as follows :  irb ( main ): 01 9 : 0   ( 1 .. 5 ) . respond_to?   :each  =   true   We can see the the (1..5) can respond to the  each  method, therefore we can call  each  on the object.", 
            "title": "Duck Typing"
        }, 
        {
            "location": "/ruby_documentation/", 
            "text": "Ruby Documentation\n\n\nRuby documentation can be found in the following places :\n\n\n\n\nRDoc\n\n\nri\n\n\nRuby doc website\n\n\nDevdocs.io\n\n\nDash App\n\n\n\n\nRDoc\n\n\nRDoc produces HTML and online documentation for Ruby projects. We can use the command line tool \nrdoc\n to generate Ruby documentation.\n\n\nRVM Documentation\n\n\nrvm\n \ndocs\n \ngenerate\n\n\n\n\n\n\nri documentation from rvm\n\n\nGenerate ri docs without generating rdoc with the following :\n\n\nrvm\n \ndocs\n \ngenerate\n-\nri\n\n\n\n\n\n\nri\n\n\nThe \nri\n command line tool will show Ruby documentation if installed. To show ri documentation for the \nString\n, you can run the following on the terminal :\n\n\nri\n \nString\n\n\n\n\n\n\nRuby Gems Documentation\n\n\nYou can find documentation on installed gems by running the gems server as follows :\n\n\ngem\n \nserver\n\n\n\n\n\n\nYou will get a port number on which the gem server is running. Use the browser to access the server.", 
            "title": "Ruby Documentation"
        }, 
        {
            "location": "/ruby_documentation/#ruby-documentation", 
            "text": "Ruby documentation can be found in the following places :   RDoc  ri  Ruby doc website  Devdocs.io  Dash App", 
            "title": "Ruby Documentation"
        }, 
        {
            "location": "/ruby_documentation/#rdoc", 
            "text": "RDoc produces HTML and online documentation for Ruby projects. We can use the command line tool  rdoc  to generate Ruby documentation.", 
            "title": "RDoc"
        }, 
        {
            "location": "/ruby_documentation/#rvm-documentation", 
            "text": "rvm   docs   generate", 
            "title": "RVM Documentation"
        }, 
        {
            "location": "/ruby_documentation/#ri-documentation-from-rvm", 
            "text": "Generate ri docs without generating rdoc with the following :  rvm   docs   generate - ri", 
            "title": "ri documentation from rvm"
        }, 
        {
            "location": "/ruby_documentation/#ri", 
            "text": "The  ri  command line tool will show Ruby documentation if installed. To show ri documentation for the  String , you can run the following on the terminal :  ri   String", 
            "title": "ri"
        }, 
        {
            "location": "/ruby_documentation/#ruby-gems-documentation", 
            "text": "You can find documentation on installed gems by running the gems server as follows :  gem   server   You will get a port number on which the gem server is running. Use the browser to access the server.", 
            "title": "Ruby Gems Documentation"
        }, 
        {
            "location": "/operators/", 
            "text": "Ruby Operators\n\n\nRuby operators can be broadly categorized into the following : \n\n\n\n\nArithmetic\n\n\nShift or Append\n\n\nComparison\n\n\nBooleans\n\n\nRanges\n\n\n\n\nArithmetic Operators\n\n\nThe arithmetic operators are :\n\n\n\n\n+\n - Addition\n\n\n-\n - Subtraction\n\n\n*\n - Multiplication\n\n\n**\n - Exponential\n\n\n/\n - Division\n\n\n%\n - Modulo\n\n\n\n\nAddition\n\n\n \n1\n \n+\n \n1\n\n \n=\n \n2\n\n\n\n\n\n\nDivision\n\n\n \n5\n \n/\n \n2\n\n \n=\n \n2\n\n\n\n\n\n\nTo get 2.5 as the answer you will need to use floating point numbers as follows :\n\n\n \n5\n.\n0\n \n/\n \n2\n.\n0\n\n \n=\n \n2\n.\n5\n\n\n\n\n\n\nModulo\n\n\nRemainder division\n\n\n \n5\n \n%\n \n2\n\n \n=\n \n1\n\n\n\n\n\n\nYou will get an exception if you try to divide by 0.\n\n\n \n2\n \n/\n0\n\n\nZeroDivisionError\n:\n \ndivided\n \nby\n \n0\n\n    \nfrom\n \n(\nirb\n):\n9\n:in\n \n`/\n\n\n\n\n\n\nFloating point division with 0 will give \nInfinity\n as a result.\n\n\n \n2\n.\n0\n \n/\n \n0\n.\n0\n\n \n=\n \nInfinity\n\n\n\n\n\n\nAddition on Arrays\n\n\nWe can apply addition to arrays, the result in a concatenation of the two arrays as follows :\n\n\n \n[\n1\n,\n2\n]\n \n+\n \n[\n3\n,\n4\n,\n5\n]\n\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nArithmetic Operators on Strings\n\n\nWe can also apply arithmetic operators on string objects as follows :\n\n\n \nHello world \n \n*\n \n2\n\n \n=\n \nHello world Hello world \n\n\n\n\n\n\nOnly the multiplication operator works, other arithmetic operators will produce an error.\n\n\nExponential Operators\n\n\nWe use the \n**\n for exponent as follows :\n\n\n \n \n2\n \n**\n \n2\n\n \n=\n \n4\n\n\n\n\n\n\nShift operators\n\n\nWe can use the two shift operators, \n and \n. This allows us to manipulate the numbers in binary. E.g we can easily get a 4 by shifting the 2 in binary by 1 as follows.\n\n\n \n2\n \n \n1\n\n \n=\n \n4\n\n\n\n\n\n\nHere is how it works. The number 2 in binary is represented as 10. When we shift by 1 we push an additional 0 at the end, so we now get the number 100, which is 4 in binary.\n\n\nWe can display the value of 2 in binary using the \nto_s(2)\n method as follows :\n\n\n \n2\n.\nto_s\n(\n2\n)\n\n \n=\n \n10\n\n\n\n\n\n\nWe can see that 2 in binary is 10.\n\n\nIf we change the operator and push to the right, we now remove the leading 0.\n\n\n \n2\n \n \n1\n\n \n=\n \n1\n\n\n\n\n\n\nWe now get a 1 since we removed the leading 0 from 10.\n\n\nWe can shift with more bits if we prefer, e.g. to get the value 8 we can push 2 by 3 bits as follows :\n\n\n \n2\n \n \n2\n\n \n=\n \n8\n\n\n\n\n\n\nAppend Operator\n\n\nThe same operator for left shifting, \n is for appending on arrays.\n\n\n \nnums\n \n=\n \n[]\n\n \n=\n \n[]\n \n\n2\n.\n2\n.\n5\n \n:\n02\n9\n \n \nnums\n \n \n1\n\n \n=\n \n[\n1\n]\n \n\n2\n.\n2\n.\n5\n \n:\n030\n \n \nnums\n \n \n2\n\n \n=\n \n[\n1\n,\n \n2\n]\n\n\n\n\n\n\nWe could also apply the append multiple times as follows :\n\n\n \n \nnums\n \n \n3\n \n \n4\n\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nOutput to Standard Output\n\n\nThe \n operator is also used to output to Standard Output as follows :\n\n\n \n \nSTDOUT\n \n \nHello World\n\n\nHello\n \nWorld\n \n=\n \n#\nIO:\nSTDOUT\n\n\n\n\n\n\nComparison Operators\n\n\n\n\n - Less than operator\n\n\n= - Less then or equal to operator\n\n\n\n\n\n\n\n\nGreater than operator\n\n\n\n\n\n\n\n\n\n\n\n\n= - Greater than operator\n\n\n\n\n\n\n=\n - Comparable operator\n\n\n!= - Not equal to operator\n\n\n\n\nComparable operator \n=\n\n\nThe other operators perform exactly as they are supposed to except the comparable operator. The comparable operator works as follows :\n\n\n\n\nReturns -1 if the left hand value is less than the right hand operand\n\n\nReturns 1 if the left hand operand is greater than the right hand operand\n\n\nReturn 0 is they are equal\n\n\nReturns nil if they can not be compared\n\n\n\n\n \n2\n \n=\n \n2\n\n \n=\n \n0\n\n\n\n\n\n\n \n1\n \n=\n \n2\n\n \n=\n \n-\n1\n\n\n\n\n\n\n \n2\n \n=\n \n1\n\n \n=\n \n1\n\n\n\n\n\n\nBoolean Operators\n\n\n\n\n - Logical AND operator\n\n\n|| - Logical OR operator\n\n\n! - NOT operator\n\n\n\n\n operator\n\n\nThe operator returns tru if all the operands are true or false otherwise.\n\n\n \n10\n \n \n0\n \n \n10\n \n \n9\n\n \n=\n \nfalse\n\n\n\n\n\n\n|| operator\n\n\nThe logical OR operator returns true if any of the operands returns true. It returns false if both operands return false.\n\n\n \n10\n \n \n0\n \n||\n \n10\n \n==\n \n10\n\n \n=\n \ntrue\n\n\n\n\n\n\n! NOT Operator\n\n\nNegates the operand.\n\n\n \n!\ntrue\n\n \n=\n \nfalse\n\n\n\n\n\n\n \n!\nfalse\n\n \n=\n \ntrue\n\n\n\n\n\n\n||= OR Equal\n\n\nThis operator returns the current value if its initialized or initializes the new value.\n\n\n \nb\n \n||=\n \n5\n \n# b is not defined, so we get 5\n\n \n=\n \n5\n\n\n2\n.\n2\n.\n5\n \n:\n04\n9\n \n \nb\n \n=\n \n10\n \n# assign b to a new value of 10\n\n \n=\n \n10\n\n\n2\n.\n2\n.\n5\n \n:\n050\n \n \nb\n \n||=\n \n5\n \n# assign 5 if b does not have a value\n\n \n=\n \n10\n \n# b have a value so we get the value already assigned\n\n\n\n\n\n\nPerforming the same operation above only using the ||(logical OR) operator results in  an error as follows :\n\n\n \n \na\n \n||\n \n5\n\n\nNameError\n:\n \nundefined\n \nlocal\n \nvariable\n \nor\n \nmethod\n \n`a\n for main:Object\n\n\n\n\n\n\nRange Operators\n\n\nRange operators are used to implement sequences, conditions and intervals.\n\n\nRange operator\n\n\nWe define the range with ..(inclusive) or ...(exclusive) operators.\n\n\nInclusive range operator\n\n\n \n(\n1\n..\n3\n)\n.\neach\n \n{\n|\ni\n|\n \np\n \ni\n}\n\n\n1\n\n\n2\n\n\n3\n\n \n=\n \n1\n..\n3\n\n\n\n\n\n\nExclusive range operator\n\n\n \n(\n1\n...\n3\n)\n.\neach\n \n{\n|\ni\n|\n \np\n \ni\n}\n\n\n1\n\n\n2\n\n \n=\n \n1\n...\n3\n\n\n\n\n\n\nVerify that the class is a range :\n\n\n \n(\n1\n..\n2\n)\n.\nclass\n\n \n=\n \nRange\n\n\n\n\n\n\nConvert a range to array\n\n\nWe can convert the Range to an array using the \nto_a\n as follows :\n\n\n \n(\n1\n..\n5\n)\n.\nto_a\n\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nConvert to an enum\n\n\nWe can also convert the range to an enumerable using \nto_enum\n as follows :\n\n\n \n \nn\n \n=\n \n(\n1\n..\n5\n)\n.\nto_enum\n\n \n=\n \n#\nEnumerator: 1..5:each\n\n\n2\n.\n2\n.\n5\n \n:\n060\n \n \nn\n.\nnext\n\n \n=\n \n1\n\n\n2\n.\n2\n.\n5\n \n:\n061\n \n \nn\n.\nnext\n\n \n=\n \n2\n\n\n\n\n\n\nWe can also create and convert range of type character as follows :\n\n\n \nalphabet\n \n=\n \n(\na\n..\nz\n)\n.\nto_enum\n\n \n=\n \n#\nEnumerator: \na\n..\nz\n:each\n\n\n2\n.\n2\n.\n5\n \n:\n065\n \n \nalphabet\n.\nnext\n\n \n=\n \na\n \n\n2\n.\n2\n.\n5\n \n:\n066\n \n \nalphabet\n.\nnext\n\n \n=\n \nb", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#ruby-operators", 
            "text": "Ruby operators can be broadly categorized into the following :    Arithmetic  Shift or Append  Comparison  Booleans  Ranges", 
            "title": "Ruby Operators"
        }, 
        {
            "location": "/operators/#arithmetic-operators", 
            "text": "The arithmetic operators are :   +  - Addition  -  - Subtraction  *  - Multiplication  **  - Exponential  /  - Division  %  - Modulo", 
            "title": "Arithmetic Operators"
        }, 
        {
            "location": "/operators/#addition", 
            "text": "1   +   1 \n  =   2", 
            "title": "Addition"
        }, 
        {
            "location": "/operators/#division", 
            "text": "5   /   2 \n  =   2   To get 2.5 as the answer you will need to use floating point numbers as follows :    5 . 0   /   2 . 0 \n  =   2 . 5", 
            "title": "Division"
        }, 
        {
            "location": "/operators/#modulo", 
            "text": "Remainder division    5   %   2 \n  =   1   You will get an exception if you try to divide by 0.    2   / 0  ZeroDivisionError :   divided   by   0 \n     from   ( irb ): 9 :in   `/   Floating point division with 0 will give  Infinity  as a result.    2 . 0   /   0 . 0 \n  =   Infinity", 
            "title": "Modulo"
        }, 
        {
            "location": "/operators/#addition-on-arrays", 
            "text": "We can apply addition to arrays, the result in a concatenation of the two arrays as follows :    [ 1 , 2 ]   +   [ 3 , 4 , 5 ] \n  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]", 
            "title": "Addition on Arrays"
        }, 
        {
            "location": "/operators/#arithmetic-operators-on-strings", 
            "text": "We can also apply arithmetic operators on string objects as follows :    Hello world    *   2 \n  =   Hello world Hello world    Only the multiplication operator works, other arithmetic operators will produce an error.", 
            "title": "Arithmetic Operators on Strings"
        }, 
        {
            "location": "/operators/#exponential-operators", 
            "text": "We use the  **  for exponent as follows :      2   **   2 \n  =   4", 
            "title": "Exponential Operators"
        }, 
        {
            "location": "/operators/#shift-operators", 
            "text": "We can use the two shift operators,   and  . This allows us to manipulate the numbers in binary. E.g we can easily get a 4 by shifting the 2 in binary by 1 as follows.    2     1 \n  =   4   Here is how it works. The number 2 in binary is represented as 10. When we shift by 1 we push an additional 0 at the end, so we now get the number 100, which is 4 in binary.  We can display the value of 2 in binary using the  to_s(2)  method as follows :    2 . to_s ( 2 ) \n  =   10   We can see that 2 in binary is 10.  If we change the operator and push to the right, we now remove the leading 0.    2     1 \n  =   1   We now get a 1 since we removed the leading 0 from 10.  We can shift with more bits if we prefer, e.g. to get the value 8 we can push 2 by 3 bits as follows :    2     2 \n  =   8", 
            "title": "Shift operators"
        }, 
        {
            "location": "/operators/#append-operator", 
            "text": "The same operator for left shifting,   is for appending on arrays.    nums   =   [] \n  =   []   2 . 2 . 5   : 02 9     nums     1 \n  =   [ 1 ]   2 . 2 . 5   : 030     nums     2 \n  =   [ 1 ,   2 ]   We could also apply the append multiple times as follows :      nums     3     4 \n  =   [ 1 ,   2 ,   3 ,   4 ]", 
            "title": "Append Operator"
        }, 
        {
            "location": "/operators/#output-to-standard-output", 
            "text": "The   operator is also used to output to Standard Output as follows :      STDOUT     Hello World  Hello   World   =   # IO: STDOUT", 
            "title": "Output to Standard Output"
        }, 
        {
            "location": "/operators/#comparison-operators", 
            "text": "- Less than operator  = - Less then or equal to operator     Greater than operator       = - Greater than operator    =  - Comparable operator  != - Not equal to operator", 
            "title": "Comparison Operators"
        }, 
        {
            "location": "/operators/#comparable-operator", 
            "text": "The other operators perform exactly as they are supposed to except the comparable operator. The comparable operator works as follows :   Returns -1 if the left hand value is less than the right hand operand  Returns 1 if the left hand operand is greater than the right hand operand  Return 0 is they are equal  Returns nil if they can not be compared     2   =   2 \n  =   0     1   =   2 \n  =   - 1     2   =   1 \n  =   1", 
            "title": "Comparable operator &lt;=&gt;"
        }, 
        {
            "location": "/operators/#boolean-operators", 
            "text": "- Logical AND operator  || - Logical OR operator  ! - NOT operator", 
            "title": "Boolean Operators"
        }, 
        {
            "location": "/operators/#operator", 
            "text": "The operator returns tru if all the operands are true or false otherwise.    10     0     10     9 \n  =   false", 
            "title": "&amp;&amp; operator"
        }, 
        {
            "location": "/operators/#operator_1", 
            "text": "The logical OR operator returns true if any of the operands returns true. It returns false if both operands return false.    10     0   ||   10   ==   10 \n  =   true", 
            "title": "|| operator"
        }, 
        {
            "location": "/operators/#not-operator", 
            "text": "Negates the operand.    ! true \n  =   false     ! false \n  =   true", 
            "title": "! NOT Operator"
        }, 
        {
            "location": "/operators/#or-equal", 
            "text": "This operator returns the current value if its initialized or initializes the new value.    b   ||=   5   # b is not defined, so we get 5 \n  =   5  2 . 2 . 5   : 04 9     b   =   10   # assign b to a new value of 10 \n  =   10  2 . 2 . 5   : 050     b   ||=   5   # assign 5 if b does not have a value \n  =   10   # b have a value so we get the value already assigned   Performing the same operation above only using the ||(logical OR) operator results in  an error as follows :      a   ||   5  NameError :   undefined   local   variable   or   method   `a  for main:Object", 
            "title": "||= OR Equal"
        }, 
        {
            "location": "/operators/#range-operators", 
            "text": "Range operators are used to implement sequences, conditions and intervals.", 
            "title": "Range Operators"
        }, 
        {
            "location": "/operators/#range-operator", 
            "text": "We define the range with ..(inclusive) or ...(exclusive) operators.", 
            "title": "Range operator"
        }, 
        {
            "location": "/operators/#inclusive-range-operator", 
            "text": "( 1 .. 3 ) . each   { | i |   p   i }  1  2  3 \n  =   1 .. 3", 
            "title": "Inclusive range operator"
        }, 
        {
            "location": "/operators/#exclusive-range-operator", 
            "text": "( 1 ... 3 ) . each   { | i |   p   i }  1  2 \n  =   1 ... 3   Verify that the class is a range :    ( 1 .. 2 ) . class \n  =   Range", 
            "title": "Exclusive range operator"
        }, 
        {
            "location": "/operators/#convert-a-range-to-array", 
            "text": "We can convert the Range to an array using the  to_a  as follows :    ( 1 .. 5 ) . to_a \n  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]", 
            "title": "Convert a range to array"
        }, 
        {
            "location": "/operators/#convert-to-an-enum", 
            "text": "We can also convert the range to an enumerable using  to_enum  as follows :      n   =   ( 1 .. 5 ) . to_enum \n  =   # Enumerator: 1..5:each  2 . 2 . 5   : 060     n . next \n  =   1  2 . 2 . 5   : 061     n . next \n  =   2   We can also create and convert range of type character as follows :    alphabet   =   ( a .. z ) . to_enum \n  =   # Enumerator:  a .. z :each  2 . 2 . 5   : 065     alphabet . next \n  =   a   2 . 2 . 5   : 066     alphabet . next \n  =   b", 
            "title": "Convert to an enum"
        }, 
        {
            "location": "/strings/", 
            "text": "String Literals\n\n\nString literals are surrounded by single or double quotes.\n\n\n \nputs\n \nHello World\n\n\nHello\n \nWorld\n\n\n\n\n\n\nDouble quoted string literals allows for string interpolation. Here is an example with interpolation using double quoted string literals :\n\n\n2\n.\n2\n.\n5\n \n:\n076\n \n \nputs\n \nHello World\n\n\nHello\n \nWorld\n\n \n=\n \nnil\n\n\n2\n.\n2\n.\n5\n \n:\n077\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n07\n8\n \n \nputs\n \nHello \n#{\nname\n}\n\n\nHello\n \nJoseph\n\n \n=\n \nnil\n\n\n\n\n\n\ninterpolation does not work with single quotes :\n\n\n2\n.\n2\n.\n5\n \n:\n080\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n \n\n2\n.\n2\n.\n5\n \n:\n081\n \n \nputs\n \nHello #{name}\n\n\nHello\n \n#{name}\n\n \n=\n \nnil\n \n\n\n\n\n\nQuoting inside string literlas\n\n\nWe can use single quotes inside double quotes as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n082\n \n \nputs\n \nJoseph\ns iPhone\n\n\nJoseph\ns\n \niPhone\n\n \n=\n \nnil\n\n\n\n\n\n\nWe can use an escape character if we really want the double quote inside the double quoted string literal as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n085\n \n \nputs\n \nJoseph\n\\\ns iPhone\n\n\nJoseph\ns iPhone\n\n\n =\n nil\n\n\n\n\n\n\nEscape Characters\n\n\n\n\n\\\" -\u00a0Escaping \u00a0double quote using \u00a0backslash\n\n\n\\ -\u00a0Escaping \u00a0backslash with another backslash\n\n\n\\a -\u00a0Bell/Alert\n\n\n\\b -\u00a0Backspace\n\n\n\\r -\u00a0Carriage Return\n\n\n\\n -\u00a0New Line\n\n\n\\s -\u00a0Space\n\n\n\\t -\u00a0Tab\n\n\n\n\nString interpolation\n\n\nString interpolation allows the substitution of a variable inside a string literal. We us the \n#{variable_name}\n as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n086\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n087\n \n \ncompany\n \n=\n \nPeruzal\n\n \n=\n \nPeruzal\n\n\n2\n.\n2\n.\n5\n \n:\n088\n \n \nputs\n \nMy name is \n#{\nname\n}\n and i work at \n#{\ncompany\n}\n\n\nMy\n \nname\n \nis\n \nJoseph\n \nand\n \ni\n \nwork\n \nat\n \nPeruzal\n\n \n=\n \nnil\n\n\n\n\n\n\nHERE Doc\n\n\nWe can have multiple lines of string literals by using HERE doc instead of the double or single quotes. A HERE doc start with \nANY_WORD_HERE\n and end sa new line with \nANY_WORD_HERE\n. Here is an example\n\n\n2\n.\n2\n.\n5\n \n:\n093\n \n \nputs\n \nEND\n\n\n2.2.5 :094\n This is an example\n\n\n2.2.5 :095\n of a string that\n\n\n2.2.5 :096\n spans over multiple lines.\n\n\n2.2.5 :097\n END\n\n\nThis is an example\n\n\nof a string that\n\n\nspans over multiple lines.\n\n\n =\n nil\n\n\n2\n.\n2\n.\n5\n \n:\n094\n This is an example\n\n\n2.2.5 :095\n \nof\n \na\n \nstring\n \nthat\n\n\n2\n.\n2\n.\n5\n \n:\n096\n spans over multiple lines.\n\n\n2.2.5 :097\n \nEND\n\n\nThis\n \nis\n \nan\n \nexample\n\n\nof\n \na\n \nstring\n \nthat\n\n\nspans\n \nover\n \nmultiple\n \nlines\n.\n\n \n=\n \nnil\n\n\n\n\n\n\nThe HERE does starts with \nEND\n and finishes with \nEND\n.\n\n\nPrinting without a new line\n\n\nTo output without adding a new line we use \nprint\n instead of \nputs\n as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n098\n \n \nprint\n \nHello World\n\n\nHello\n \nWorld\n \n=\n \nnil\n\n\n\n\n\n\nString delimiters\n\n\nWe can use a character to delimit the start and end of a string as follows :\n\n\n%q*Start and end of character*\n\n\n\n\n\n\nString Methods\n\n\nThe String type have a lot of methods, we will look at a subset below :\n\n\n\n\ndowncase\n\n\nupcase\n\n\ncapitalize\n\n\nswapcase\n\n\nlength\n\n\nempty?\n\n\n\n\nConcatenating Strings\n\n\nWe can use the + operator to concatenate strings as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n113\n \n \nputs\n \nHello \n \n+\n \nWorld\n\n\nHello\n \nWorld\n\n \n=\n \nnil\n\n\n\n\n\n\nWe can concatenate using string interpolation as well :\n\n\n2\n.\n2\n.\n5\n \n:\n114\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n115\n \n \nputs\n \nMy name is \n#{\nname\n}\n\n\nMy\n \nname\n \nis\n \nJoseph\n\n \n=\n \nnil\n\n\n\n\n\n\nExtracting character from strings\n\n\nWe can use the \n[]\n to extract character or substrings from a string as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n116\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n \n\n2\n.\n2\n.\n5\n \n:\n117\n \n \nname\n[\n0\n]\n\n \n=\n \nJ\n\n\n\n\n\n\nWe can also pass a range and extract a substring :\n\n\n2\n.\n2\n.\n5\n \n:\n120\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n121\n \n \nname\n[\n0\n...\n3\n]\n\n \n=\n \nJos\n\n\n\n\n\n\nWe can also use negative numbers to begin extracting from the end of the string as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n122\n \n \nname\n \n=\n \nJoseph\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n123\n \n \nname\n[-\n1\n]\n\n \n=\n \nh\n\n\n\n\n\n\nSplitting strings\n\n\nWe use the \nsplit\n method to split a string. You will need to choose the character to use to split the string as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n126\n \n \nfull_name\n.\nsplit\n()\n\n \n=\n \n[\nJosep\n,\n \nKandi\n]\n\n\n\n\n\n\nUsing a comma to split as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n127\n \n \nfruits\n \n=\n \nOranges,Apples,Mangoes\n\n \n=\n \nOranges,Apples,Mangoes\n\n\n2\n.\n2\n.\n5\n \n:\n128\n \n \nfruits\n.\nsplit\n(\n,\n)\n\n \n=\n \n[\nOranges\n,\n \nApples\n,\n \nMangoes\n]\n\n\n\n\n\n\nWe can split the string directly into variables as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n129\n \n \ndata\n \n=\n \nJoseph,Kandi,Peruzal\n\n \n=\n \nJoseph,Kandi,Peruzal\n\n\n2\n.\n2\n.\n5\n \n:\n130\n \n \nfirst_name\n,\nlast_name\n,\ncompany\n \n=\n \ndata\n.\nsplit\n(\n,\n)\n\n \n=\n \n[\nJoseph\n,\n \nKandi\n,\n \nPeruzal\n]\n\n\n2\n.\n2\n.\n5\n \n:\n131\n \n \nfirst_name\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n132\n \n \ncompany\n\n \n=\n \nPeruzal\n\n\n\n\n\n\nRegular Expressions\n\n\nRegular expressions allows for pattern matching. In Ruby they are multiple ways to match a paatern :\n\n\n\n\nUse the \n=~\n\n\nUse \n%r{pattern}\n\n\nUse \n/pattern/\n\n\nThe \nRegexp\n class\n\n\nThe \nmatch\n method on the String class\n\n\n\n\nMatching with =~\n\n\nname\n \n=\n \nMy name is Joseph Kandi\n\n\nname\n \n=~\n \n/Joseph/\n \n# note that we are providing a pattern using //\n\n\n=\n \n11\n\n\n\n\n\n\nThe \n=~\n will return the starting position of the match.\n\n\nMatching with %r{}\n\n\nWe could have written the above as follows :\n\n\nname\n \n=\n \nMy name is Joseph Kandi\n\n\n%r{Joseph}\n \n=~\n \nname\n \n# note Joseph is not a string but a pattern\n\n\n=\n \n11\n\n\n\n\n\n\nWill return the same result.\n\n\nUsing the match method\n\n\nWe could also have used the \nmatch\n method on the String class as follows :\n\n\nname\n \n=\n \nMy name is Joseph Kandi\n\n\nname\n.\nmatch\n(\n/Joseph/\n)\n \n# note Joseph is not a string but a pattern\n\n \n=\n \n#\nMatchData \nJoseph\n\n\n\n\n\n\nThe \nmatch\n method returns \nnil\n if it cant find the match. The match data can be accessed with global variables :\n\n\n2\n.\n2\n.\n5\n \n:\n067\n \n \n$~\n \n# Match object\n\n \n=\n \n#\nMatchData \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n06\n8\n \n \n$\n \n# The last match\n\n \n=\n \nJoseph\n\n\n2\n.\n2\n.\n5\n \n:\n06\n9\n \n \n$\n \n# pre match\n\n \n=\n \n Kandi\n\n\n2\n.\n2\n.\n5\n \n:\n070\n \n \n$`\n \n# post match\n\n \n=\n \nMy name is \n\n\n\n\n\n\n$1, $2, etc Contains text matching first, second, etc. capture group.\n\n\nNegative match\n\n\nWe can use the \n!~\n for a negative match :\n\n\nd\n \n=\n \n0114804898\n\n\n%r{d+}\n \n!~\n \nd\n \n# one or more digits\n\n\n=\n \ntrue\n \n# returns true of false\n\n\n\n\n\n\nModifiers (options)\n\n\n\n\n/pattern/i\n - Ignore case (or constant Regexp::IGNORECASE)\n\n\n/pattern/m\n - Treat a newline as a character matched by a full stop or period (.) (or constant Regexp::MULTILINE)\n\n\n/pattern/x\n - Ignore whitespace and comments in the pattern (or constant Regexp::EXTENDED)\n\n\n/pattern/o\n - Perform #{} interpolation only once\n\n\n\n\nString Exercises\n\n\n\n\nWhat is the character used for string interpolation?\n\n\n\n\nYou have the following code and you want to interpolate the variable :\n\n\n```ruby\nnumber = 50\n\n\nputs \"The number is \"\n\n\nUse the `number` variable and output `The number is 50` using string interpolation.\n3. Show the number after and prior using string interpolation\nruby\nnumber = 50\n\n\nputs \"The number is and prior is and next is\"\n\n\n4. Reverse the string \".sdrawkcab si gnirts sihT\" permanently using a method on the String class.\n5. Make the following code snippet read properly by using the `split`, `reverse` and `join` methods on the String class :\nruby\ns = \"order. wrong the in are words These\"\n```\n6. Why are symbols more preferred than using Strings?\n8. Enumerate over the String, \"Ruby is awesome\" one character at a time. Show two ways of enumerating the String.\n9. Show the frequencies of each word in a sentence. Use any sentence.\n10. Make the String \"Ruby\" lowercased.\n11. Make all vowels in a sentence uppercase. Show different ways of achieving it.\n12. Check if the following String is really a String, \"Ruby is a programming language\". Hint, use duck typing.\n13. Extract the substring \"language\" from the String \"Ruby language\". Show two ways.\n14. Generate the full aplhabet without typing the characters manually.\n15. Generate the full alphabet in reverse order.\n16. Write a Ruby snippet to check for a valid email address.\n17. Extract the domain name and check if the MX record is valid. Use the code below for validating the domain :\n\n\n\n\n\n\nResolv\n::\nDNS\n.\nnew\n.\ngetresource\n(\nhostname\n,\n \nResolv\n::\nDNS\n::\nResource\n::\nIN\n::\nMX\n)\n\n\n\n\n\n\n\n\nWrite Ruby code to check for a valid IP address.\n\n\nCheck a string whether is a number, a letter or a mixed set of letters and number.\n\n\nCheck is a word is a palindrome or not. Test with the following words :\n\n\n\n\nA\n \nbut\n \ntuba\n\n\nA\n \nman\n,\n \na\n \nplan\n,\n \na\n \ncanal\n:\n \nPanama\n\n\nA\n \nSanta\n \nat\n \nNasa\n\n\nAnne\n,\n \nI\n \nvote\n \nmore\n \ncars\n \nrace\n \nRome\n \nto\n \nVienna\n\n\n\n\n\n\nSolution to Exercises\n\n\nIn Ruby they are many ways of doing things, the snippets here are just one way of solving the exercises.\n\n\n\n\nThe \n#{}\n is used for string interpolation.\n\n\n\n\nBy using string interpolation, the code will be :\n\n\nruby\nnumber = 50\nputs \"The number is #{number}\"\n\n3. The code to show the number before and after is as follows :\n\n\nruby\nnumber = 50\nputs \"The number is #{number} and prior #{number -1} is and next is #{number.succ}\"\n\n\n\n\n\n\nThe code to reverse permanently is to use the \nreverse!\n method as follows :\n\n\nruby\nsentence = \".sdrawkcab si gnirts sihT\".reverse!\n\n\n\n\n\n\nWe first use the \nsplit\n method to make the string an array, then reverse the array using the \nreverse\n method and then join the reversed array using the \njoin\n method.\n\n\nruby\ns = \"order. wrong the in are words These\"\ns.split.reverse.join(\" \")\n\n\n\n\n\n\nThere's only one version of the symbols as shown by the code below :\n\n\nruby\n:name.object_id # will always return the same object id\n\"name\".object_id # generates a new object id each time\n\"name\".object_id # generates a new object id not similar to the previous string\n\n\n\n\n\n\nWe can use the \nscan\n method on the string class and use a regex to find all word then iterate through them as follows :\n\n\nruby\ns =  \"Ruby is awesome\"\ns.scan(/\\w+/) { |w| puts w}\n\n\nor we could split the string using the \nsplit\n method, this turns it into an array and now we can now use the \neach\n method as follows :\n\nruby\ns.split().each {|w| p w}\n\n8.  To generate frequencies we can use a Hash that is initialized with zero values for keys that do not exist using the \nHash.new(0)\n as follows :\n\n\nruby\nfreq = Hash.new(0)\ns = \"Show the frequencies of each word in a sentence. Use any sentence\"\ns.scan(/\\w+/) {|w| freq[w] += 1}\nputs freq\nfreq.each {|k,v| p \"#{k} #{v}\"} # loop through the key and values\n\n9. We can use the downcase method as follows \n\"Ruby\".downcase\n.\n10. We can us the \ntr\n method that translates a character or we can use the global substitution \ngsub\n methods as follows :\n\n\nruby\ns = \"Make all vowels in a sentence uppercase.\"\ns.tr(\"aeiou\", \"AEIOU\")\n\n16. Check for a valid email, we can use a regex as follows :\n\n\n```ruby\nemail = 'joseph@peruzal.com' # test email address\nvalid = '[^@]+' # exclude invlaid character in the email\nemail =~ /^#{valid}@#{valid}.#{valid}$/ # validate the email\n\n\nvalid = '[A-Za-z\\d.+-]+' # we could use for commonly encountered email addresses\n```\n17. We can extract the domain and also check for the MX records as follows :\n\n\n```ruby\nrequire 'resolv'\n\n\ndef valid_email_host?(email)\n    hostname = email[(email =~ /@/)+1..email.length] valid = true\n        begin\n            Resolv::DNS.new.getresource(hostname, Resolv::DNS::Resource::IN::MX) \n        rescue Resolv::ResolvError\n            valid = false\n        end\n    return valid\nend\n```\n18. We can use the regex together with a case statement as follows :\n\n\nruby\nstring = \"123\"\ncase string\nwhen /^[a-zA-Z]+$/\n\"Letters\"\nwhen /^[0-9]+$/ \"Numbers\"\nelse\n\"Mixed\"\nend", 
            "title": "Strings"
        }, 
        {
            "location": "/strings/#string-literals", 
            "text": "String literals are surrounded by single or double quotes.    puts   Hello World  Hello   World   Double quoted string literals allows for string interpolation. Here is an example with interpolation using double quoted string literals :  2 . 2 . 5   : 076     puts   Hello World  Hello   World \n  =   nil  2 . 2 . 5   : 077     name   =   Joseph \n  =   Joseph  2 . 2 . 5   : 07 8     puts   Hello  #{ name }  Hello   Joseph \n  =   nil   interpolation does not work with single quotes :  2 . 2 . 5   : 080     name   =   Joseph \n  =   Joseph   2 . 2 . 5   : 081     puts   Hello #{name}  Hello   #{name} \n  =   nil", 
            "title": "String Literals"
        }, 
        {
            "location": "/strings/#quoting-inside-string-literlas", 
            "text": "We can use single quotes inside double quotes as follows :  2 . 2 . 5   : 082     puts   Joseph s iPhone  Joseph s   iPhone \n  =   nil   We can use an escape character if we really want the double quote inside the double quoted string literal as follows :  2 . 2 . 5   : 085     puts   Joseph \\ s iPhone  Joseph s iPhone   =  nil", 
            "title": "Quoting inside string literlas"
        }, 
        {
            "location": "/strings/#escape-characters", 
            "text": "\\\" -\u00a0Escaping \u00a0double quote using \u00a0backslash  \\ -\u00a0Escaping \u00a0backslash with another backslash  \\a -\u00a0Bell/Alert  \\b -\u00a0Backspace  \\r -\u00a0Carriage Return  \\n -\u00a0New Line  \\s -\u00a0Space  \\t -\u00a0Tab", 
            "title": "Escape Characters"
        }, 
        {
            "location": "/strings/#string-interpolation", 
            "text": "String interpolation allows the substitution of a variable inside a string literal. We us the  #{variable_name}  as follows :  2 . 2 . 5   : 086     name   =   Joseph \n  =   Joseph  2 . 2 . 5   : 087     company   =   Peruzal \n  =   Peruzal  2 . 2 . 5   : 088     puts   My name is  #{ name }  and i work at  #{ company }  My   name   is   Joseph   and   i   work   at   Peruzal \n  =   nil", 
            "title": "String interpolation"
        }, 
        {
            "location": "/strings/#here-doc", 
            "text": "We can have multiple lines of string literals by using HERE doc instead of the double or single quotes. A HERE doc start with  ANY_WORD_HERE  and end sa new line with  ANY_WORD_HERE . Here is an example  2 . 2 . 5   : 093     puts   END  2.2.5 :094  This is an example  2.2.5 :095  of a string that  2.2.5 :096  spans over multiple lines.  2.2.5 :097  END  This is an example  of a string that  spans over multiple lines.   =  nil  2 . 2 . 5   : 094  This is an example  2.2.5 :095   of   a   string   that  2 . 2 . 5   : 096  spans over multiple lines.  2.2.5 :097   END  This   is   an   example  of   a   string   that  spans   over   multiple   lines . \n  =   nil   The HERE does starts with  END  and finishes with  END .", 
            "title": "HERE Doc"
        }, 
        {
            "location": "/strings/#printing-without-a-new-line", 
            "text": "To output without adding a new line we use  print  instead of  puts  as follows :  2 . 2 . 5   : 098     print   Hello World  Hello   World   =   nil", 
            "title": "Printing without a new line"
        }, 
        {
            "location": "/strings/#string-delimiters", 
            "text": "We can use a character to delimit the start and end of a string as follows :  %q*Start and end of character*", 
            "title": "String delimiters"
        }, 
        {
            "location": "/strings/#string-methods", 
            "text": "The String type have a lot of methods, we will look at a subset below :   downcase  upcase  capitalize  swapcase  length  empty?", 
            "title": "String Methods"
        }, 
        {
            "location": "/strings/#concatenating-strings", 
            "text": "We can use the + operator to concatenate strings as follows :  2 . 2 . 5   : 113     puts   Hello    +   World  Hello   World \n  =   nil   We can concatenate using string interpolation as well :  2 . 2 . 5   : 114     name   =   Joseph \n  =   Joseph  2 . 2 . 5   : 115     puts   My name is  #{ name }  My   name   is   Joseph \n  =   nil", 
            "title": "Concatenating Strings"
        }, 
        {
            "location": "/strings/#extracting-character-from-strings", 
            "text": "We can use the  []  to extract character or substrings from a string as follows :  2 . 2 . 5   : 116     name   =   Joseph \n  =   Joseph   2 . 2 . 5   : 117     name [ 0 ] \n  =   J   We can also pass a range and extract a substring :  2 . 2 . 5   : 120     name   =   Joseph \n  =   Joseph  2 . 2 . 5   : 121     name [ 0 ... 3 ] \n  =   Jos   We can also use negative numbers to begin extracting from the end of the string as follows :  2 . 2 . 5   : 122     name   =   Joseph \n  =   Joseph  2 . 2 . 5   : 123     name [- 1 ] \n  =   h", 
            "title": "Extracting character from strings"
        }, 
        {
            "location": "/strings/#splitting-strings", 
            "text": "We use the  split  method to split a string. You will need to choose the character to use to split the string as follows :  2 . 2 . 5   : 126     full_name . split () \n  =   [ Josep ,   Kandi ]   Using a comma to split as follows :  2 . 2 . 5   : 127     fruits   =   Oranges,Apples,Mangoes \n  =   Oranges,Apples,Mangoes  2 . 2 . 5   : 128     fruits . split ( , ) \n  =   [ Oranges ,   Apples ,   Mangoes ]   We can split the string directly into variables as follows :  2 . 2 . 5   : 129     data   =   Joseph,Kandi,Peruzal \n  =   Joseph,Kandi,Peruzal  2 . 2 . 5   : 130     first_name , last_name , company   =   data . split ( , ) \n  =   [ Joseph ,   Kandi ,   Peruzal ]  2 . 2 . 5   : 131     first_name \n  =   Joseph  2 . 2 . 5   : 132     company \n  =   Peruzal", 
            "title": "Splitting strings"
        }, 
        {
            "location": "/strings/#regular-expressions", 
            "text": "Regular expressions allows for pattern matching. In Ruby they are multiple ways to match a paatern :   Use the  =~  Use  %r{pattern}  Use  /pattern/  The  Regexp  class  The  match  method on the String class", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/strings/#matching-with", 
            "text": "name   =   My name is Joseph Kandi  name   =~   /Joseph/   # note that we are providing a pattern using //  =   11   The  =~  will return the starting position of the match.", 
            "title": "Matching with =~"
        }, 
        {
            "location": "/strings/#matching-with-r", 
            "text": "We could have written the above as follows :  name   =   My name is Joseph Kandi  %r{Joseph}   =~   name   # note Joseph is not a string but a pattern  =   11   Will return the same result.", 
            "title": "Matching with %r{}"
        }, 
        {
            "location": "/strings/#using-the-match-method", 
            "text": "We could also have used the  match  method on the String class as follows :  name   =   My name is Joseph Kandi  name . match ( /Joseph/ )   # note Joseph is not a string but a pattern \n  =   # MatchData  Joseph   The  match  method returns  nil  if it cant find the match. The match data can be accessed with global variables :  2 . 2 . 5   : 067     $~   # Match object \n  =   # MatchData  Joseph  2 . 2 . 5   : 06 8     $   # The last match \n  =   Joseph  2 . 2 . 5   : 06 9     $   # pre match \n  =    Kandi  2 . 2 . 5   : 070     $`   # post match \n  =   My name is    $1, $2, etc Contains text matching first, second, etc. capture group.", 
            "title": "Using the match method"
        }, 
        {
            "location": "/strings/#negative-match", 
            "text": "We can use the  !~  for a negative match :  d   =   0114804898  %r{d+}   !~   d   # one or more digits  =   true   # returns true of false", 
            "title": "Negative match"
        }, 
        {
            "location": "/strings/#modifiers-options", 
            "text": "/pattern/i  - Ignore case (or constant Regexp::IGNORECASE)  /pattern/m  - Treat a newline as a character matched by a full stop or period (.) (or constant Regexp::MULTILINE)  /pattern/x  - Ignore whitespace and comments in the pattern (or constant Regexp::EXTENDED)  /pattern/o  - Perform #{} interpolation only once", 
            "title": "Modifiers (options)"
        }, 
        {
            "location": "/strings/#string-exercises", 
            "text": "What is the character used for string interpolation?   You have the following code and you want to interpolate the variable :  ```ruby\nnumber = 50", 
            "title": "String Exercises"
        }, 
        {
            "location": "/strings/#puts-the-number-is", 
            "text": "Use the `number` variable and output `The number is 50` using string interpolation.\n3. Show the number after and prior using string interpolation ruby\nnumber = 50", 
            "title": "puts \"The number is \""
        }, 
        {
            "location": "/strings/#puts-the-number-is-and-prior-is-and-next-is", 
            "text": "4. Reverse the string \".sdrawkcab si gnirts sihT\" permanently using a method on the String class.\n5. Make the following code snippet read properly by using the `split`, `reverse` and `join` methods on the String class : ruby\ns = \"order. wrong the in are words These\"\n```\n6. Why are symbols more preferred than using Strings?\n8. Enumerate over the String, \"Ruby is awesome\" one character at a time. Show two ways of enumerating the String.\n9. Show the frequencies of each word in a sentence. Use any sentence.\n10. Make the String \"Ruby\" lowercased.\n11. Make all vowels in a sentence uppercase. Show different ways of achieving it.\n12. Check if the following String is really a String, \"Ruby is a programming language\". Hint, use duck typing.\n13. Extract the substring \"language\" from the String \"Ruby language\". Show two ways.\n14. Generate the full aplhabet without typing the characters manually.\n15. Generate the full alphabet in reverse order.\n16. Write a Ruby snippet to check for a valid email address.\n17. Extract the domain name and check if the MX record is valid. Use the code below for validating the domain :    Resolv :: DNS . new . getresource ( hostname ,   Resolv :: DNS :: Resource :: IN :: MX )    Write Ruby code to check for a valid IP address.  Check a string whether is a number, a letter or a mixed set of letters and number.  Check is a word is a palindrome or not. Test with the following words :   A   but   tuba  A   man ,   a   plan ,   a   canal :   Panama  A   Santa   at   Nasa  Anne ,   I   vote   more   cars   race   Rome   to   Vienna", 
            "title": "puts \"The number is and prior is and next is\""
        }, 
        {
            "location": "/strings/#solution-to-exercises", 
            "text": "In Ruby they are many ways of doing things, the snippets here are just one way of solving the exercises.   The  #{}  is used for string interpolation.   By using string interpolation, the code will be :  ruby\nnumber = 50\nputs \"The number is #{number}\" \n3. The code to show the number before and after is as follows :  ruby\nnumber = 50\nputs \"The number is #{number} and prior #{number -1} is and next is #{number.succ}\"    The code to reverse permanently is to use the  reverse!  method as follows :  ruby\nsentence = \".sdrawkcab si gnirts sihT\".reverse!    We first use the  split  method to make the string an array, then reverse the array using the  reverse  method and then join the reversed array using the  join  method.  ruby\ns = \"order. wrong the in are words These\"\ns.split.reverse.join(\" \")    There's only one version of the symbols as shown by the code below :  ruby\n:name.object_id # will always return the same object id\n\"name\".object_id # generates a new object id each time\n\"name\".object_id # generates a new object id not similar to the previous string    We can use the  scan  method on the string class and use a regex to find all word then iterate through them as follows :  ruby\ns =  \"Ruby is awesome\"\ns.scan(/\\w+/) { |w| puts w}  or we could split the string using the  split  method, this turns it into an array and now we can now use the  each  method as follows : ruby\ns.split().each {|w| p w} \n8.  To generate frequencies we can use a Hash that is initialized with zero values for keys that do not exist using the  Hash.new(0)  as follows :  ruby\nfreq = Hash.new(0)\ns = \"Show the frequencies of each word in a sentence. Use any sentence\"\ns.scan(/\\w+/) {|w| freq[w] += 1}\nputs freq\nfreq.each {|k,v| p \"#{k} #{v}\"} # loop through the key and values \n9. We can use the downcase method as follows  \"Ruby\".downcase .\n10. We can us the  tr  method that translates a character or we can use the global substitution  gsub  methods as follows :  ruby\ns = \"Make all vowels in a sentence uppercase.\"\ns.tr(\"aeiou\", \"AEIOU\") \n16. Check for a valid email, we can use a regex as follows :  ```ruby\nemail = 'joseph@peruzal.com' # test email address\nvalid = '[^@]+' # exclude invlaid character in the email\nemail =~ /^#{valid}@#{valid}.#{valid}$/ # validate the email  valid = '[A-Za-z\\d.+-]+' # we could use for commonly encountered email addresses\n```\n17. We can extract the domain and also check for the MX records as follows :  ```ruby\nrequire 'resolv'  def valid_email_host?(email)\n    hostname = email[(email =~ /@/)+1..email.length] valid = true\n        begin\n            Resolv::DNS.new.getresource(hostname, Resolv::DNS::Resource::IN::MX) \n        rescue Resolv::ResolvError\n            valid = false\n        end\n    return valid\nend\n```\n18. We can use the regex together with a case statement as follows :  ruby\nstring = \"123\"\ncase string\nwhen /^[a-zA-Z]+$/\n\"Letters\"\nwhen /^[0-9]+$/ \"Numbers\"\nelse\n\"Mixed\"\nend", 
            "title": "Solution to Exercises"
        }, 
        {
            "location": "/arrays/", 
            "text": "Arrays\n\n\nArrays are a collection of items. In Ruby, arrays can take a collection of any type. An array is an ordered list of elements. Each element is a reference to some object.\n\n\nCreating Arrays\n\n\nTo create an a array you use the \n[]\n symbols. We can create an empty array as follows :\n\n\nirb\n(\nmain\n):\n001\n:\n0\n \narray\n \n=\n \n[]\n\n\n=\n \n[]\n\n\nirb\n(\nmain\n):\n002\n:\n0\n \narray\n.\nclass\n\n\n=\n \nArray\n\n\n\n\n\n\nWe can also create the array by calling \nnew\n on the \nArray\n class as follows :\n\n\nirb\n(\nmain\n):\n003\n:\n0\n \narray\n \n=\n \nArray\n.\nnew\n\n\n=\n \n[]\n\n\nirb\n(\nmain\n):\n004\n:\n0\n \narray\n.\nclass\n\n\n=\n \nArray\n\n\n\n\n\n\nCreate an array and specify an initial capacity :\n\n\nirb\n(\nmain\n):\n005\n:\n0\n \narray\n \n=\n \nArray\n.\nnew\n(\n2\n)\n\n\n=\n \n[\nnil\n,\n \nnil\n]\n\n\n\n\n\n\nWe can create the array and specify the capacity and initial values :\n\n\nirb\n(\nmain\n):\n006\n:\n0\n \narray\n \n=\n \nArray\n.\nnew\n(\n2\n,\n0\n)\n\n\n=\n \n[\n0\n,\n \n0\n]\n\n\n\n\n\n\nCreate an array with different types as follows :\n\n\nirb\n(\nmain\n):\n00\n8\n:\n0\n \narray\n \n=\n \n[\nhello\n,\n \nModule\n.\nnew\n,\n \n3\n.\n5\n]\n\n\n=\n \n[\nhello\n,\n \n#\nModule:0x007f844e0742f0\n, 3.5]\n\n\n\n\n\n\nCreate an array that initialized with two hashes :\n\n\nirb\n(\nmain\n):\n00\n9\n:\n0\n \narray\n \n=\n \nArray\n.\nnew\n(\n2\n,\n \nHash\n.\nnew\n)\n\n\n=\n \n[\n{},\n \n{}\n]\n\n\n\n\n\n\nWe can also use the \n{}\n to specify the object to initialize the array with as follows :\n\n\nrb\n(\nmain\n):\n011\n:\n0\n \narray\n \n=\n \nArray\n.\nnew\n(\n2\n){\nArray\n.\nnew\n(\n2\n,\n0\n)}\n\n\n=\n \n[[\n0\n,\n \n0\n]\n,\n \n[\n0\n,\n \n0\n]]\n\n\n\n\n\n\n%w{1 2 3}\n \n# array of strings\n\n\n%\ni\n{\none\n \ntwo\n \nthree\n}\n \n# arrays of symbols\n\n\n\n\n\n\nAccessing Array Elements\n\n\nWe use the \n[]\n to access the array elements. Retrieve the item at position 0 in the array as follows :\n\n\nirb\n(\nmain\n):\n014\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n015\n:\n0\n \narray\n[\n0\n]\n\n\n=\n \n1\n\n\n\n\n\n\nGet the last item in the array :\n\n\nirb\n(\nmain\n):\n017\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n01\n8\n:\n0\n \narray\n[-\n1\n]\n\n\n=\n \n5\n\n\n\n\n\n\nRetrieve multiple items using a range :\n\n\nirb\n(\nmain\n):\n01\n9\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n020\n:\n0\n \narray\n[\n0\n..\n2\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n\n\n\n\nUsing alternative syntax as follows :\n\n\nirb\n(\nmain\n):\n024\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n025\n:\n0\n \narray\n[\n0\n,\n3\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n\n\n\n\nInstead of using the \n[]\n we can use methods to access array elements as follows :\n\n\nirb\n(\nmain\n):\n02\n9\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n030\n:\n0\n \narray\n.\nat\n(\n0\n)\n\n\n=\n \n1\n\n\n\n\n\n\nReturns \nnil\n if the item is not found as follows :\n\n\nirb\n(\nmain\n):\n031\n:\n0\n \narray\n.\nat\n(\n5\n)\n\n\n=\n \nnil\n\n\n\n\n\n\nThe \nat\n method does not throw an error if the item is not found. Using \nfetch\n throws an error if the element is not found as follows :\n\n\nirb\n(\nmain\n):\n032\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n033\n:\n0\n \narray\n.\nfetch\n(\n0\n)\n\n\n=\n \n1\n\n\n\n\n\n\nThrows an error if the item is not found :\n\n\nirb\n(\nmain\n):\n034\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n035\n:\n0\n \narray\n.\nfetch\n(\n5\n)\n\n\nIndexError\n:\n \nindex\n \n5\n \noutside\n \nof\n \narray\n \nbounds\n:\n \n-\n5\n...\n5\n\n\n\n\n\n\nRemove Elements From The Array\n\n\nUsing the \npop\n method we can remove the element from the array as the end :\n\n\nirb\n(\nmain\n):\n03\n8\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n03\n9\n:\n0\n \narray\n.\npop\n\n\n=\n \n5\n\n\nirb\n(\nmain\n):\n040\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nThe \nshift\n removes an element at the beginning of the array :\n\n\nirb\n(\nmain\n):\n042\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n043\n:\n0\n \narray\n.\nshift\n\n\n=\n \n1\n\n\nirb\n(\nmain\n):\n044\n:\n0\n \narray\n\n\n=\n \n[\n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nDelete a specific value\n\n\nUsing the \ndelete\n method we can delete a specific value from the array as follows :\n\n\nirb\n(\nmain\n):\n060\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n061\n:\n0\n \narray\n.\ndelete\n(\n3\n)\n\n\n=\n \n3\n\n\nirb\n(\nmain\n):\n062\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nDelete a value at a position\n\n\nWe can use the \ndelete_at\n method to remove the value at a specific position as follows :\n\n\nirb\n(\nmain\n):\n064\n:\n0\n \narray\n \n=\n \n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n065\n:\n0\n \narray\n.\ndelete_at\n(\n1\n)\n\n\n=\n \n2\n\n\nirb\n(\nmain\n):\n066\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n3\n,\n \n4\n,\n \n5\n]\n\n\n\n\n\n\nDelete nil array elements\n\n\nWe can use the \ncompact\n method to remove nil array elements as follows :\n\n\nirb\n(\nmain\n):\n070\n:\n0\n \narray\n \n=\n \n[\n1\n,\nnil\n,\n2\n,\nnil\n,\n5\n]\n\n\n=\n \n[\n1\n,\n \nnil\n,\n \n2\n,\n \nnil\n,\n \n5\n]\n\n\nirb\n(\nmain\n):\n071\n:\n0\n \narray\n.\ncompact\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n5\n]\n\n\n\n\n\n\nArray Methods\n\n\nArrays contains a lot fo methods, here are some interesting ones :\n\n\n\n\nlength\n\n\nsize\n\n\ncount\n\n\nfirst\n\n\nlast\n\n\nsample\n\n\nempty?\n\n\nsort\n\n\nshuffle\n\n\n\n\nAdding elements at the end of the array\n\n\nWe can use the \npush\n method or the \n to add items to the end of the array as follows :\n\n\nirb\n(\nmain\n):\n072\n:\n0\n \n[\n1\n,\n2\n,\n3\n].\npush\n(\n4\n)\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nUsing the shift operator :\n\n\nirb\n(\nmain\n):\n073\n:\n0\n \n[\n1\n,\n2\n,\n3\n]\n \n \n4\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nAdd elements at the beginning\n\n\nWe can add elements to the beginning of the array using \nunshift\n and \ninsert\n method as follows :\n\n\nirb\n(\nmain\n):\n074\n:\n0\n \n[\n1\n,\n2\n,\n3\n,\n4\n].\nunshift\n(\n0\n)\n\n\n=\n \n[\n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nUse insert to place the item at a specific position as follows :\n\n\nirb\n(\nmain\n):\n075\n:\n0\n \n[\n1\n,\n2\n,\n3\n,\n4\n].\ninsert\n(\n0\n,\n0\n)\n\n\n=\n \n[\n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nLooping Through An Array\n\n\nWe can loop through the array using iterators and blocks. The \neach\n iterator method returns each item within the array :\n\n\nirb\n(\nmain\n):\n076\n:\n0\n \n[\n1\n,\n2\n,\n3\n,\n4\n].\neach\n \n{\n|\nitem\n|\n \np\n \nitem\n \n}\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nLoop in reverse\n\n\nWe can use the \nreverse_each\n to loop in reverse as follows :\n\n\nirb\n(\nmain\n):\n077\n:\n0\n \n[\n1\n,\n2\n,\n3\n,\n4\n].\nreverse_each\n \n{\n|\nitem\n|\n \np\n \nitem\n \n}\n\n\n4\n\n\n3\n\n\n2\n\n\n1\n\n\n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n]\n\n\n\n\n\n\nProduce a new array based on transformation\n\n\nWe can use the \ncollect\n to produce a transformation of some other array along with a block that takes one element and transforms it :\n\n\n[\n1\n,\n2\n,\n3\n,\n4\n].\nmap\n \n{\n|\nx\n|\n \nx\n \n**\n \n2\n}\n\n\n\n\n\n\nWe could also have used the \nmap\n method. On arrays they produce the same output.\n\n\nRun a block for each item in the array\n\n\nUsing the \nmap\n method, we can run a block of code for each item within the array without modifying the original array as follows :\n\n\nirb\n(\nmain\n):\n07\n8\n:\n0\n \n[\n1\n,\n2\n,\n3\n].\nmap\n \n{\n|\nitem\n|\n \nitem\n \n*\n \nitem\n \n}\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\n\n\n\n\nUsing the \nmap!\n modifies the original array as follows :\n\n\nirb\n(\nmain\n):\n082\n:\n0\n \narray\n.\nmap!\n \n{\n \n|\nitem\n|\n \nitem\n \n*\n \nitem\n \n}\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\nirb\n(\nmain\n):\n083\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\n\n\n\n\nLooping with an index\n\n\nWe can loop through the items and also get access to the index using the \neach_with_index\n as follows :\n\n\nirb\n(\nmain\n):\n086\n:\n0\n \narray\n.\neach_with_index\n \n{\n \n|\nitem\n,\n \nindex\n|\n \np\n \n#{\nindex\n}\n \n#{\nitem\n}\n \n}\n\n\n0 1\n\n\n1 4\n\n\n2 9\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\n\n\n\n\nSelecting items that match\n\n\nWe can use a block to select items that match a condition within a block as follows :\n\n\nirb\n(\nmain\n):\n090\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\nirb\n(\nmain\n):\n091\n:\n0\n \narray\n.\nselect\n \n{\n|\nitem\n|\n \nitem\n.\neven?\n \n}\n\n\n=\n \n[\n4\n]\n\n\n\n\n\n\nWe can use the \nselect!\n to modify the original array.\n\n\nRejecting items not matching\n\n\nWe can return items that does not match by using the \nreject\n method as follows :\n\n\nirb\n(\nmain\n):\n092\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\nirb\n(\nmain\n):\n093\n:\n0\n \narray\n.\nreject\n \n{\n \n|\nitem\n|\n \nitem\n.\neven?\n \n}\n\n\n=\n \n[\n1\n,\n \n9\n]\n\n\n\n\n\n\nRemove item with a condition\n\n\nWe can use the \ndelete_if\n to remove items that match a condition as follows :\n\n\nirb\n(\nmain\n):\n094\n:\n0\n \narray\n\n\n=\n \n[\n1\n,\n \n4\n,\n \n9\n]\n\n\nirb\n(\nmain\n):\n095\n:\n0\n \narray\n.\ndelete_if\n \n{\n|\nitem\n|\n \nitem\n.\neven?\n}\n\n\n=\n \n[\n1\n,\n \n9\n]\n\n\n\n\n\n\nThe \ndelete_if\n method is destructive.\n\n\nSorting arrays\n\n\nYou can sort homogeneous arrays of common data types, like strings or numbers, \"naturally\" by just calling Array#sort:\n\n\n[\n5\n.\n01\n,\n \n-\n5\n,\n \n0\n,\n \n5\n].\nsort\n                           \n# =\n [-5, 0, 5, 5.01]\n\n\n[\nUtahraptor\n,\n \nAnkylosaur\n,\n \nMaiasaur\n].\nsort\n   \n# =\n [\nAnkylosaur\n, \nMaiasaur\n, \nUtahraptor\n]\n\n\n\n\n\n\nTo sort objects based on one of their data members, or by the results of a method call, use Array#sort_by. This code sorts an array of arrays by size, regardless of their contents:\n\n\narrays\n \n=\n \n[[\n1\n,\n2\n,\n3\n]\n,\n \n[\n100\n]\n,\n \n[\n10\n,\n20\n]]\n\n\narrays\n.\nsort_by\n \n{\n \n|\nx\n|\n \nx\n.\nsize\n \n}\n       \n# =\n [[100], [10, 20], [1, 2, 3]]\n\n\n\n\n\n\nWe can use a code block to define a sort routine :\n\n\n[\n1\n,\n \n100\n,\n \n42\n,\n \n23\n,\n \n26\n,\n \n10000\n].\nsort\n \ndo\n \n|\nx\n,\n \ny\n|\n\n    \nx\n==\n42\n \n?\n \n1\n \n:\n \nx\n=\ny\n\n\nend\n\n\n# =\n [1, 23, 26, 100, 10000, 42]\n\n\n\n\n\n\nChange the sort order an objects :\n\n\nclass\n \nAnimal\n\n    \nattr_reader\n \n:name\n,\n \n:eyes\n,\n \n:appendages\n\n    \ndef\n \ninitialize\n(\nname\n,\n \neyes\n,\n \nappendages\n)\n\n        \n@name\n,\n \n@eyes\n,\n \n@appendages\n \n=\n \nname\n,\n \neyes\n,\n \nappendages\n\n    \nend\n\n    \ndef\n \ninspect\n\n        \n@name\n\n    \nend\n\n\nend\n\n\n\nanimals\n \n=\n \n[\nAnimal\n.\nnew\n(\noctopus\n,\n \n2\n,\n \n8\n),\n\n            \nAnimal\n.\nnew\n(\nspider\n,\n \n6\n,\n \n8\n),\n\n            \nAnimal\n.\nnew\n(\nbee\n,\n \n5\n,\n \n6\n),\n\n            \nAnimal\n.\nnew\n(\nelephant\n,\n \n2\n,\n \n4\n),\n\n            \nAnimal\n.\nnew\n(\ncrab\n,\n \n2\n,\n \n10\n)\n]\n\n\nanimals\n.\nsort_by\n \n{\n \n|\nx\n|\n \nx\n.\neyes\n \n}\n\n\n# =\n [octopus, elephant, crab, bee, spider]\n\n\nanimals\n.\nsort_by\n \n{\n \n|\nx\n|\n \nx\n.\nappendages\n \n}\n\n\n# =\n [elephant, bee, octopus, spider, crab]\n\n\n\n\n\n\nIf you pass a block into sort, Ruby calls the block to make comparisons instead of using the comparison operator.\n\n\nShuffling an array\n\n\nIn the older Ruby they was no method to shuffle. In the Ruby 2, the method \nshuffle\n was introduced. Here is a demo of shuffling a deck of cards :\n\n\nclass\n \nCard\n\n    \ndef\n \ninitialize\n(\nsuit\n,\n \nrank\n)\n\n        \n@suit\n \n=\n \nsuit\n\n        \n@rank\n \n=\n \nrank\n\n    \nend\n\n    \ndef\n \nto_s\n\n        \n#{\n@suit\n}\n of \n#{\n@rank\n}\n\n    \nend\n\n\nend\n\n\n\nclass\n \nDeck\n \n \nArray\n\n    \nattr_reader\n \n:cards\n\n    \n@@suits\n \n=\n \n%w{Spades Hearts Clubs Diamonds}\n\n    \n@@ranks\n \n=\n \n%w{Ace 2 3 4 5 6 7 8 9 10 Jack Queen King}\n\n    \ndef\n \ninitialize\n\n        \n@@suits\n.\neach\n \n{\n \n|\nsuit\n|\n \n@@ranks\n.\neach\n \n{\n \n|\nrank\n|\n \nself\n \n \nCard\n.\nnew\n(\nrank\n,\n \nsuit\n)\n \n}\n \n}\n\n    \nend\n\n\nend\n\n\n\ndeck\n \n=\n \nDeck\n.\nnew\n\n\ndeck\n.\ncollect\n \n{\n \n|\ncard\n|\n \ncard\n.\nto_s\n \n}\n\n\n# =\n [\nAce of Spades\n, \n2 of Spades\n, \n3 of Spades\n, \n4 of Spades\n, ...] deck.shuffle!\n\n\ndeck\n.\ncollect\n \n{\n \n|\ncard\n|\n \ncard\n.\nto_s\n \n}\n\n\n# =\n [\n6 of Clubs\n, \n8 of Diamonds\n, \n2 of Hearts\n, \n5 of Clubs\n, ...]\n\n\n\n\n\n\nExercises\n\n\n\n\n\n\nLoop through the array and only choose the letters :\n\n\nruby\narray = ['1', 'a', '2', 'b', '3', 'c']\n\nThe expected output is \na b c\n.\n2. Make the each of the following characters uppercase, show at least two ways :\n\n\nruby\narray = ['a', 'b', 'c']\n\n3. Remove duplicates from the following array :\n\n\nruby\nsurvey_results = [1, 2, 7, 1, 1, 5, 2, 5, 1]\n\nAlso try use the set collection. You can find the Set class by adding the Set standard libary as follows :\n\n\nruby\nrequire 'set'\n\n\nShow also the frequency of the duplicate characters.\n4. Sum the items of the array :\n\n\nruby\ncollection = [1, 2, 3, 4, 5]\n\n5. Sort the array by the frequency of the words in the sentence.\n6. Generate a deck of the 52 cards. Use the following start code :\n\n\nruby\nsuits = %w{Spades Hearts Clubs Diamonds}\nranks = %w{Ace 2 3 4 5 6 7 8 9 10 Jack Queen King}\n\n7. Get the smallest and biggest top and bottom 5 of the following array :\n\n\nruby\n[1,60,21,100,-5,20,60,22,85,91,4,66]\n\n8. Find the smallest word in a sentence.\n9. Decompose an array with duplicate values into a hash. Use this as sample :\n\n\nruby\nraw_data = [ [1, 'a'], [1, 'b'], [1, 'c'],\n                [2, 'a'], [2, ['b', 'c']],\n                [3, 'c'] ]\n\nThe expected output is as follows :\n\n\n```ruby\n\n\n=\n {1=\n[\"a\", \"b\", \"c\"], 2=\n[\"a\", [\"b\", \"c\"]], 3=\n[\"c\"]}\n\n\n```\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nWe can use the \nstep\n by skipping 2 steps:\n\n\nruby\n(0..array.count).step(2) {|i| p array[i + 1] }\n\n2. The solution is to perform an operation on the array using \nmap\n or \ncollect\n as follows :\n\n\nruby\narray.collect {|c| c.upcase }\narray.map {|c| c.upcase }\n\nYou could do something interesting we havent covered yet using lambdas as follows :\n\n\nruby\nupcase = -\n(c){ c.downcase } # create a lambda expression\narray.map(\nupcase) # pass a lambda into the map.\n\n3. We can use the \nuniq\n method to remove duplicates from an array.\n\n\nruby\nsurvey_results.uniq\n\n\nor using a Set as follows :\n\n\n```ruby\nrequire 'set'\n\n\ns = Set.new\nsurvey_results.each {|c| s.add}\n```\n4. This is one of the many solutions :\n\n\nruby\ncollection.inject(0) {|sum, i| sum + i} # =\n 15\n\n5. We first need to construct a histogram. Then we can use the \nsort_by\n method as follows :\n\n\nruby\nw = \"This is a is a is a word is this sentence\"\nhist = w.split.inject(Hash.new(0)) {|hash,v| hash[v] += 1; hash }\nw.split.sort_by {|x| [hist[x], x]}\n\n\nAnd we can sort distinctly as follows :\n\n\nruby\nhist.keys.sort_by { |x| [hist[x], x] }\n\n6. We can just embed an \neach\n block inside another one.\n7. The idea is to sort the list first and then extract the values :\n\n\n```ruby\nl = [1,60,21,100,-5,20,60,22,85,91,4,66] sorted = l.sort\n\n\nThe top 5\n\n\nsorted[-5...sorted.size] # =\n [60, 66, 85, 91, 100]\n\n\nThe bottom 5\n\n\nsorted[0...5]\n\n\n=\n [-5, 1, 4, 20, 21]\n\n\n``\n8. We can use the\nmin` on the Array and pass in a block for comparison as follows :\n\n\n\n\n\n\nw\n \n=\n \nThis is a is a is a word is this sentence\n\n\nw\n.\nsplit\n.\nmin\n \n{\n|\nx\n,\ny\n|\n \nx\n.\nsize\n \n=\n \ny\n.\nsize\n \n}\n\n\n\n\n\n\n\n\nWe can build a hash using the first values from the array as follows :\n\n\n\n\nhash\n \n=\n \nHash\n.\nnew\n \n{\n \n|\nhash\n,\n \nkey\n|\n \nhash\n[\nkey\n]\n \n=\n \n[]\n \n}\n\n    \nraw_data\n \n=\n \n[\n \n[\n1\n,\n \na\n]\n,\n \n[\n1\n,\n \nb\n]\n,\n \n[\n1\n,\n \nc\n]\n,\n\n                 \n[\n2\n,\n \na\n]\n,\n \n[\n2\n,\n \n[\nb\n,\n \nc\n]]\n,\n\n                 \n[\n3\n,\n \nc\n]\n \n]\n\n    \nraw_data\n.\neach\n \n{\n \n|\nx\n,\ny\n|\n \nhash\n[\nx\n]\n \n \ny\n \n}\n\n\nhash", 
            "title": "Arrays"
        }, 
        {
            "location": "/arrays/#arrays", 
            "text": "Arrays are a collection of items. In Ruby, arrays can take a collection of any type. An array is an ordered list of elements. Each element is a reference to some object.", 
            "title": "Arrays"
        }, 
        {
            "location": "/arrays/#creating-arrays", 
            "text": "To create an a array you use the  []  symbols. We can create an empty array as follows :  irb ( main ): 001 : 0   array   =   []  =   []  irb ( main ): 002 : 0   array . class  =   Array   We can also create the array by calling  new  on the  Array  class as follows :  irb ( main ): 003 : 0   array   =   Array . new  =   []  irb ( main ): 004 : 0   array . class  =   Array   Create an array and specify an initial capacity :  irb ( main ): 005 : 0   array   =   Array . new ( 2 )  =   [ nil ,   nil ]   We can create the array and specify the capacity and initial values :  irb ( main ): 006 : 0   array   =   Array . new ( 2 , 0 )  =   [ 0 ,   0 ]   Create an array with different types as follows :  irb ( main ): 00 8 : 0   array   =   [ hello ,   Module . new ,   3 . 5 ]  =   [ hello ,   # Module:0x007f844e0742f0 , 3.5]   Create an array that initialized with two hashes :  irb ( main ): 00 9 : 0   array   =   Array . new ( 2 ,   Hash . new )  =   [ {},   {} ]   We can also use the  {}  to specify the object to initialize the array with as follows :  rb ( main ): 011 : 0   array   =   Array . new ( 2 ){ Array . new ( 2 , 0 )}  =   [[ 0 ,   0 ] ,   [ 0 ,   0 ]]   %w{1 2 3}   # array of strings  % i { one   two   three }   # arrays of symbols", 
            "title": "Creating Arrays"
        }, 
        {
            "location": "/arrays/#accessing-array-elements", 
            "text": "We use the  []  to access the array elements. Retrieve the item at position 0 in the array as follows :  irb ( main ): 014 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 015 : 0   array [ 0 ]  =   1   Get the last item in the array :  irb ( main ): 017 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 01 8 : 0   array [- 1 ]  =   5   Retrieve multiple items using a range :  irb ( main ): 01 9 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 020 : 0   array [ 0 .. 2 ]  =   [ 1 ,   2 ,   3 ]   Using alternative syntax as follows :  irb ( main ): 024 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 025 : 0   array [ 0 , 3 ]  =   [ 1 ,   2 ,   3 ]   Instead of using the  []  we can use methods to access array elements as follows :  irb ( main ): 02 9 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 030 : 0   array . at ( 0 )  =   1   Returns  nil  if the item is not found as follows :  irb ( main ): 031 : 0   array . at ( 5 )  =   nil   The  at  method does not throw an error if the item is not found. Using  fetch  throws an error if the element is not found as follows :  irb ( main ): 032 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 033 : 0   array . fetch ( 0 )  =   1   Throws an error if the item is not found :  irb ( main ): 034 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 035 : 0   array . fetch ( 5 )  IndexError :   index   5   outside   of   array   bounds :   - 5 ... 5", 
            "title": "Accessing Array Elements"
        }, 
        {
            "location": "/arrays/#remove-elements-from-the-array", 
            "text": "Using the  pop  method we can remove the element from the array as the end :  irb ( main ): 03 8 : 0   array  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 03 9 : 0   array . pop  =   5  irb ( main ): 040 : 0   array  =   [ 1 ,   2 ,   3 ,   4 ]   The  shift  removes an element at the beginning of the array :  irb ( main ): 042 : 0   array  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 043 : 0   array . shift  =   1  irb ( main ): 044 : 0   array  =   [ 2 ,   3 ,   4 ,   5 ]", 
            "title": "Remove Elements From The Array"
        }, 
        {
            "location": "/arrays/#delete-a-specific-value", 
            "text": "Using the  delete  method we can delete a specific value from the array as follows :  irb ( main ): 060 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 061 : 0   array . delete ( 3 )  =   3  irb ( main ): 062 : 0   array  =   [ 1 ,   2 ,   4 ,   5 ]", 
            "title": "Delete a specific value"
        }, 
        {
            "location": "/arrays/#delete-a-value-at-a-position", 
            "text": "We can use the  delete_at  method to remove the value at a specific position as follows :  irb ( main ): 064 : 0   array   =   [ 1 , 2 , 3 , 4 , 5 ]  =   [ 1 ,   2 ,   3 ,   4 ,   5 ]  irb ( main ): 065 : 0   array . delete_at ( 1 )  =   2  irb ( main ): 066 : 0   array  =   [ 1 ,   3 ,   4 ,   5 ]", 
            "title": "Delete a value at a position"
        }, 
        {
            "location": "/arrays/#delete-nil-array-elements", 
            "text": "We can use the  compact  method to remove nil array elements as follows :  irb ( main ): 070 : 0   array   =   [ 1 , nil , 2 , nil , 5 ]  =   [ 1 ,   nil ,   2 ,   nil ,   5 ]  irb ( main ): 071 : 0   array . compact  =   [ 1 ,   2 ,   5 ]", 
            "title": "Delete nil array elements"
        }, 
        {
            "location": "/arrays/#array-methods", 
            "text": "Arrays contains a lot fo methods, here are some interesting ones :   length  size  count  first  last  sample  empty?  sort  shuffle", 
            "title": "Array Methods"
        }, 
        {
            "location": "/arrays/#adding-elements-at-the-end-of-the-array", 
            "text": "We can use the  push  method or the   to add items to the end of the array as follows :  irb ( main ): 072 : 0   [ 1 , 2 , 3 ]. push ( 4 )  =   [ 1 ,   2 ,   3 ,   4 ]   Using the shift operator :  irb ( main ): 073 : 0   [ 1 , 2 , 3 ]     4  =   [ 1 ,   2 ,   3 ,   4 ]", 
            "title": "Adding elements at the end of the array"
        }, 
        {
            "location": "/arrays/#add-elements-at-the-beginning", 
            "text": "We can add elements to the beginning of the array using  unshift  and  insert  method as follows :  irb ( main ): 074 : 0   [ 1 , 2 , 3 , 4 ]. unshift ( 0 )  =   [ 0 ,   1 ,   2 ,   3 ,   4 ]   Use insert to place the item at a specific position as follows :  irb ( main ): 075 : 0   [ 1 , 2 , 3 , 4 ]. insert ( 0 , 0 )  =   [ 0 ,   1 ,   2 ,   3 ,   4 ]", 
            "title": "Add elements at the beginning"
        }, 
        {
            "location": "/arrays/#looping-through-an-array", 
            "text": "We can loop through the array using iterators and blocks. The  each  iterator method returns each item within the array :  irb ( main ): 076 : 0   [ 1 , 2 , 3 , 4 ]. each   { | item |   p   item   }  1  2  3  4  =   [ 1 ,   2 ,   3 ,   4 ]", 
            "title": "Looping Through An Array"
        }, 
        {
            "location": "/arrays/#loop-in-reverse", 
            "text": "We can use the  reverse_each  to loop in reverse as follows :  irb ( main ): 077 : 0   [ 1 , 2 , 3 , 4 ]. reverse_each   { | item |   p   item   }  4  3  2  1  =   [ 1 ,   2 ,   3 ,   4 ]", 
            "title": "Loop in reverse"
        }, 
        {
            "location": "/arrays/#produce-a-new-array-based-on-transformation", 
            "text": "We can use the  collect  to produce a transformation of some other array along with a block that takes one element and transforms it :  [ 1 , 2 , 3 , 4 ]. map   { | x |   x   **   2 }   We could also have used the  map  method. On arrays they produce the same output.", 
            "title": "Produce a new array based on transformation"
        }, 
        {
            "location": "/arrays/#run-a-block-for-each-item-in-the-array", 
            "text": "Using the  map  method, we can run a block of code for each item within the array without modifying the original array as follows :  irb ( main ): 07 8 : 0   [ 1 , 2 , 3 ]. map   { | item |   item   *   item   }  =   [ 1 ,   4 ,   9 ]   Using the  map!  modifies the original array as follows :  irb ( main ): 082 : 0   array . map!   {   | item |   item   *   item   }  =   [ 1 ,   4 ,   9 ]  irb ( main ): 083 : 0   array  =   [ 1 ,   4 ,   9 ]", 
            "title": "Run a block for each item in the array"
        }, 
        {
            "location": "/arrays/#looping-with-an-index", 
            "text": "We can loop through the items and also get access to the index using the  each_with_index  as follows :  irb ( main ): 086 : 0   array . each_with_index   {   | item ,   index |   p   #{ index }   #{ item }   }  0 1  1 4  2 9  =   [ 1 ,   4 ,   9 ]", 
            "title": "Looping with an index"
        }, 
        {
            "location": "/arrays/#selecting-items-that-match", 
            "text": "We can use a block to select items that match a condition within a block as follows :  irb ( main ): 090 : 0   array  =   [ 1 ,   4 ,   9 ]  irb ( main ): 091 : 0   array . select   { | item |   item . even?   }  =   [ 4 ]   We can use the  select!  to modify the original array.", 
            "title": "Selecting items that match"
        }, 
        {
            "location": "/arrays/#rejecting-items-not-matching", 
            "text": "We can return items that does not match by using the  reject  method as follows :  irb ( main ): 092 : 0   array  =   [ 1 ,   4 ,   9 ]  irb ( main ): 093 : 0   array . reject   {   | item |   item . even?   }  =   [ 1 ,   9 ]", 
            "title": "Rejecting items not matching"
        }, 
        {
            "location": "/arrays/#remove-item-with-a-condition", 
            "text": "We can use the  delete_if  to remove items that match a condition as follows :  irb ( main ): 094 : 0   array  =   [ 1 ,   4 ,   9 ]  irb ( main ): 095 : 0   array . delete_if   { | item |   item . even? }  =   [ 1 ,   9 ]   The  delete_if  method is destructive.", 
            "title": "Remove item with a condition"
        }, 
        {
            "location": "/arrays/#sorting-arrays", 
            "text": "You can sort homogeneous arrays of common data types, like strings or numbers, \"naturally\" by just calling Array#sort:  [ 5 . 01 ,   - 5 ,   0 ,   5 ]. sort                             # =  [-5, 0, 5, 5.01]  [ Utahraptor ,   Ankylosaur ,   Maiasaur ]. sort     # =  [ Ankylosaur ,  Maiasaur ,  Utahraptor ]   To sort objects based on one of their data members, or by the results of a method call, use Array#sort_by. This code sorts an array of arrays by size, regardless of their contents:  arrays   =   [[ 1 , 2 , 3 ] ,   [ 100 ] ,   [ 10 , 20 ]]  arrays . sort_by   {   | x |   x . size   }         # =  [[100], [10, 20], [1, 2, 3]]   We can use a code block to define a sort routine :  [ 1 ,   100 ,   42 ,   23 ,   26 ,   10000 ]. sort   do   | x ,   y | \n     x == 42   ?   1   :   x = y  end  # =  [1, 23, 26, 100, 10000, 42]   Change the sort order an objects :  class   Animal \n     attr_reader   :name ,   :eyes ,   :appendages \n     def   initialize ( name ,   eyes ,   appendages ) \n         @name ,   @eyes ,   @appendages   =   name ,   eyes ,   appendages \n     end \n     def   inspect \n         @name \n     end  end  animals   =   [ Animal . new ( octopus ,   2 ,   8 ), \n             Animal . new ( spider ,   6 ,   8 ), \n             Animal . new ( bee ,   5 ,   6 ), \n             Animal . new ( elephant ,   2 ,   4 ), \n             Animal . new ( crab ,   2 ,   10 ) ]  animals . sort_by   {   | x |   x . eyes   }  # =  [octopus, elephant, crab, bee, spider]  animals . sort_by   {   | x |   x . appendages   }  # =  [elephant, bee, octopus, spider, crab]   If you pass a block into sort, Ruby calls the block to make comparisons instead of using the comparison operator.", 
            "title": "Sorting arrays"
        }, 
        {
            "location": "/arrays/#shuffling-an-array", 
            "text": "In the older Ruby they was no method to shuffle. In the Ruby 2, the method  shuffle  was introduced. Here is a demo of shuffling a deck of cards :  class   Card \n     def   initialize ( suit ,   rank ) \n         @suit   =   suit \n         @rank   =   rank \n     end \n     def   to_s \n         #{ @suit }  of  #{ @rank } \n     end  end  class   Deck     Array \n     attr_reader   :cards \n     @@suits   =   %w{Spades Hearts Clubs Diamonds} \n     @@ranks   =   %w{Ace 2 3 4 5 6 7 8 9 10 Jack Queen King} \n     def   initialize \n         @@suits . each   {   | suit |   @@ranks . each   {   | rank |   self     Card . new ( rank ,   suit )   }   } \n     end  end  deck   =   Deck . new  deck . collect   {   | card |   card . to_s   }  # =  [ Ace of Spades ,  2 of Spades ,  3 of Spades ,  4 of Spades , ...] deck.shuffle!  deck . collect   {   | card |   card . to_s   }  # =  [ 6 of Clubs ,  8 of Diamonds ,  2 of Hearts ,  5 of Clubs , ...]", 
            "title": "Shuffling an array"
        }, 
        {
            "location": "/arrays/#exercises", 
            "text": "Loop through the array and only choose the letters :  ruby\narray = ['1', 'a', '2', 'b', '3', 'c'] \nThe expected output is  a b c .\n2. Make the each of the following characters uppercase, show at least two ways :  ruby\narray = ['a', 'b', 'c'] \n3. Remove duplicates from the following array :  ruby\nsurvey_results = [1, 2, 7, 1, 1, 5, 2, 5, 1] \nAlso try use the set collection. You can find the Set class by adding the Set standard libary as follows :  ruby\nrequire 'set'  Show also the frequency of the duplicate characters.\n4. Sum the items of the array :  ruby\ncollection = [1, 2, 3, 4, 5] \n5. Sort the array by the frequency of the words in the sentence.\n6. Generate a deck of the 52 cards. Use the following start code :  ruby\nsuits = %w{Spades Hearts Clubs Diamonds}\nranks = %w{Ace 2 3 4 5 6 7 8 9 10 Jack Queen King} \n7. Get the smallest and biggest top and bottom 5 of the following array :  ruby\n[1,60,21,100,-5,20,60,22,85,91,4,66] \n8. Find the smallest word in a sentence.\n9. Decompose an array with duplicate values into a hash. Use this as sample :  ruby\nraw_data = [ [1, 'a'], [1, 'b'], [1, 'c'],\n                [2, 'a'], [2, ['b', 'c']],\n                [3, 'c'] ] \nThe expected output is as follows :  ```ruby", 
            "title": "Exercises"
        }, 
        {
            "location": "/arrays/#1a-b-c-2a-b-c-3c", 
            "text": "```", 
            "title": "=&gt; {1=&gt;[\"a\", \"b\", \"c\"], 2=&gt;[\"a\", [\"b\", \"c\"]], 3=&gt;[\"c\"]}"
        }, 
        {
            "location": "/arrays/#solution", 
            "text": "We can use the  step  by skipping 2 steps:  ruby\n(0..array.count).step(2) {|i| p array[i + 1] } \n2. The solution is to perform an operation on the array using  map  or  collect  as follows :  ruby\narray.collect {|c| c.upcase }\narray.map {|c| c.upcase } \nYou could do something interesting we havent covered yet using lambdas as follows :  ruby\nupcase = - (c){ c.downcase } # create a lambda expression\narray.map( upcase) # pass a lambda into the map. \n3. We can use the  uniq  method to remove duplicates from an array.  ruby\nsurvey_results.uniq  or using a Set as follows :  ```ruby\nrequire 'set'  s = Set.new\nsurvey_results.each {|c| s.add}\n```\n4. This is one of the many solutions :  ruby\ncollection.inject(0) {|sum, i| sum + i} # =  15 \n5. We first need to construct a histogram. Then we can use the  sort_by  method as follows :  ruby\nw = \"This is a is a is a word is this sentence\"\nhist = w.split.inject(Hash.new(0)) {|hash,v| hash[v] += 1; hash }\nw.split.sort_by {|x| [hist[x], x]}  And we can sort distinctly as follows :  ruby\nhist.keys.sort_by { |x| [hist[x], x] } \n6. We can just embed an  each  block inside another one.\n7. The idea is to sort the list first and then extract the values :  ```ruby\nl = [1,60,21,100,-5,20,60,22,85,91,4,66] sorted = l.sort", 
            "title": "Solution"
        }, 
        {
            "location": "/arrays/#the-top-5", 
            "text": "sorted[-5...sorted.size] # =  [60, 66, 85, 91, 100]", 
            "title": "The top 5"
        }, 
        {
            "location": "/arrays/#the-bottom-5", 
            "text": "sorted[0...5]", 
            "title": "The bottom 5"
        }, 
        {
            "location": "/arrays/#-5-1-4-20-21", 
            "text": "``\n8. We can use the min` on the Array and pass in a block for comparison as follows :    w   =   This is a is a is a word is this sentence  w . split . min   { | x , y |   x . size   =   y . size   }    We can build a hash using the first values from the array as follows :   hash   =   Hash . new   {   | hash ,   key |   hash [ key ]   =   []   } \n     raw_data   =   [   [ 1 ,   a ] ,   [ 1 ,   b ] ,   [ 1 ,   c ] , \n                  [ 2 ,   a ] ,   [ 2 ,   [ b ,   c ]] , \n                  [ 3 ,   c ]   ] \n     raw_data . each   {   | x , y |   hash [ x ]     y   }  hash", 
            "title": "=&gt; [-5, 1, 4, 20, 21]"
        }, 
        {
            "location": "/hashes/", 
            "text": "Hashes\n\n\nHashes are dictionary style collections that uses key and value pair. There are also known as associative arrays in other languages.\n\n\nCreating Hashes\n\n\nThey are two ways to create a hash in Ruby.\n\n\nCreate Hash using {}\n\n\nWe can create an empty hash using the \n{}\n character as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n133\n \n \nhash\n \n=\n \n{}\n\n \n=\n \n{}\n\n\n2\n.\n2\n.\n5\n \n:\n134\n \n \nhash\n.\nclass\n\n \n=\n \nHash\n\n\n\n\n\n\nCreate Hash using Hash.new\n\n\nWe can also create a hash by calling the \nnew\n method on the \nHash\n type as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n135\n \n \nhash\n \n=\n \nHash\n.\nnew\n\n \n=\n \n{}\n\n\n2\n.\n2\n.\n5\n \n:\n136\n \n \nhash\n.\nclass\n\n \n=\n \nHash\n\n\n\n\n\n\nCreating with string keys\n\n\nWe can use strings as keys for the hashes as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n137\n \n \np\n \n=\n \n{\nname\n \n=\n \nJoseph\n,\n \ncompany\n \n=\n \nPeruzal\n}\n\n \n=\n \n{\nname\n=\nJoseph\n,\n \ncompany\n=\nPeruzal\n}\n\n\n\n\n\n\nCreating a hash using symbols for keys\n\n\nInstead of using strings, we can use symbols for the keys of the hash as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n140\n \n \np\n \n=\n \n{\n \nname\n:\n \nJoseph\n,\n \ncompany\n:\n \nPeruzal\n \n}\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n}\n\n\n\n\n\n\nThe longer way of using symbols is as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n142\n \n \np\n \n=\n \n{\n \n:name\n \n=\n \nJoseph\n,\n \n:company\n \n=\n \nPeruzal\n \n}\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n}\n\n\n\n\n\n\nThe shorter way will not work with numeric keys.\n\n\nYou can randomly add more keys to the hash by using the \n[]\n symbols as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n142\n \n \np\n \n=\n \n{\n \n:name\n \n=\n \nJoseph\n,\n \n:company\n \n=\n \nPeruzal\n \n}\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n}\n\n\n2\n.\n2\n.\n5\n \n:\n143\n \n \np\n[\n:location\n]\n \n=\n \nCape Town\n\n \n=\n \nCape Town\n\n\n2\n.\n2\n.\n5\n \n:\n144\n \n \np\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n\n\n\n\n\n\nGetting a count of key\n\n\nWe can use the \ncount\n method to find the number of keys within a hash as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n144\n \n \np\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n \n\n2\n.\n2\n.\n5\n \n:\n145\n \n \np\n.\ncount\n\n\n\n\n\n\nCheck fo existence of keys\n\n\nWe can check for the existence of keys within a hash with the \nhas_key?\n methods as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n147\n \n \np\n.\nhas_key?\n \n:company\n\n \n=\n \ntrue\n\n\n\n\n\n\nAlternatively we can check if a value exists using  the \nhas_value?\n method as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n148\n \n \np\n.\nhas_value?\n \nJoseph\n\n \n=\n \ntrue\n\n\n\n\n\n\nSort keys\n\n\nBy default the hash keys are unordered since we can access them directly, we can use the \nsort\n method to put the keys in alphabetical order as follows :\n\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n\n\n2\n.\n2\n.\n5\n \n:\n150\n \n \np\n.\nsort\n\n \n=\n \n[[\n:company\n,\n \nPeruzal\n]\n,\n \n[\n:location\n,\n \nCape Town\n]\n,\n \n[\n:name\n,\n \nJoseph\n]]\n\n\n\n\n\n\nAccessing Hash elements\n\n\nHash elements are accessed in a similar way as with the arrays, the different is that in a hash we will use a key instead of an index as in arrays. We use the \n[]\n to access hash elements as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n151\n \n \np\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n \n\n2\n.\n2\n.\n5\n \n:\n152\n \n \np\n[\n:name\n]\n\n \n=\n \nJoseph\n\n\n\n\n\n\nSelecting key and values\n\n\nWe can use the \nselect\n method to return the key/value pairs of a hash as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n157\n \n \np\n.\nselect\n \n{\n|\nkey\n,\nvalue\n|\n \nvalue\n \n==\n \nJoseph\n}\n\n \n=\n \n{\n:name\n=\nJoseph\n}\n\n\n\n\n\n\nLooping Through Hash elements\n\n\nWe can loop through the key/value pair of hash elements using the \neach\n method as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n158\n \n \np\n.\neach\n \n{\n|\nkey\n,\nvalue\n|\n \np\n \n#{\nkey\n}\n \n#{\nvalue\n}\n}\n\n\nname Joseph\n\n\ncompany Peruzal\n\n\nlocation Cape Town\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n\n\n\n\n\n\nLoop through each value pair\n\n\nWe can instead loop through each value pair using the \neach_value\n method as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n159\n \n \np\n.\neach_value\n \n{\n|\nv\n|\n \np\n \nv\n}\n\n\nJoseph\n\n\nPeruzal\n\n\nCape Town\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n\n\n\n\n\n\nLoop through each key\n\n\nWe can also loop through the keys using the \neach_key\n as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n160\n \n \np\n.\neach_key\n \n{\n|\nk\n|\n \np\n \nk\n}\n\n\n:name\n\n\n:company\n\n\n:location\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n\n\n\n\n\n\nClearing hashes\n\n\nWe can use the \nclear\n method to clear the contents of the hash as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n161\n \n \np\n.\nclear\n\n \n=\n \n{}\n\n\n\n\n\n\nCheck if hash if empty\n\n\nWe can use the \nempty?\n method to check if the hash is empty of not as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n162\n \n \np\n.\nempty?\n\n \n=\n \ntrue\n\n\n\n\n\n\nRemove keys\n\n\nWe can remove keys at the beginning of the hash by using the \nshift\n method as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n165\n \n \np\n\n \n=\n \n{\n:name\n=\nJoseph\n,\n \n:company\n=\nPeruzal\n}\n\n\n2\n.\n2\n.\n5\n \n:\n166\n \n \np\n.\nshift\n\n \n=\n \n[\n:name\n,\n \nJoseph\n]\n\n\n2\n.\n2\n.\n5\n \n:\n167\n \n \np\n\n \n=\n \n{\n:company\n=\nPeruzal\n}\n\n\n\n\n\n\nMerge hashes\n\n\nWe can use the \nmerge\n method to join two hashes together as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n179\n \n \nperson\n \n=\n \n{\n \nfirst_name\n:\n \nJoseph\n,\n \nlast_name\n:\n \nKandi\n \n}\n\n \n=\n \n{\n:first_name\n=\nJoseph\n,\n \n:last_name\n=\nKandi\n}\n \n\n2\n.\n2\n.\n5\n \n:\n180\n \n \ncompany\n \n=\n \n{\n \nname\n:\n \nPeruzal\n,\n \nlocation\n:\n \nCape Town\n \n}\n\n \n=\n \n{\n:name\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n \n\n2\n.\n2\n.\n5\n \n:\n181\n \n \nperson\n.\nmerge\n(\ncompany\n)\n\n \n=\n \n{\n:first_name\n=\nJoseph\n,\n \n:last_name\n=\nKandi\n,\n \n:name\n=\nPeruzal\n,\n \n:location\n=\nCape Town\n}\n \n\n\n\n\n\nExercise\n\n\n\n\nChoose a random value using a weighted value from a list. The higher the value, the higher the chances of choosing the same value. Assign a weight to each value. E.g :\n\n\n\n\nmarbles\n \n=\n \n{\n \n:black\n \n=\n \n51\n,\n \n:white\n \n=\n \n17\n \n}\n\n\n3\n.\ntimes\n \n{\n \nputs\n \nchoose_weighted\n(\nmarbles\n)\n \n}\n\n\n# black\n\n\n# white\n\n\n# black\n\n\n\n\n\n\nSolution\n\n\n\n\nThe following is one way of implementing it :\n\n\n\n\ndef\n \nchoose_weighted\n(\nweighted\n)\n\n    \nsum\n \n=\n \nweighted\n.\ninject\n(\n0\n)\n \ndo\n \n|\nsum\n,\n \nitem_and_weight\n|\n\n        \nsum\n \n+=\n \nitem_and_weight\n[\n1\n]\n\n    \nend\n\n    \ntarget\n \n=\n \nrand\n(\nsum\n)\n\n    \nweighted\n.\neach\n \ndo\n \n|\nitem\n,\n \nweight\n|\n\n        \nreturn\n \nitem\n \nif\n \ntarget\n \n=\n \nweight\n\n        \ntarget\n \n-=\n \nweight\n\n    \nend\n\n\nend\n\n\n\nlottery_probabilities\n \n=\n \n{\n \nYou\nve wasted your money!\n \n=\n \n1000\n,\n\n                              \nYou\nve won back the cost of your ticket!\n \n=\n \n50\n,\n\n                              \nYou\nve won two shiny zorkmids!\n \n=\n \n20\n,\n\n                              \nYou\nve won five zorkmids!\n \n=\n \n10\n,\n\n                              \nYou\nve won ten zorkmids!\n \n=\n \n5\n,\n\n                              \nYou\nve won a hundred zorkmids!\n \n=\n \n1\n \n}\n\n\n# Let\ns buy some lottery tickets.\n\n\n5\n.\ntimes\n \n{\n \nputs\n \nchoose_weighted\n(\nlottery_probabilities\n)\n \n}", 
            "title": "Hashes"
        }, 
        {
            "location": "/hashes/#hashes", 
            "text": "Hashes are dictionary style collections that uses key and value pair. There are also known as associative arrays in other languages.", 
            "title": "Hashes"
        }, 
        {
            "location": "/hashes/#creating-hashes", 
            "text": "They are two ways to create a hash in Ruby.", 
            "title": "Creating Hashes"
        }, 
        {
            "location": "/hashes/#create-hash-using", 
            "text": "We can create an empty hash using the  {}  character as follows :  2 . 2 . 5   : 133     hash   =   {} \n  =   {}  2 . 2 . 5   : 134     hash . class \n  =   Hash", 
            "title": "Create Hash using {}"
        }, 
        {
            "location": "/hashes/#create-hash-using-hashnew", 
            "text": "We can also create a hash by calling the  new  method on the  Hash  type as follows :  2 . 2 . 5   : 135     hash   =   Hash . new \n  =   {}  2 . 2 . 5   : 136     hash . class \n  =   Hash", 
            "title": "Create Hash using Hash.new"
        }, 
        {
            "location": "/hashes/#creating-with-string-keys", 
            "text": "We can use strings as keys for the hashes as follows :  2 . 2 . 5   : 137     p   =   { name   =   Joseph ,   company   =   Peruzal } \n  =   { name = Joseph ,   company = Peruzal }", 
            "title": "Creating with string keys"
        }, 
        {
            "location": "/hashes/#creating-a-hash-using-symbols-for-keys", 
            "text": "Instead of using strings, we can use symbols for the keys of the hash as follows :  2 . 2 . 5   : 140     p   =   {   name :   Joseph ,   company :   Peruzal   } \n  =   { :name = Joseph ,   :company = Peruzal }   The longer way of using symbols is as follows :  2 . 2 . 5   : 142     p   =   {   :name   =   Joseph ,   :company   =   Peruzal   } \n  =   { :name = Joseph ,   :company = Peruzal }   The shorter way will not work with numeric keys.  You can randomly add more keys to the hash by using the  []  symbols as follows :  2 . 2 . 5   : 142     p   =   {   :name   =   Joseph ,   :company   =   Peruzal   } \n  =   { :name = Joseph ,   :company = Peruzal }  2 . 2 . 5   : 143     p [ :location ]   =   Cape Town \n  =   Cape Town  2 . 2 . 5   : 144     p \n  =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }", 
            "title": "Creating a hash using symbols for keys"
        }, 
        {
            "location": "/hashes/#getting-a-count-of-key", 
            "text": "We can use the  count  method to find the number of keys within a hash as follows :  2 . 2 . 5   : 144     p \n  =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }   2 . 2 . 5   : 145     p . count", 
            "title": "Getting a count of key"
        }, 
        {
            "location": "/hashes/#check-fo-existence-of-keys", 
            "text": "We can check for the existence of keys within a hash with the  has_key?  methods as follows :  2 . 2 . 5   : 147     p . has_key?   :company \n  =   true   Alternatively we can check if a value exists using  the  has_value?  method as follows :  2 . 2 . 5   : 148     p . has_value?   Joseph \n  =   true", 
            "title": "Check fo existence of keys"
        }, 
        {
            "location": "/hashes/#sort-keys", 
            "text": "By default the hash keys are unordered since we can access them directly, we can use the  sort  method to put the keys in alphabetical order as follows :    =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }  2 . 2 . 5   : 150     p . sort \n  =   [[ :company ,   Peruzal ] ,   [ :location ,   Cape Town ] ,   [ :name ,   Joseph ]]", 
            "title": "Sort keys"
        }, 
        {
            "location": "/hashes/#accessing-hash-elements", 
            "text": "Hash elements are accessed in a similar way as with the arrays, the different is that in a hash we will use a key instead of an index as in arrays. We use the  []  to access hash elements as follows :  2 . 2 . 5   : 151     p \n  =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }   2 . 2 . 5   : 152     p [ :name ] \n  =   Joseph", 
            "title": "Accessing Hash elements"
        }, 
        {
            "location": "/hashes/#selecting-key-and-values", 
            "text": "We can use the  select  method to return the key/value pairs of a hash as follows :  2 . 2 . 5   : 157     p . select   { | key , value |   value   ==   Joseph } \n  =   { :name = Joseph }", 
            "title": "Selecting key and values"
        }, 
        {
            "location": "/hashes/#looping-through-hash-elements", 
            "text": "We can loop through the key/value pair of hash elements using the  each  method as follows :  2 . 2 . 5   : 158     p . each   { | key , value |   p   #{ key }   #{ value } }  name Joseph  company Peruzal  location Cape Town \n  =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }", 
            "title": "Looping Through Hash elements"
        }, 
        {
            "location": "/hashes/#loop-through-each-value-pair", 
            "text": "We can instead loop through each value pair using the  each_value  method as follows :  2 . 2 . 5   : 159     p . each_value   { | v |   p   v }  Joseph  Peruzal  Cape Town \n  =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }", 
            "title": "Loop through each value pair"
        }, 
        {
            "location": "/hashes/#loop-through-each-key", 
            "text": "We can also loop through the keys using the  each_key  as follows :  2 . 2 . 5   : 160     p . each_key   { | k |   p   k }  :name  :company  :location \n  =   { :name = Joseph ,   :company = Peruzal ,   :location = Cape Town }", 
            "title": "Loop through each key"
        }, 
        {
            "location": "/hashes/#clearing-hashes", 
            "text": "We can use the  clear  method to clear the contents of the hash as follows :  2 . 2 . 5   : 161     p . clear \n  =   {}", 
            "title": "Clearing hashes"
        }, 
        {
            "location": "/hashes/#check-if-hash-if-empty", 
            "text": "We can use the  empty?  method to check if the hash is empty of not as follows :  2 . 2 . 5   : 162     p . empty? \n  =   true", 
            "title": "Check if hash if empty"
        }, 
        {
            "location": "/hashes/#remove-keys", 
            "text": "We can remove keys at the beginning of the hash by using the  shift  method as follows :  2 . 2 . 5   : 165     p \n  =   { :name = Joseph ,   :company = Peruzal }  2 . 2 . 5   : 166     p . shift \n  =   [ :name ,   Joseph ]  2 . 2 . 5   : 167     p \n  =   { :company = Peruzal }", 
            "title": "Remove keys"
        }, 
        {
            "location": "/hashes/#merge-hashes", 
            "text": "We can use the  merge  method to join two hashes together as follows :  2 . 2 . 5   : 179     person   =   {   first_name :   Joseph ,   last_name :   Kandi   } \n  =   { :first_name = Joseph ,   :last_name = Kandi }   2 . 2 . 5   : 180     company   =   {   name :   Peruzal ,   location :   Cape Town   } \n  =   { :name = Peruzal ,   :location = Cape Town }   2 . 2 . 5   : 181     person . merge ( company ) \n  =   { :first_name = Joseph ,   :last_name = Kandi ,   :name = Peruzal ,   :location = Cape Town }", 
            "title": "Merge hashes"
        }, 
        {
            "location": "/hashes/#exercise", 
            "text": "Choose a random value using a weighted value from a list. The higher the value, the higher the chances of choosing the same value. Assign a weight to each value. E.g :   marbles   =   {   :black   =   51 ,   :white   =   17   }  3 . times   {   puts   choose_weighted ( marbles )   }  # black  # white  # black", 
            "title": "Exercise"
        }, 
        {
            "location": "/hashes/#solution", 
            "text": "The following is one way of implementing it :   def   choose_weighted ( weighted ) \n     sum   =   weighted . inject ( 0 )   do   | sum ,   item_and_weight | \n         sum   +=   item_and_weight [ 1 ] \n     end \n     target   =   rand ( sum ) \n     weighted . each   do   | item ,   weight | \n         return   item   if   target   =   weight \n         target   -=   weight \n     end  end  lottery_probabilities   =   {   You ve wasted your money!   =   1000 , \n                               You ve won back the cost of your ticket!   =   50 , \n                               You ve won two shiny zorkmids!   =   20 , \n                               You ve won five zorkmids!   =   10 , \n                               You ve won ten zorkmids!   =   5 , \n                               You ve won a hundred zorkmids!   =   1   }  # Let s buy some lottery tickets.  5 . times   {   puts   choose_weighted ( lottery_probabilities )   }", 
            "title": "Solution"
        }, 
        {
            "location": "/numbers/", 
            "text": "Numbers\n\n\nNumbers Inheritance Hierarchy\n\n\n\n\nNumeric\n is the class from which all higher-level numeric classes should inherit. Classes such as \nInteger\n inherit from the \nNumeric\n class. Numeric contains methods such as \nabs\n, \nceil\n, \nzero?\n, \nnegative?\n, \nto_int\n and more.\n\n\n\n\nThe \nInteger\n class is the parent for the \nFixnum\n and \nBigNum\n.\n\n\nFixnum\n is used for fixed length numbers. \nBigNum\n holds numbers that cannot fit in a Fixnum. The conversion happens automatically.\n\n\nFloat\n represent floating-point numbers.\n\n\nComplex\n represents complex numbers, numbers in the form \na+b_i_\n where \ni\n is an imaginary number.\n\n\nRational\n represents rational numbers, numbers in the form \na/b\n.\n\n\n\n\nCreating Numbers\n\n\nWe can create number types from their literal values e,g :\n\n\nirb\n(\nmain\n):\n098\n:\n0\n \nn\n \n=\n \n10\n\n\n=\n \n10\n\n\nirb\n(\nmain\n):\n099\n:\n0\n \nn\n.\nclass\n\n\n=\n \nInteger\n\n\n\n\n\n\nWe can check what type \nn\n is using the \nclass\n method or using the \nis_a?\n method as follows :\n\n\nirb\n(\nmain\n):\n100\n:\n0\n \nn\n.\nis_a?\n \nInteger\n\n\n=\n \ntrue\n\n\n\n\n\n\nOr if its a \nFloat\n type we can use the \nis_float?\n :\n\n\nirb\n(\nmain\n):\n101\n:\n0\n \nn\n.\nis_a?\n \nFloat\n\n\n=\n \nfalse\n\n\n\n\n\n\nNumeric Alterations\n\n\nNumeric types allows for performing mathematical calculations.\n\n\nirb\n(\nmain\n):\n105\n:\n0\n \nn\n \n=\n \n20\n\n\n=\n \n20\n\n\nirb\n(\nmain\n):\n106\n:\n0\n \nn\n \n=\n \nn\n+\n \n2\n\n\n=\n \n22\n\n\n\n\n\n\nirb\n(\nmain\n):\n107\n:\n0\n \nn\n \n=\n \nn\n \n/\n \n2\n.\n0\n\n\n=\n \n11\n.\n0\n\n\nirb\n(\nmain\n):\n108\n:\n0\n \nn\n.\nclass\n\n\n=\n \nFloat\n\n\nirb\n(\nmain\n):\n109\n:\n0\n \nn\n.\nis_a?\n \nNumeric\n\n\n=\n \ntrue\n\n\n\n\n\n\nWe can also call methods on the numeric types e.g to get the absolute value as follows :\n\n\nirb\n(\nmain\n):\n111\n:\n0\n \nn\n \n=\n \n-\n10\n\n\n=\n \n-\n10\n\n\nirb\n(\nmain\n):\n112\n:\n0\n \nn\n.\nabs\n\n\n=\n \n10\n\n\n\n\n\n\nGet the ceiling using the \nceiling\n as follows :\n\n\nirb\n(\nmain\n):\n114\n:\n0\n \nn\n \n=\n \n10\n.\n6\n\n\n=\n \n10\n.\n6\n\n\nirb\n(\nmain\n):\n115\n:\n0\n \nn\n.\nceil\n\n\n=\n \n11\n\n\n\n\n\n\nand also the floor using the \nfloor\n function as follows :\n\n\nirb\n(\nmain\n):\n117\n:\n0\n \nn\n \n=\n \n10\n.\n6\n\n\n=\n \n10\n.\n6\n\n\nirb\n(\nmain\n):\n118\n:\n0\n \nn\n.\nfloor\n\n\n=\n \n10\n\n\n\n\n\n\nWe can also round integer values using the \nround\n function as follows :\n\n\nirb\n(\nmain\n):\n119\n:\n0\n \nn\n \n=\n \n10\n.\n6\n\n\n=\n \n10\n.\n6\n\n\nirb\n(\nmain\n):\n120\n:\n0\n \nn\n.\nround\n\n\n=\n \n11\n\n\n\n\n\n\nor round down :\n\n\nirb\n(\nmain\n):\n121\n:\n0\n \nn\n \n=\n \n10\n.\n2\n\n\n=\n \n10\n.\n2\n\n\nirb\n(\nmain\n):\n122\n:\n0\n \nn\n.\nround\n\n\n=\n \n10\n\n\n\n\n\n\nNumeric Comparison\n\n\nWe can perform numeric comparison using the number class.\n\n\n \nn\n \n=\n \n10\n\n\n=\n \n10\n\n\n \nn\n \n==\n \n10\n\n\n=\n \ntrue\n\n\n \nn\n \n \n5\n\n\n=\n \nfalse\n\n\n \nn\n \n=\n \n12\n\n\n=\n \ntrue\n\n\n \nn\n \n==\n \n10\n.\n00\n\n\n=\n \ntrue\n\n\n\n\n\n\nWe can also compare the number using the spaceship operator as follows :\n\n\n \n10\n \n=\n \n11\n\n\n=\n \n-\n1\n\n\n \n10\n \n=\n \n9\n\n\n=\n \n1\n\n\n \n10\n \n=\n \n10\n\n\n=\n \n0\n\n\n\n\n\n\nWe can check if the two values are equal using the \neql?\n method as follows :\n\n\nirb\n(\nmain\n):\n123\n:\n0\n \n10\n.\neql?\n \n10\n\n\n=\n \ntrue\n\n\nirb\n(\nmain\n):\n124\n:\n0\n \n10\n.\neql?\n \n10\n.\n0\n\n\n=\n \nfalse\n\n\n\n\n\n\nCheck if the values are even or odd as follows :\n\n\n \n10\n.\nodd?\n\n\n=\n \nfalse\n\n\n \n10\n.\neven?\n\n\n=\n \ntrue\n\n\n\n\n\n\nCheck if the number is between a specific range as follows :\n\n\n \n10\n.\nbetween?\n(\n3\n,\n12\n)\n\n\n=\n \ntrue\n\n\n\n\n\n\nWe can use the iterators and count up to or down to a specified number as follows :\n\n\nirb\n(\nmain\n):\n126\n:\n0\n \n1\n.\nupto\n(\n3\n)\n \n{\n|\nn\n|\n \np\n \nn\n}\n\n\n1\n\n\n2\n\n\n3\n\n\n=\n \n1\n\n\n\n\n\n\nor going down as follows :\n\n\nirb\n(\nmain\n):\n127\n:\n0\n \n3\n.\ndownto\n(\n1\n)\n \n{\n|\nn\n|\n \np\n \nn\n}\n\n\n3\n\n\n2\n\n\n1\n\n\n=\n \n3\n\n\n\n\n\n\nParsing Numbers\n\n\nWe can get the corresponding number represented as a string :\n\n\n400\n.\nto_i\n       \n# =\n 400\n\n\n3.14\n.\nto_f\n      \n# =\n 3.14\n\n\n1.602e-19\n.\nto_f\n \n# =\n 1.602e-19\n\n\n\n\n\n\nThe \nto_i\n coverts the number to an Integer and the \nto_f\n converts the number into a Float.\nWe can also pass in parameters to the methods to specify the base for the \nto_i\n method :\n\n\n405\n.\nto_i\n(\n8\n)\n  \n# 261\n\n\n405\n.\noct\n      \n# 261\n\n\n405\n.\nhex\n      \n# 1029\n\n\n405\n.\nto_i\n(\n16\n)\n \n# 1029\n\n\n\n\n\n\nWe can also convert numbers to their corresponding string in binary, octal, or hex as follows :\n\n\n405\n.\nto_s\n(\n2\n)\n     \n# 110010101\n\n\n405\n.\nto_s\n(\n16\n)\n    \n# 195\n\n\n\n\n\n\nYou can use the \nInteger\n and \nFloat\n classes to parse and these will throw errors if the string can't be parsed.\n\n\nInteger\n(\n405\n)\n          \n# 405\n\n\ni\n \n=\n \nInteger\n(\n405ab\n)\n    \n# ArgumentError: invalid value for Integer(): \n405ab\n\n\nFloat\n(\n4.5\n)\n            \n# 4.5\n\n\nFloat\n(\n4.5f\n)\n           \n# ArgumentError: invalid value for Float(): \n4.5f\n\n\n\n\n\n\nThe Integer \nto_s\n can create a string representation in every integer base. The String \nto_i\n can parse a string to a number in a supported base.\n\n\n-1001001\n.\nto_i\n(\n2\n)\n  \n# -73\n\n\nabc\n.\nto_i\n(\n16\n)\n      \n# 2748\n\n\n\n-\n73\n.\nto_s\n(\n2\n)\n         \n#  \n-1001001\n\n\n2748\n.\nto_s\n(\n16\n)\n       \n# 2748\n\n\n\n\n\n\nRandom Numbers\n\n\nThe \nrand\n method is used to generate random numbers.  \nrand\n returns a pseudo-random floating point number between 0.0 and 1.0, including 0.0 and excluding 1.0.\n\n\nrand\n    \n# 0.7376536979277991\n\n\nrand\n    \n# 0.7906867058221021\n\n\n\n\n\n\nIf we pass in a value \nn\n, it will generate a number between \n0\n and \nn - 1\n.\n\n\nrand\n(\n10\n)\n \n# generates numbers between 0 and 9\n\n\nrand\n(\n5\n..\n10\n)\n \n# generates numbers between 5 and 10\n\n\n\n\n\n\nExercise\n\n\n\n\nCreate a routine that generates random numbers\n\n\n\n\nSelect a random value from a hash. Create an hash, here is a sample :\n\n\nruby\nm = { key1: 'value1',\n        key2: 'value2',\n        key3: 'value3' }\n\n3. Find the average, median and mode for a set of numbers passed in as an array. Test with the following :\n\n\nruby\nmean([1,2,3,4]) # =\n 2.5\n\n4. We have a set of players that participated in different games as follows :\n\n\nruby\ngames = [[\"Alice\", \"Bob\"], [\"Carol\", \"Ted\"], [\"Alice\", \"Mallory\"], [\"Ted\", \"Bob\"]]\n \n\n\nWrite code to only show the unique players that participated. The set of players should not contain duplicates.\nExpected output should be \n\"Alice\", \"Mallory\", \"Ted\", \"Carol\", \"Bob\"\n\n5. Use the Luhn algorithm to verify a credit card number. More information on how the algorithm works is available on \nWikipedia\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThey are many ways to to this. Use the \nrand\n methods as follows to generate a random number :\n\n\nruby\nrand(47) # generate a random number bewtween 0 and 47\n\n2. We can first extract the values from the array and then choose each one at random.\n\n\nruby\nm.values.sample  # the values method returns all values as an array\nm[m.keys.sample] # longer version, get the random key and use it to find a value\n\n3. Here is the sample solution for finding the mean, media and mode.\n\n\n```ruby\n\n\nmean\n\n\ndef mean(array)\narray.inject(array.inject(0) { |sum, x| sum += x } / array.size.to_f\nend\n\n\nmedian\n\n\ndef median(array, already_sorted=false)\n    return nil if array.empty?\n    array = array.sort unless already_sorted\n    m_pos = array.size / 2\n    array.size % 2 == 1 ? array[m_pos] : mean(array[m_pos-1..m_pos])\nend\n\n\ndef modes(array, find_all=true)\n    histogram = array.inject(Hash.new(0)) { |h, n| h[n] += 1; h }\n    modes = nil\n    histogram.each_pair do |item, times|\n        modes \n item if modes \n times == modes[0] and find_all\n        modes = [times, item] if (!modes \n times \n 1) or (modes \n times \n modes[0])\n    end\n    modes ? modes[1\u2026modes.size] : modes\nend\n\n\nmean([1,2,3,4]) # =\n 2.5\nmedian([1,2,3,4,5]) # =\n 3\nmodes([1,2,3,4]) # =\n nil\nmodes([1,1,2,3,4]) # =\n [1]\nmodes([1,1,2,2,3,4]) # =\n [1, 2]\nmodes([1,1,2,2,3,4,4]) # =\n [1, 2, 4]\nmodes([1,1,2,2,3,4,4], false) # =\n [1]\n\n``\n4. We can use the\nSet` class found in the set standard library. We will need to require it as follows :\n\n\n```ruby\nrequire 'set'\n\n\ngames = [[\"Alice\", \"Bob\"], [\"Carol\", \"Ted\"], [\"Alice\", \"Mallory\"], [\"Ted\", \"Bob\"]]\nplayers = games.inject(Set.new) { |set, game| game.each { |p| set \n p }; set }\n```\n\n\nWe can also convert an array to a set using the \nto_set\n method. This wil remove duplicates.\n5. Many implementations of the algorithm.", 
            "title": "Numbers"
        }, 
        {
            "location": "/numbers/#numbers", 
            "text": "", 
            "title": "Numbers"
        }, 
        {
            "location": "/numbers/#numbers-inheritance-hierarchy", 
            "text": "Numeric  is the class from which all higher-level numeric classes should inherit. Classes such as  Integer  inherit from the  Numeric  class. Numeric contains methods such as  abs ,  ceil ,  zero? ,  negative? ,  to_int  and more.   The  Integer  class is the parent for the  Fixnum  and  BigNum .  Fixnum  is used for fixed length numbers.  BigNum  holds numbers that cannot fit in a Fixnum. The conversion happens automatically.  Float  represent floating-point numbers.  Complex  represents complex numbers, numbers in the form  a+b_i_  where  i  is an imaginary number.  Rational  represents rational numbers, numbers in the form  a/b .", 
            "title": "Numbers Inheritance Hierarchy"
        }, 
        {
            "location": "/numbers/#creating-numbers", 
            "text": "We can create number types from their literal values e,g :  irb ( main ): 098 : 0   n   =   10  =   10  irb ( main ): 099 : 0   n . class  =   Integer   We can check what type  n  is using the  class  method or using the  is_a?  method as follows :  irb ( main ): 100 : 0   n . is_a?   Integer  =   true   Or if its a  Float  type we can use the  is_float?  :  irb ( main ): 101 : 0   n . is_a?   Float  =   false", 
            "title": "Creating Numbers"
        }, 
        {
            "location": "/numbers/#numeric-alterations", 
            "text": "Numeric types allows for performing mathematical calculations.  irb ( main ): 105 : 0   n   =   20  =   20  irb ( main ): 106 : 0   n   =   n +   2  =   22   irb ( main ): 107 : 0   n   =   n   /   2 . 0  =   11 . 0  irb ( main ): 108 : 0   n . class  =   Float  irb ( main ): 109 : 0   n . is_a?   Numeric  =   true   We can also call methods on the numeric types e.g to get the absolute value as follows :  irb ( main ): 111 : 0   n   =   - 10  =   - 10  irb ( main ): 112 : 0   n . abs  =   10   Get the ceiling using the  ceiling  as follows :  irb ( main ): 114 : 0   n   =   10 . 6  =   10 . 6  irb ( main ): 115 : 0   n . ceil  =   11   and also the floor using the  floor  function as follows :  irb ( main ): 117 : 0   n   =   10 . 6  =   10 . 6  irb ( main ): 118 : 0   n . floor  =   10   We can also round integer values using the  round  function as follows :  irb ( main ): 119 : 0   n   =   10 . 6  =   10 . 6  irb ( main ): 120 : 0   n . round  =   11   or round down :  irb ( main ): 121 : 0   n   =   10 . 2  =   10 . 2  irb ( main ): 122 : 0   n . round  =   10", 
            "title": "Numeric Alterations"
        }, 
        {
            "location": "/numbers/#numeric-comparison", 
            "text": "We can perform numeric comparison using the number class.    n   =   10  =   10    n   ==   10  =   true    n     5  =   false    n   =   12  =   true    n   ==   10 . 00  =   true   We can also compare the number using the spaceship operator as follows :    10   =   11  =   - 1    10   =   9  =   1    10   =   10  =   0   We can check if the two values are equal using the  eql?  method as follows :  irb ( main ): 123 : 0   10 . eql?   10  =   true  irb ( main ): 124 : 0   10 . eql?   10 . 0  =   false   Check if the values are even or odd as follows :    10 . odd?  =   false    10 . even?  =   true   Check if the number is between a specific range as follows :    10 . between? ( 3 , 12 )  =   true   We can use the iterators and count up to or down to a specified number as follows :  irb ( main ): 126 : 0   1 . upto ( 3 )   { | n |   p   n }  1  2  3  =   1   or going down as follows :  irb ( main ): 127 : 0   3 . downto ( 1 )   { | n |   p   n }  3  2  1  =   3", 
            "title": "Numeric Comparison"
        }, 
        {
            "location": "/numbers/#parsing-numbers", 
            "text": "We can get the corresponding number represented as a string :  400 . to_i         # =  400  3.14 . to_f        # =  3.14  1.602e-19 . to_f   # =  1.602e-19   The  to_i  coverts the number to an Integer and the  to_f  converts the number into a Float.\nWe can also pass in parameters to the methods to specify the base for the  to_i  method :  405 . to_i ( 8 )    # 261  405 . oct        # 261  405 . hex        # 1029  405 . to_i ( 16 )   # 1029   We can also convert numbers to their corresponding string in binary, octal, or hex as follows :  405 . to_s ( 2 )       # 110010101  405 . to_s ( 16 )      # 195   You can use the  Integer  and  Float  classes to parse and these will throw errors if the string can't be parsed.  Integer ( 405 )            # 405  i   =   Integer ( 405ab )      # ArgumentError: invalid value for Integer():  405ab  Float ( 4.5 )              # 4.5  Float ( 4.5f )             # ArgumentError: invalid value for Float():  4.5f   The Integer  to_s  can create a string representation in every integer base. The String  to_i  can parse a string to a number in a supported base.  -1001001 . to_i ( 2 )    # -73  abc . to_i ( 16 )        # 2748  - 73 . to_s ( 2 )           #   -1001001  2748 . to_s ( 16 )         # 2748", 
            "title": "Parsing Numbers"
        }, 
        {
            "location": "/numbers/#random-numbers", 
            "text": "The  rand  method is used to generate random numbers.   rand  returns a pseudo-random floating point number between 0.0 and 1.0, including 0.0 and excluding 1.0.  rand      # 0.7376536979277991  rand      # 0.7906867058221021   If we pass in a value  n , it will generate a number between  0  and  n - 1 .  rand ( 10 )   # generates numbers between 0 and 9  rand ( 5 .. 10 )   # generates numbers between 5 and 10", 
            "title": "Random Numbers"
        }, 
        {
            "location": "/numbers/#exercise", 
            "text": "Create a routine that generates random numbers   Select a random value from a hash. Create an hash, here is a sample :  ruby\nm = { key1: 'value1',\n        key2: 'value2',\n        key3: 'value3' } \n3. Find the average, median and mode for a set of numbers passed in as an array. Test with the following :  ruby\nmean([1,2,3,4]) # =  2.5 \n4. We have a set of players that participated in different games as follows :  ruby\ngames = [[\"Alice\", \"Bob\"], [\"Carol\", \"Ted\"], [\"Alice\", \"Mallory\"], [\"Ted\", \"Bob\"]]    Write code to only show the unique players that participated. The set of players should not contain duplicates.\nExpected output should be  \"Alice\", \"Mallory\", \"Ted\", \"Carol\", \"Bob\" \n5. Use the Luhn algorithm to verify a credit card number. More information on how the algorithm works is available on  Wikipedia", 
            "title": "Exercise"
        }, 
        {
            "location": "/numbers/#solution", 
            "text": "They are many ways to to this. Use the  rand  methods as follows to generate a random number :  ruby\nrand(47) # generate a random number bewtween 0 and 47 \n2. We can first extract the values from the array and then choose each one at random.  ruby\nm.values.sample  # the values method returns all values as an array\nm[m.keys.sample] # longer version, get the random key and use it to find a value \n3. Here is the sample solution for finding the mean, media and mode.  ```ruby", 
            "title": "Solution"
        }, 
        {
            "location": "/numbers/#mean", 
            "text": "def mean(array)\narray.inject(array.inject(0) { |sum, x| sum += x } / array.size.to_f\nend", 
            "title": "mean"
        }, 
        {
            "location": "/numbers/#median", 
            "text": "def median(array, already_sorted=false)\n    return nil if array.empty?\n    array = array.sort unless already_sorted\n    m_pos = array.size / 2\n    array.size % 2 == 1 ? array[m_pos] : mean(array[m_pos-1..m_pos])\nend  def modes(array, find_all=true)\n    histogram = array.inject(Hash.new(0)) { |h, n| h[n] += 1; h }\n    modes = nil\n    histogram.each_pair do |item, times|\n        modes   item if modes   times == modes[0] and find_all\n        modes = [times, item] if (!modes   times   1) or (modes   times   modes[0])\n    end\n    modes ? modes[1\u2026modes.size] : modes\nend  mean([1,2,3,4]) # =  2.5\nmedian([1,2,3,4,5]) # =  3\nmodes([1,2,3,4]) # =  nil\nmodes([1,1,2,3,4]) # =  [1]\nmodes([1,1,2,2,3,4]) # =  [1, 2]\nmodes([1,1,2,2,3,4,4]) # =  [1, 2, 4]\nmodes([1,1,2,2,3,4,4], false) # =  [1] ``\n4. We can use the Set` class found in the set standard library. We will need to require it as follows :  ```ruby\nrequire 'set'  games = [[\"Alice\", \"Bob\"], [\"Carol\", \"Ted\"], [\"Alice\", \"Mallory\"], [\"Ted\", \"Bob\"]]\nplayers = games.inject(Set.new) { |set, game| game.each { |p| set   p }; set }\n```  We can also convert an array to a set using the  to_set  method. This wil remove duplicates.\n5. Many implementations of the algorithm.", 
            "title": "median"
        }, 
        {
            "location": "/booleans/", 
            "text": "Booleans\n\n\nBooleans are used to represent true or false values. In Ruby the \ntrue\n and \nfalse\n are each individual classes. The class for true is \nTrueClass\n and the false is \nFalseClass\n.\n\n\nCreating Booleans\n\n\nCheck the class for \ntrue\n and \nfalse\n as follows :\n\n\nirb\n(\nmain\n):\n001\n:\n0\n \ntrue\n.\nclass\n\n\n=\n \nTrueClass\n\n\nirb\n(\nmain\n):\n002\n:\n0\n \nfalse\n.\nclass\n\n\n=\n \nFalseClass\n\n\n\n\n\n\nExpression Trees\n\n\nBooleans are used in evaluation expressions.\n\n\n \nn\n \n=\n \n20\n\n\n=\n \n20\n\n\n \nn\n \n=\n \n20\n\n\n=\n \ntrue\n\n\n\n\n\n\nAdditional expression tests :\n\n\n \nname\n \n=\n \nJoseph\n\n\n=\n \nJoseph\n\n\n \nname\n \n==\n \nPrudence\n \n \nn\n \n \n20\n\n\n=\n \nfalse\n\n\n\n\n\n\nif statement\n\n\nWe can also use the \nif\n statement to check for a true of false condition. The \nif\n statement have the following syntax :\n\n\nif\n \nboolean\n \nexpress\n\n \n#statements here\n\n\nend\n\n\n\n\n\n\nfor example :\n\n\nif\n \ncompany\n \n==\n \nPeruzal\n\n    \nputs\n \nCompany is \n#{\ncompany\n}\n\n\nend\n\n\n\n\n\n\nNegation\n\n\nThe \n!\n negates the boolean statement :\n\n\nx\n \n=\n \nfalse\n\n\nif\n \n!\nx\n\n \nputs\n \nx is false\n\n\nend\n\n\n\n\n\n\nMultiple tests\n\n\nWe can perform multiple logical operations. The result should be boolean :\n\n\nruby\n \n=\n \nnifty\n\n\nprogramming\n \n=\n \nfun\n\n\n\nif\n \nruby\n \n==\n \nnifty\n \n \nprogramming\n \n==\n \nfun\n \n# using the and operator\n\n \nputs\n \nKeep programming!\n\n\nend\n\n\n\nif\n \nruby\n==\nnifty\n \nand\n \nprogramming\n==\nfun\n \nand\n \nweather\n==\nnice\n \n# using the and logical operator\n\n  \nputs\n \nStop programming and go outside!\n\n\nend\n\n\n\nif\n \na\n \n==\n \n10\n \n||\n \nb\n \n==\n \n27\n \n||\n \nc\n \n=\n \n43\n \n||\n \nd\n \n=\n \n\u2212\n14\n \n# using the ||(or) logical operator\n\n \nprint\n \nsum\n \n=\n \na\n \n+\n \nb\n \n+\n \nc\n \n+\n \nd\n\n\nend\n\n\n\nif\n \nruby\n \n==\n \nnifty\n \nor\n \nprogramming\n \n==\n \nfun\n \n# using the or logical operator\n\n \nputs\n \nKeep programming!\n\n\nend\n\n\n\n\n\n\nPutting \nif\n at the end of the statement\n\n\nFor one line \nif\n statements, you can place the if condition at the end of the statement as follows :\n\n\nputs\n \nRuby is great\n \nif\n \ntrue\n\n\n\n\n\n\nThe \nelse\n statement\n\n\nAdd an optional else to execute a statement when if is not true:\n\n\nif\n \nx\n \n=\n \ny\n\n \nputs\n \nx greater than or equal to y\n\n\nelse\n\n \nputs\n \nx is not greater than or equal to y\n\n\nend\n\n\n\n\n\n\nThe \nelsif\n statement\n\n\nUse one or more optional \nelsif\n statements to test multiple statements (ending with an optional else, which must be last):\n\n\nif\n \nx\n \n==\n \ny\n\n \nputs\n \nx equals y\n\n\nelsif\n \nx\n \n!=\n \ny\n\n \nputs\n \nx is not equal to y\n\n\nelsif\n \nx\n \n \ny\n\n \nputs\n \nx is greater than y\n\n\nelsif\n \nx\n \n \ny\n\n \nputs\n \nx is less than y\n\n\nelse\n\n \nputs\n \nWell, i dont what is x and y is\n\n\nend\n\n\n\n\n\n\nunless\n statement\n\n\nThe \nunless\n statement is the negation of an \nif\n statement.\n\n\nunless\n \ncompany\n \n==\n \nPeruzal\n\n \ncompany\n \n=\n \nUnknown\n\n\nelse\n\n \ncompany\n \n=\n \nPeruzal\n\n\nend\n\n\n\n\n\n\nThe equivalent \nif\n statement :\n\n\nif\n \ncompany\n \n==\n \nPeruzal\n\n \ncompany\n \n=\n \nPeruzal\n\n\nelse\n\n \ncompany\n \n=\n \nUnknown\n\n\nend\n\n\n\n\n\n\nShot unless statement\n\n\nWe can also add the \nunless\n at the end of the statement as follows :\n\n\ncompany\n \n=\n \n\n\nputs\n \nI don\nt know your company\n \nunless\n \ncompany\n \n==\n \nPeruzal\n\n\n\n\n\n\nTenary operator\n\n\nFor short \nif\n else expression and then assign a variable, we can use the tenary operator \n?:\n as follows :\n\n\n \n(\ncompany\n.\neql?\nPeruzal\n)\n \n?\n \nYes\n \n:\n \nNo\n\n\n=\n \nYes\n\n\n\n\n\n\nWe usually assign the value returned to a variable. The ternary operator is a shortened version of the \nif-else\n construct.", 
            "title": "Booleans"
        }, 
        {
            "location": "/booleans/#booleans", 
            "text": "Booleans are used to represent true or false values. In Ruby the  true  and  false  are each individual classes. The class for true is  TrueClass  and the false is  FalseClass .", 
            "title": "Booleans"
        }, 
        {
            "location": "/booleans/#creating-booleans", 
            "text": "Check the class for  true  and  false  as follows :  irb ( main ): 001 : 0   true . class  =   TrueClass  irb ( main ): 002 : 0   false . class  =   FalseClass", 
            "title": "Creating Booleans"
        }, 
        {
            "location": "/booleans/#expression-trees", 
            "text": "Booleans are used in evaluation expressions.    n   =   20  =   20    n   =   20  =   true   Additional expression tests :    name   =   Joseph  =   Joseph    name   ==   Prudence     n     20  =   false", 
            "title": "Expression Trees"
        }, 
        {
            "location": "/booleans/#if-statement", 
            "text": "We can also use the  if  statement to check for a true of false condition. The  if  statement have the following syntax :  if   boolean   express \n  #statements here  end   for example :  if   company   ==   Peruzal \n     puts   Company is  #{ company }  end", 
            "title": "if statement"
        }, 
        {
            "location": "/booleans/#negation", 
            "text": "The  !  negates the boolean statement :  x   =   false  if   ! x \n  puts   x is false  end", 
            "title": "Negation"
        }, 
        {
            "location": "/booleans/#multiple-tests", 
            "text": "We can perform multiple logical operations. The result should be boolean :  ruby   =   nifty  programming   =   fun  if   ruby   ==   nifty     programming   ==   fun   # using the and operator \n  puts   Keep programming!  end  if   ruby == nifty   and   programming == fun   and   weather == nice   # using the and logical operator \n   puts   Stop programming and go outside!  end  if   a   ==   10   ||   b   ==   27   ||   c   =   43   ||   d   =   \u2212 14   # using the ||(or) logical operator \n  print   sum   =   a   +   b   +   c   +   d  end  if   ruby   ==   nifty   or   programming   ==   fun   # using the or logical operator \n  puts   Keep programming!  end", 
            "title": "Multiple tests"
        }, 
        {
            "location": "/booleans/#putting-if-at-the-end-of-the-statement", 
            "text": "For one line  if  statements, you can place the if condition at the end of the statement as follows :  puts   Ruby is great   if   true", 
            "title": "Putting if at the end of the statement"
        }, 
        {
            "location": "/booleans/#the-else-statement", 
            "text": "Add an optional else to execute a statement when if is not true:  if   x   =   y \n  puts   x greater than or equal to y  else \n  puts   x is not greater than or equal to y  end", 
            "title": "The else statement"
        }, 
        {
            "location": "/booleans/#the-elsif-statement", 
            "text": "Use one or more optional  elsif  statements to test multiple statements (ending with an optional else, which must be last):  if   x   ==   y \n  puts   x equals y  elsif   x   !=   y \n  puts   x is not equal to y  elsif   x     y \n  puts   x is greater than y  elsif   x     y \n  puts   x is less than y  else \n  puts   Well, i dont what is x and y is  end", 
            "title": "The elsif statement"
        }, 
        {
            "location": "/booleans/#unless-statement", 
            "text": "The  unless  statement is the negation of an  if  statement.  unless   company   ==   Peruzal \n  company   =   Unknown  else \n  company   =   Peruzal  end   The equivalent  if  statement :  if   company   ==   Peruzal \n  company   =   Peruzal  else \n  company   =   Unknown  end", 
            "title": "unless statement"
        }, 
        {
            "location": "/booleans/#shot-unless-statement", 
            "text": "We can also add the  unless  at the end of the statement as follows :  company   =    puts   I don t know your company   unless   company   ==   Peruzal", 
            "title": "Shot unless statement"
        }, 
        {
            "location": "/booleans/#tenary-operator", 
            "text": "For short  if  else expression and then assign a variable, we can use the tenary operator  ?:  as follows :    ( company . eql? Peruzal )   ?   Yes   :   No  =   Yes   We usually assign the value returned to a variable. The ternary operator is a shortened version of the  if-else  construct.", 
            "title": "Tenary operator"
        }, 
        {
            "location": "/objects/", 
            "text": "Constants\n\n\nRuby comes with a lot of constants that hold various information. Here are some common constants :\n\n\n\n\nARGF\n\n\nARGV\n\n\nDATA\n\n\nENV\n\n\nRUBY_*\n\n\nSTDERR\n\n\nSTDIN\n\n\nSTDOUT\n\n\nTRUE/FALSE/NIL\n\n\n\n\nARGF\n\n\nARGF\n is a stream built when passing in a list of files to be processed using arguments to an application. As a file is processed by \nARGF\n it is removed from the ARGV array so that it it not re-processed.\n\n\nARGF is a stream designed for use in scripts that process files given as command-line arguments or passed in via STDIN.\n\n\nThe arguments passed to your script are stored in the ARGV Array, one argument per element. ARGF assumes that any arguments that aren't filenames have been removed from ARGV. For example:\n\n\n$\n \nruby\n \nargf\n.\nrb\n \n--\nverbose\n \nfile1\n \nfile2\n\n\n\nARGV\n  \n#=\n [\n--verbose\n, \nfile1\n, \nfile2\n]\n\n\noption\n \n=\n \nARGV\n.\nshift\n \n#=\n \n--verbose\n\n\nARGV\n  \n#=\n [\nfile1\n, \nfile2\n]\n\n\n\n\n\n\nYou can now use ARGF to work with a concatenation of each of these named files. For instance, ARGF.read will return the contents of file1 followed by the contents of file2.\n\n\nAfter a file in ARGV has been read ARGF removes it from the Array. Thus, after all files have been read ARGV will be empty.\n\n\nYou can manipulate ARGV yourself to control what ARGF operates on. If you remove a file from ARGV, it is ignored by ARGF; if you add files to ARGV, they are treated as if they were named on the command line. For example:\n\n\nARGV\n.\nreplace\n \n[\nfile1\n]\n\n\nARGF\n.\nreadlines\n \n# Returns the contents of file1 as an Array\n\n\nARGV\n           \n#=\n []\n\n\nARGV\n.\nreplace\n \n[\nfile2\n,\n \nfile3\n]\n\n\nARGF\n.\nread\n      \n# Returns the contents of file2 and file3\n\n\n\n\n\n\nARGV\n\n\nIt is an alias of $*. Holds command line arguments\n\n\nARGF\n\n\n#!/usr/bin/env ruby\n\n\ncount\n \n=\n \nARGV\n.\ncount\n\n\nputs\n \nARGV\n[\n0\n]\n \nif\n \ncount\n \n \n0\n\n\n\n\n\n\nDATA\n\n\nRead portions of the code marked with \nEND\n and ends at the end of the file.\n\n\nENV\n\n\nRead environment variables.\n\n\nirb\n(\nmain\n):\n012\n:\n0\n \nENV\n[\nHOME\n]\n\n\n=\n \n/Users/joseph\n\n\n\n\n\n\n \nENV\n.\ninspect\n\n\n\n\n\n\nRUBY_* Constants\n\n\nConstants hold information about Ruby. Here are some constants :\n\n\n\n\nRUBY_COPYRIGHT\n\n\nRUBY_DESCRIPTION\n\n\nRUBY_ENGINE\n\n\nRUBY_PATCHLEVEL\n\n\nRUBY_PLATFORM\n\n\nRUBY_RELEASE_DATA\n\n\nRUBY_VERSION\n\n\nRUBY_REVISION\n\n\n\n\nFreezing Objects\n\n\nMake an object read-only.\n\n\nirb\n(\nmain\n):\n014\n:\n0\n \nresults\n \n=\n \n[\n10\n,\n \n120\n,\n \n57\n]\n\n\n=\n \n[\n10\n,\n \n120\n,\n \n57\n]\n\n\nirb\n(\nmain\n):\n015\n:\n0\n \nresults\n.\nfreeze\n\n\n=\n \n[\n10\n,\n \n120\n,\n \n57\n]\n\n\nirb\n(\nmain\n):\n016\n:\n0\n \nresults\n.\nfrozen?\n\n\n=\n \ntrue\n\n\nirb\n(\nmain\n):\n017\n:\n0\n \nresults\n.\npop\n\n\nRuntimeError\n:\n \ncan\nt\n \nmodify\n \nfrozen\n \nArray\n\n\n\n\n\n\nObject Metadata\n\n\nWe can check object metadata using methods such as \ninstance_of?\n as follows :\n\n\n \nclass\n \nPerson\n\n\n   \nend\n\n\n=\n \nnil\n\n\n  \np\n \n=\n \nPerson\n.\nnew\n\n\n=\n \n#\nPerson:0x007fad4d0032f8\n\n\n \np1\n \n=\n \nPerson\n.\nnew\n\n\n=\n \n#\nPerson:0x007fad4c20ed78\n\n\n \np\n.\ninstance_of?\n \nPerson\n\n\n\n\n\n\nCheck instance\n\n\nWe can use the \nis_a?\n method to check if an object is an instance of the type as follows :\n\n\n \nclass\n \nPerson\n\n\n   \nend\n\n\n=\n \nnil\n\n\n  \np\n \n=\n \nPerson\n.\nnew\n\n\n=\n \n#\nPerson:0x007fad4d0032f8\n\n\n \np\n.\nis_a?\n \nPerson\n\n\n=\n \ntrue", 
            "title": "Objects"
        }, 
        {
            "location": "/objects/#constants", 
            "text": "Ruby comes with a lot of constants that hold various information. Here are some common constants :   ARGF  ARGV  DATA  ENV  RUBY_*  STDERR  STDIN  STDOUT  TRUE/FALSE/NIL", 
            "title": "Constants"
        }, 
        {
            "location": "/objects/#argf", 
            "text": "ARGF  is a stream built when passing in a list of files to be processed using arguments to an application. As a file is processed by  ARGF  it is removed from the ARGV array so that it it not re-processed.  ARGF is a stream designed for use in scripts that process files given as command-line arguments or passed in via STDIN.  The arguments passed to your script are stored in the ARGV Array, one argument per element. ARGF assumes that any arguments that aren't filenames have been removed from ARGV. For example:  $   ruby   argf . rb   -- verbose   file1   file2  ARGV    #=  [ --verbose ,  file1 ,  file2 ]  option   =   ARGV . shift   #=   --verbose  ARGV    #=  [ file1 ,  file2 ]   You can now use ARGF to work with a concatenation of each of these named files. For instance, ARGF.read will return the contents of file1 followed by the contents of file2.  After a file in ARGV has been read ARGF removes it from the Array. Thus, after all files have been read ARGV will be empty.  You can manipulate ARGV yourself to control what ARGF operates on. If you remove a file from ARGV, it is ignored by ARGF; if you add files to ARGV, they are treated as if they were named on the command line. For example:  ARGV . replace   [ file1 ]  ARGF . readlines   # Returns the contents of file1 as an Array  ARGV             #=  []  ARGV . replace   [ file2 ,   file3 ]  ARGF . read        # Returns the contents of file2 and file3", 
            "title": "ARGF"
        }, 
        {
            "location": "/objects/#argv", 
            "text": "It is an alias of $*. Holds command line arguments", 
            "title": "ARGV"
        }, 
        {
            "location": "/objects/#argf_1", 
            "text": "#!/usr/bin/env ruby  count   =   ARGV . count  puts   ARGV [ 0 ]   if   count     0", 
            "title": "ARGF"
        }, 
        {
            "location": "/objects/#data", 
            "text": "Read portions of the code marked with  END  and ends at the end of the file.", 
            "title": "DATA"
        }, 
        {
            "location": "/objects/#env", 
            "text": "Read environment variables.  irb ( main ): 012 : 0   ENV [ HOME ]  =   /Users/joseph     ENV . inspect", 
            "title": "ENV"
        }, 
        {
            "location": "/objects/#ruby_-constants", 
            "text": "Constants hold information about Ruby. Here are some constants :   RUBY_COPYRIGHT  RUBY_DESCRIPTION  RUBY_ENGINE  RUBY_PATCHLEVEL  RUBY_PLATFORM  RUBY_RELEASE_DATA  RUBY_VERSION  RUBY_REVISION", 
            "title": "RUBY_* Constants"
        }, 
        {
            "location": "/objects/#freezing-objects", 
            "text": "Make an object read-only.  irb ( main ): 014 : 0   results   =   [ 10 ,   120 ,   57 ]  =   [ 10 ,   120 ,   57 ]  irb ( main ): 015 : 0   results . freeze  =   [ 10 ,   120 ,   57 ]  irb ( main ): 016 : 0   results . frozen?  =   true  irb ( main ): 017 : 0   results . pop  RuntimeError :   can t   modify   frozen   Array", 
            "title": "Freezing Objects"
        }, 
        {
            "location": "/objects/#object-metadata", 
            "text": "We can check object metadata using methods such as  instance_of?  as follows :    class   Person      end  =   nil     p   =   Person . new  =   # Person:0x007fad4d0032f8    p1   =   Person . new  =   # Person:0x007fad4c20ed78    p . instance_of?   Person", 
            "title": "Object Metadata"
        }, 
        {
            "location": "/objects/#check-instance", 
            "text": "We can use the  is_a?  method to check if an object is an instance of the type as follows :    class   Person      end  =   nil     p   =   Person . new  =   # Person:0x007fad4d0032f8    p . is_a?   Person  =   true", 
            "title": "Check instance"
        }, 
        {
            "location": "/loops_and_iterators/", 
            "text": "Loops and Iterators\n\n\nLoop Method\n\n\nThe \nloop\n constructs loops through a block of code until the condition is false. If you don't put an end condition the loop will run infinitely.\n\n\ni\n \n=\n \n0\n\n\nloop\n \ndo\n\n    \ni\n \n+=\n \n1\n\n    \nputs\n \nHello World\n\n    \nbreak\n \nif\n \ni\n \n==\n \n2\n\n\nend\n\n\nHello\n \nWorld\n\n\nHello\n \nWorld\n\n\n=\n \nnil\n\n\n\n\n\n\nWe can continue with the loop by using the \nnext\n keyword as follows :\n\n\ni\n \n=\n \n0\n\n\nloop\n \ndo\n\n  \ni\n \n+=\n \n1\n\n  \nnext\n \nif\n \ni\n \n==\n \n2\n\n  \nputs\n \ni\n\n  \nbreak\n \nif\n \ni\n \n==\n \n5\n\n\nend\n\n\n\n\n\n\nWhile Loop\n\n\nThe syntax for the \nwhile\n is :\n\n\nwhile\n \n(\nboolean\n \ncondition\n)\n\n\n#code statement\n\n\nend\n\n\n\n\n\n\nThe while will run as long as the condition is true.\n\n\ni\n \n=\n \n0\n\n\nwhile\n \ni\n \n \n5\n\n  \ni\n \n+=\n \n1\n\n  \nputs\n \ni\n\n\nend\n\n\n\n\n\n\nUntil Loop\n\n\nuntil\n is the negated form of the \nwhile\n statement :\n\n\ni\n \n=\n \n0\n\n\nuntil\n \ni\n \n=\n \n5\n\n  \ni\n \n+=\n \n1\n\n  \nputs\n \ni\n\n\nend\n\n\n\n\n\n\nThe same statement with \nwhile\n :\n\n\ni\n \n=\n \n0\n\n\nwhile\n \ni\n \n \n5\n\n  \ni\n \n+=\n \n1\n\n  \nputs\n \ni\n\n\nend\n\n\n\n\n\n\nWhile and Until- Alternative Syntax\n\n\nThe \nwhile\n statement have alternative syntax. We can put the statement at the beginning of the while statement as follows :\n\n\ni\n \n=\n \n0\n\n\nputs\n \n#{\n \ni\n \n+=\n \n1\n \n}\n \nwhile\n \ni\n \n \n5\n\n\n\n\n\n\nuntil alternative syntax\n\n\nThe \nuntil\n also have an alternative syntax as follows :\n\n\ni\n \n=\n \n0\n\n\nputs\n \n#{\n \ni\n \n+=\n \n1\n \n}\n \nuntil\n \ni\n \n==\n \n5\n\n\n\n\n\n\nDo..While Alternative Syntax\n\n\ni\n \n=\n \n0\n\n\nbegin\n\n  \nputs\n \ni\n\n  \ni\n \n+=\n \n1\n\n\nend\n \nwhile\n \ni\n \n \n5\n\n\n\n\n\n\nFor Loop\n\n\nYou can use the traditional \nfor\n loop as in other languages as follows :\n\n\nfor\n \ni\n \nin\n \n1\n..\n5\n\n  \nputs\n \ni\n\n\nend\n\n\n\n\n\n\nAlternative \nfor\n statement\n\n\nAn alternative for the \nfor\n statement is to use the \ntimes\n methods :\n\n\n5\n.\ntimes\n \n{\n|\ni\n|\n \nputs\n \ni\n}\n\n\n\n\n\n\nStep\n\n\nWe can use a step function to choose th upper boundary in what steps we would like to loop as follows :\n\n\n1\n.\nstep\n(\n10\n,\n2\n)\n \n{\n \n|\ni\n|\n \nputs\n \ni\n}\n\n\n\n\n\n\ncase\n statement\n\n\nYou use the case statement instead of using multiple if/elsif/else statements :\n\n\nlang\n \n=\n \nfr\n\n\n\ndog\n \n=\n \ncase\n \nlang\n\n  \nwhen\n \nen\n\n    \ndog\n\n  \nwhen\n \nes\n\n    \nperro\n\n  \nwhen\n \nfr\n\n    \nchien\n\n  \nwhen\n \nde\n\n    \nHund\n\n  \nelse\n \ndog\n\n\nend\n\n\n\n\n\n\nAnd when using symbols :\n\n\nlang\n \n=\n \n:de\n\n\n\ndoggy\n \n=\n \ncase\n \nlang\n\n  \nwhen\n \n:en\n \nthen\n \ndog\n\n  \nwhen\n \n:es\n \nthen\n \nperro\n\n  \nwhen\n \n:fr\n \nthen\n \nchien\n\n  \nwhen\n \n:de\n \nthen\n \nHund\n\n\nend\n\n\nputs\n \ndoggy\n\n\n\n\n\n\nWe can also use ranges with the case statement :\n\n\nscale\n \n=\n \n8\n\n\n\nout\n \n=\n \ncase\n \nscale\n\n  \nwhen\n \n0\n \nthen\n \nlowest\n\n  \nwhen\n \n1\n..\n3\n;\n \nmedium-low\n\n  \nwhen\n \n4\n..\n5\n;\n \nmedium\n\n  \nwhen\n \n6\n..\n7\n;\n \nmedium-high\n\n  \nwhen\n \n8\n..\n9\n;\n \nhigh\n\n  \nwhen\n \n10\n;\n \nhighest\n\n  \nelse\n \noff scale\n\n\nend\n\n\nputs\n \nScale: \n \n+\n \nouts\n\n\n\n\n\n\nThe \n;\n and \nthen\n are used when we put the statement on the same line. We could have written the same as follows :\n\n\nscale\n \n=\n \n8\n\n\n\nout\n \n=\n \ncase\n \nscale\n\n  \nwhen\n \n0\n\n    \nlowest\n\n  \nwhen\n \n1\n..\n3\n\n    \nmedium-low\n\n  \nwhen\n \n4\n..\n5\n\n    \nmedium\n\n  \nwhen\n \n6\n..\n7\n\n    \nmedium-high\n\n  \nwhen\n \n8\n..\n9\n\n    \nhigh\n\n  \nwhen\n \n10\n\n    \nhighest\n\n  \nelse\n\n    \noff scale\n\n\nend\n\n\nputs\n \nScale: \n \n+\n \nout\n\n\n\n\n\n\nWe could also use complicated logical operations in the \nwhen\n clause.", 
            "title": "Loops and Iterators"
        }, 
        {
            "location": "/loops_and_iterators/#loops-and-iterators", 
            "text": "", 
            "title": "Loops and Iterators"
        }, 
        {
            "location": "/loops_and_iterators/#loop-method", 
            "text": "The  loop  constructs loops through a block of code until the condition is false. If you don't put an end condition the loop will run infinitely.  i   =   0  loop   do \n     i   +=   1 \n     puts   Hello World \n     break   if   i   ==   2  end  Hello   World  Hello   World  =   nil   We can continue with the loop by using the  next  keyword as follows :  i   =   0  loop   do \n   i   +=   1 \n   next   if   i   ==   2 \n   puts   i \n   break   if   i   ==   5  end", 
            "title": "Loop Method"
        }, 
        {
            "location": "/loops_and_iterators/#while-loop", 
            "text": "The syntax for the  while  is :  while   ( boolean   condition )  #code statement  end   The while will run as long as the condition is true.  i   =   0  while   i     5 \n   i   +=   1 \n   puts   i  end", 
            "title": "While Loop"
        }, 
        {
            "location": "/loops_and_iterators/#until-loop", 
            "text": "until  is the negated form of the  while  statement :  i   =   0  until   i   =   5 \n   i   +=   1 \n   puts   i  end   The same statement with  while  :  i   =   0  while   i     5 \n   i   +=   1 \n   puts   i  end", 
            "title": "Until Loop"
        }, 
        {
            "location": "/loops_and_iterators/#while-and-until-alternative-syntax", 
            "text": "The  while  statement have alternative syntax. We can put the statement at the beginning of the while statement as follows :  i   =   0  puts   #{   i   +=   1   }   while   i     5", 
            "title": "While and Until- Alternative Syntax"
        }, 
        {
            "location": "/loops_and_iterators/#until-alternative-syntax", 
            "text": "The  until  also have an alternative syntax as follows :  i   =   0  puts   #{   i   +=   1   }   until   i   ==   5", 
            "title": "until alternative syntax"
        }, 
        {
            "location": "/loops_and_iterators/#dowhile-alternative-syntax", 
            "text": "i   =   0  begin \n   puts   i \n   i   +=   1  end   while   i     5", 
            "title": "Do..While Alternative Syntax"
        }, 
        {
            "location": "/loops_and_iterators/#for-loop", 
            "text": "You can use the traditional  for  loop as in other languages as follows :  for   i   in   1 .. 5 \n   puts   i  end", 
            "title": "For Loop"
        }, 
        {
            "location": "/loops_and_iterators/#alternative-for-statement", 
            "text": "An alternative for the  for  statement is to use the  times  methods :  5 . times   { | i |   puts   i }", 
            "title": "Alternative for statement"
        }, 
        {
            "location": "/loops_and_iterators/#step", 
            "text": "We can use a step function to choose th upper boundary in what steps we would like to loop as follows :  1 . step ( 10 , 2 )   {   | i |   puts   i }", 
            "title": "Step"
        }, 
        {
            "location": "/loops_and_iterators/#case-statement", 
            "text": "You use the case statement instead of using multiple if/elsif/else statements :  lang   =   fr  dog   =   case   lang \n   when   en \n     dog \n   when   es \n     perro \n   when   fr \n     chien \n   when   de \n     Hund \n   else   dog  end   And when using symbols :  lang   =   :de  doggy   =   case   lang \n   when   :en   then   dog \n   when   :es   then   perro \n   when   :fr   then   chien \n   when   :de   then   Hund  end  puts   doggy   We can also use ranges with the case statement :  scale   =   8  out   =   case   scale \n   when   0   then   lowest \n   when   1 .. 3 ;   medium-low \n   when   4 .. 5 ;   medium \n   when   6 .. 7 ;   medium-high \n   when   8 .. 9 ;   high \n   when   10 ;   highest \n   else   off scale  end  puts   Scale:    +   outs   The  ;  and  then  are used when we put the statement on the same line. We could have written the same as follows :  scale   =   8  out   =   case   scale \n   when   0 \n     lowest \n   when   1 .. 3 \n     medium-low \n   when   4 .. 5 \n     medium \n   when   6 .. 7 \n     medium-high \n   when   8 .. 9 \n     high \n   when   10 \n     highest \n   else \n     off scale  end  puts   Scale:    +   out   We could also use complicated logical operations in the  when  clause.", 
            "title": "case statement"
        }, 
        {
            "location": "/functions_and_methods/", 
            "text": "Functions and Methods\n\n\nEnables reusable code. DRY(Don\u2019t Repeat Yourself)\n\n\nDefining and Calling Methods\n\n\ndef\n \nhello\n\n  \nputs\n \nHello World\n\n\nend\n\n\n\n\n\n\nCalling Methods\n\n\nhello\n\n\n\n\n\n\nor alternatively with braces\n\n\nhello\n()\n\n\n\n\n\n\nCreating methods with parameters\n\n\ndef\n \nhello\n(\nname\n)\n\n  \nputs\n \nHello \n#{\nname\n}\n\n\nend\n\n\n\n\n\n\nand calling the method as follows :\n\n\nhello\n \nJoseph\n\n\nhello\n(\nJoseph\n)\n\n\n\n\n\n\nMethods with Default Parameters\n\n\ndef\n \nhello\n(\nname\n=\nJohn\n)\n\n  \nputs\n \nHello \n#{\nname\n}\n\n\nend\n\n\n\n\n\n\nConstructor - Initialize Method\n\n\ninitialize\n is a special method in a class. Its called automatically when an object is created.\n\n\nclass\n \nPerson\n\n  \ndef\n \ninitialize\n(\nname\n)\n\n    \nputs\n \nNew person created\n\n  \nend\n\n\nend\n\n\n\n\n\n\nWhen we create the new \nPerson\n object, the \ninitialize\n method is automatically called as demonstrated below :\n\n\nirb\n(\nmain\n):\n075\n:\n0\n \np\n \n=\n \nPerson\n.\nnew\n(\nJoseph\n)\n\n\nNew\n \nperson\n \ncreated\n\n\n\n\n\n\nThe return statement\n\n\nRuby methods do not need to use the \nreturn\n keyword. The last expression evaluated will be returned. If a method does not return anything, it returns \nnil\n.\n\n\n  \ndef\n \nhello\n\n    \nputs\n \n\u201c\nHello\n \nWorld\n\u201d\n \n#Implicit return\n\n  \nend\n\n\n\n\n\n\nWe can also explicitly add a return keyword as follows :\n\n\n  \ndef\n \nadd\n(\nn\n,\n \nn1\n)\n\n    \nreturn\n \nn\n \n+\n \nn1\n\n  \nend\n\n\n\n\n\n\nWe can use it as follows :\n\n\nputs\n \nadd\n(\n1\n,\n2\n)\n\n\n\n\n\n\nReturning multiple values\n\n\nWe can also return multiple values as follows :\n\n\ndef\n \nreturn_multiple\n\n    \nreturn\n \n10\n,\n \n30\n.\n5\n,\n \n50\n\n\nend\n\n\n\n\n\n\nand use the function as follows :\n\n\nn\n,\n \nn1\n,\n \nn3\n \n=\n \nreturn_multiple\n\n\n\n\n\n\nVariable parameters\n\n\nWe can use the hash within the parameter list to pass in variable params. Any older way is to use the \n\\*variable-name\n.\n\n\nUsing the hash :\n\n\ndef\n \nvariable_params\n(\nopts\n \n=\n \n{})\n\n    \n#Do something\n\n\nend\n\n\n\n\n\n\nolder way :\n\n\ndef\n \nvariable_params\n(\n*\nopts\n)\n\n \nputs\n \nopts\n.\ncount\n \nif\n \nopts\n.\ncount\n \n \n0\n\n\nend\n\n\n\n\n\n\nNamed parameters\n\n\nWe can use symbols to name the name of the params as follows :\n\n\ndef\n \nfull_name\n(\nfirst_name\n:\n \nJohn\n,\n \nlast_name\n:\n \nDoe\n)\n\n \nputs\n \n#{\nfirst_name\n}\n \n#{\nlast_name\n}\n\n\nend\n\n\n\n\n\n\nand we can now call the method as follows :\n\n\nfull_name\n(\nfirst_name\n:\n \nJoseph\n,\n \nlast_name\n:\n \nKandi\n)\n\n\n\n\n\n\nClass methods\n\n\nWe can also have methods inside a class. We use the \nself\n keyword when defining methods on the class as follows :\n\n\nclass\n \nPerson\n\n  \ndef\n \nself\n.\ncount\n\n    \nputs\n \nMethod on the Person class\n\n  \nend\n\n\nend\n\n\n\n\n\n\nand we can call the method as follows :\n\n\nPerson\n.\ncount\n\n\n\n\n\n\nSample method signatures with required, optional, and default-valued arguments", 
            "title": "Functions and Methods"
        }, 
        {
            "location": "/functions_and_methods/#functions-and-methods", 
            "text": "Enables reusable code. DRY(Don\u2019t Repeat Yourself)", 
            "title": "Functions and Methods"
        }, 
        {
            "location": "/functions_and_methods/#defining-and-calling-methods", 
            "text": "def   hello \n   puts   Hello World  end", 
            "title": "Defining and Calling Methods"
        }, 
        {
            "location": "/functions_and_methods/#calling-methods", 
            "text": "hello   or alternatively with braces  hello ()", 
            "title": "Calling Methods"
        }, 
        {
            "location": "/functions_and_methods/#creating-methods-with-parameters", 
            "text": "def   hello ( name ) \n   puts   Hello  #{ name }  end   and calling the method as follows :  hello   Joseph  hello ( Joseph )", 
            "title": "Creating methods with parameters"
        }, 
        {
            "location": "/functions_and_methods/#methods-with-default-parameters", 
            "text": "def   hello ( name = John ) \n   puts   Hello  #{ name }  end", 
            "title": "Methods with Default Parameters"
        }, 
        {
            "location": "/functions_and_methods/#constructor-initialize-method", 
            "text": "initialize  is a special method in a class. Its called automatically when an object is created.  class   Person \n   def   initialize ( name ) \n     puts   New person created \n   end  end   When we create the new  Person  object, the  initialize  method is automatically called as demonstrated below :  irb ( main ): 075 : 0   p   =   Person . new ( Joseph )  New   person   created", 
            "title": "Constructor - Initialize Method"
        }, 
        {
            "location": "/functions_and_methods/#the-return-statement", 
            "text": "Ruby methods do not need to use the  return  keyword. The last expression evaluated will be returned. If a method does not return anything, it returns  nil .     def   hello \n     puts   \u201c Hello   World \u201d   #Implicit return \n   end   We can also explicitly add a return keyword as follows :     def   add ( n ,   n1 ) \n     return   n   +   n1 \n   end   We can use it as follows :  puts   add ( 1 , 2 )", 
            "title": "The return statement"
        }, 
        {
            "location": "/functions_and_methods/#returning-multiple-values", 
            "text": "We can also return multiple values as follows :  def   return_multiple \n     return   10 ,   30 . 5 ,   50  end   and use the function as follows :  n ,   n1 ,   n3   =   return_multiple", 
            "title": "Returning multiple values"
        }, 
        {
            "location": "/functions_and_methods/#variable-parameters", 
            "text": "We can use the hash within the parameter list to pass in variable params. Any older way is to use the  \\*variable-name .  Using the hash :  def   variable_params ( opts   =   {}) \n     #Do something  end   older way :  def   variable_params ( * opts ) \n  puts   opts . count   if   opts . count     0  end", 
            "title": "Variable parameters"
        }, 
        {
            "location": "/functions_and_methods/#named-parameters", 
            "text": "We can use symbols to name the name of the params as follows :  def   full_name ( first_name :   John ,   last_name :   Doe ) \n  puts   #{ first_name }   #{ last_name }  end   and we can now call the method as follows :  full_name ( first_name :   Joseph ,   last_name :   Kandi )", 
            "title": "Named parameters"
        }, 
        {
            "location": "/functions_and_methods/#class-methods", 
            "text": "We can also have methods inside a class. We use the  self  keyword when defining methods on the class as follows :  class   Person \n   def   self . count \n     puts   Method on the Person class \n   end  end   and we can call the method as follows :  Person . count", 
            "title": "Class methods"
        }, 
        {
            "location": "/functions_and_methods/#sample-method-signatures-with-required-optional-and-default-valued-arguments", 
            "text": "", 
            "title": "Sample method signatures with required, optional, and default-valued arguments"
        }, 
        {
            "location": "/classes_and_modules/", 
            "text": "Classes\n\n\nWhat Are Classes\n\n\n\n\nClasses are blueprints\n\n\nClasses have properties\n\n\nClasses have methods that define behavior\n\n\n\n\nDefining a class\n\n\nWe define a class using the \nclass\n keyword as follows :\n\n\nclass\n \nCar\n\n\nend\n\n\n\n\n\n\nObjects\n\n\nObjects are created from classes. Objects are created using the \nnew\n method of the class as follows :\n\n\nirb\n(\nmain\n):\n089\n:\n0\n \nc\n \n=\n \nCar\n.\nnew\n\n\n=\n \n#\nCar:0x007f862f1ce280\n\n\n\n\n\n\nThe variable \nc\n is an object of type \nCar\n.\n\n\nGetter methods\n\n\nMethods that return properties of the class are called \ngetters\n. Here is a getter method :\n\n\ndef\n \ncolor\n\n    \n@color\n\n\nend\n\n\n\n\n\n\nSetter method\n\n\nThe setter is the method that assigns a value to a property. You can define the setter method as follows :\n\n\ndef\n \ncolor\n=\n(\ncolor\n)\n\n    \n@color\n \n=\n \ncolor\n\n\nend\n\n\n\n\n\n\nWe can now use the methods to assign and get values of the properties :\n\n\nirb\n(\nmain\n):\n106\n:\n0\n \nc\n \n=\n \nCar\n.\nnew\n\n\n=\n \n#\nCar:0x007f86310614b8\n\n\nirb\n(\nmain\n):\n107\n:\n0\n \nc\n.\ncolor\n \n=\n \nBlue\n\n\n=\n \nBlue\n\n\nirb\n(\nmain\n):\n108\n:\n0\n \nc\n.\ncolor\n\n\n=\n \nBlue\n\n\n\n\n\n\nAccessing properties\n\n\nWe access the properties of the class using the \n.\n operator as above.\n\n\nShorthand getter and setters\n\n\nWe can define the getter and setter using the \nattr_accessor\n keyword. This creates both the getter and accessor methods on the class as follows :\n\n\nclass\n \nCar\n\n    \nattr_accessor\n \n:color\n\n\nend\n\n\n\n\n\n\nWe now use the symbols of the properties instead of string or prepending the @ sign on the property name.\n\n\nAnd we use them in the same way :\n\n\nc\n \n=\n \nCar\n.\nnew\n\n\n\nc\n.\ncolor\n \n=\n \nBlue\n\n\nputs\n \nc\n.\ncolor\n\n\n=\n \nBlue\n\n\n\n\n\n\nConstructors\n\n\nConstructors are methods that are automatically run when we create a new object. They are also used to initialize properties of the class :\n\n\nclass\n \nPerson\n\n  \nattr_accessor\n \n:first_name\n,\n \n:last_name\n\n\n  \ndef\n \ninitialize\n(\nfirst_name\n,\n \nlast_name\n)\n\n    \nself\n.\nfirst_name\n \n=\n \nfirst_name\n\n    \nself\n.\nlast_name\n \n=\n \nlast_name\n\n  \nend\n\n\nend\n\n\n\n\n\n\nPrivate Methods\n\n\nWe can use the \nprivate\n keyword to mark the method as private.\n\n\n  \nprivate\n \ndef\n \nemail_reminders\n()\n\n    \nputs\n \nThis is a private method\n\n  \nend\n\n\n\n\n\n\nWe could also add the \nprivate\n keyword at the end of the class as follows :\n\n\n  \ndef\n \nemail_reminders\n()\n\n    \nputs\n \nThis is a private method\n\n  \nend\n\n\n\nprivate\n \n:email_reminders\n\n\n\n\n\n\nAlso the methods are marked private, you can still call the private methods using the \nsend\n method of the object :\n\n\np\n \n=\n \nPerson\n.\nnew\n\n\np\n.\nsend\n \n:email_reminders\n \n# assuming the method is defined on Person class\n\n\n\n\n\n\nInstance variables\n\n\nInstance variables are defined using a single \n@\n. By defining the accessor methods we automatically get an instance variable. We could have modified the constructor as follows :\n\n\nclass\n \nPerson\n\n  \nattr_accessor\n \n:first_name\n,\n \n:last_name\n\n\n  \ndef\n \ninitialize\n(\nfirst_name\n,\n \nlast_name\n)\n\n    \n@first_name\n \n=\n \nfirst_name\n\n    \n@last_name\n \n=\n \nlast_name\n\n  \nend\n\n\nend\n\n\n\n\n\n\nClass variables\n\n\nClass variables are defined using \n@@\n signs. The variables belong to the class not an instance of the object.\n\n\nclass\n \nPerson\n\n\n \n@@total\n \n=\n \n0\n \n# should be initialized before use\n\n\n  \ndef\n \ninitialize\n(\n \nfname\n,\n \nlname\n \n)\n\n    \n@fname\n \n=\n \nfname\n\n    \n@lname\n \n=\n \nlname\n\n    \n@@total\n \n+=\n \n1\n\n  \nend\n\n\n  \ndef\n \nself\n.\ntotal\n\n    \nTotal person objects created \n \n+\n \n@@total\n.\nto_s\n\n  \nend\n\n\nend\n\n\n\n\n\n\nWe can now create objects of type Person and then call the \ntotal\n method. The method \ntotal\n belongs to the class not a specific object because we prefixed it with a \nself\n keyword.\n\n\np\n \n=\n \nPerson\n.\nnew\n(\nJ\n,\n \nK\n)\n\n\np2\n \n=\n \nPerson\n.\nnew\n(\nK\n,\n \nJ\n)\n\n\nputs\n \nPerson\n.\ntotal\n\n\n\n\n\n\nClass methods\n\n\nWe can define class methods by using the \nself\n keyword or we can use the class name. In the above, \ntotal\n is a class method.\n\n\n  \ndef\n \nself\n.\ntotal\n\n    \nTotal person objects created \n \n+\n \n@@total\n.\nto_s\n\n  \nend\n\n\n\n\n\n\nWe can also define a class method as follows :\n\n\nclass\n \nPerson\n\n\n \n@@total\n \n=\n \n0\n \n# should be initialized before use\n\n\n  \ndef\n \ninitialize\n(\n \nfname\n,\n \nlname\n \n)\n\n    \n@fname\n \n=\n \nfname\n\n    \n@lname\n \n=\n \nlname\n\n    \n@@total\n \n+=\n \n1\n\n  \nend\n\n\n  \ndef\n \nPerson\n.\ntotal\n\n    \nTotal person objects created \n \n+\n \n@@total\n.\nto_s\n\n  \nend\n\n\nend\n\n\n\n\n\n\nInheritance\n\n\nIn Ruby we use the \n for inheritance. When a child class inherits from the parent class, it automatically inherits the methods and properties from the parent class :\n\n\nclass\n \nName\n\n \nattr_accessor\n \n:given_name\n,\n \n:family_name\n\n\nend\n\n\n\nclass\n \nAddress\n \n \nName\n\n \nattr_accessor\n \n:street\n,\n \n:city\n,\n \n:state\n,\n \n:country\n\n\nend\n\n\n\na\n \n=\n \nAddress\n.\nnew\n\n\nputs\n \na\n.\nrespond_to?\n(\n:given_name\n)\n \n# =\n true\n\n\n\n\n\n\nNested Classes\n\n\nIn Ruby, it\u2019s possible to define classes within other classes. These are called nested classes. Nested classes are useful when a class depends on other classes, but those classes aren\u2019t necessarily useful anywhere else. They can also be useful when you want to separate classes into groups of classes rather than keep them all distinct. Here\u2019s an example:\n\n\nclass\n \nDrawing\n\n  \nclass\n \nLine\n\n  \nend\n\n\n  \nclass\n \nCircle\n\n  \nend\n\n\nend\n\n\n\n\n\n\nYou can now create a new Line as follows :\n\n\nline\n \n=\n \nDrawing\n::\nLine\n.\nnew\n\n\n\n\n\n\nInstead of using nested class we could also define a module and next the classes inside :\n\n\nmodule\n \nDrawing\n\n  \nclass\n \nLine\n\n  \nend\n\n\n  \nclass\n \nCircle\n\n  \nend\n\n\nend\n\n\n\n\n\n\nand we will create the Line the same way as before :\n\n\nline\n \n=\n \nDrawing\n::\nLine\n.\nnew", 
            "title": "Classes and Modules"
        }, 
        {
            "location": "/classes_and_modules/#classes", 
            "text": "", 
            "title": "Classes"
        }, 
        {
            "location": "/classes_and_modules/#what-are-classes", 
            "text": "Classes are blueprints  Classes have properties  Classes have methods that define behavior", 
            "title": "What Are Classes"
        }, 
        {
            "location": "/classes_and_modules/#defining-a-class", 
            "text": "We define a class using the  class  keyword as follows :  class   Car  end", 
            "title": "Defining a class"
        }, 
        {
            "location": "/classes_and_modules/#objects", 
            "text": "Objects are created from classes. Objects are created using the  new  method of the class as follows :  irb ( main ): 089 : 0   c   =   Car . new  =   # Car:0x007f862f1ce280   The variable  c  is an object of type  Car .", 
            "title": "Objects"
        }, 
        {
            "location": "/classes_and_modules/#getter-methods", 
            "text": "Methods that return properties of the class are called  getters . Here is a getter method :  def   color \n     @color  end", 
            "title": "Getter methods"
        }, 
        {
            "location": "/classes_and_modules/#setter-method", 
            "text": "The setter is the method that assigns a value to a property. You can define the setter method as follows :  def   color = ( color ) \n     @color   =   color  end   We can now use the methods to assign and get values of the properties :  irb ( main ): 106 : 0   c   =   Car . new  =   # Car:0x007f86310614b8  irb ( main ): 107 : 0   c . color   =   Blue  =   Blue  irb ( main ): 108 : 0   c . color  =   Blue", 
            "title": "Setter method"
        }, 
        {
            "location": "/classes_and_modules/#accessing-properties", 
            "text": "We access the properties of the class using the  .  operator as above.", 
            "title": "Accessing properties"
        }, 
        {
            "location": "/classes_and_modules/#shorthand-getter-and-setters", 
            "text": "We can define the getter and setter using the  attr_accessor  keyword. This creates both the getter and accessor methods on the class as follows :  class   Car \n     attr_accessor   :color  end   We now use the symbols of the properties instead of string or prepending the @ sign on the property name.  And we use them in the same way :  c   =   Car . new  c . color   =   Blue  puts   c . color  =   Blue", 
            "title": "Shorthand getter and setters"
        }, 
        {
            "location": "/classes_and_modules/#constructors", 
            "text": "Constructors are methods that are automatically run when we create a new object. They are also used to initialize properties of the class :  class   Person \n   attr_accessor   :first_name ,   :last_name \n\n   def   initialize ( first_name ,   last_name ) \n     self . first_name   =   first_name \n     self . last_name   =   last_name \n   end  end", 
            "title": "Constructors"
        }, 
        {
            "location": "/classes_and_modules/#private-methods", 
            "text": "We can use the  private  keyword to mark the method as private.     private   def   email_reminders () \n     puts   This is a private method \n   end   We could also add the  private  keyword at the end of the class as follows :     def   email_reminders () \n     puts   This is a private method \n   end  private   :email_reminders   Also the methods are marked private, you can still call the private methods using the  send  method of the object :  p   =   Person . new  p . send   :email_reminders   # assuming the method is defined on Person class", 
            "title": "Private Methods"
        }, 
        {
            "location": "/classes_and_modules/#instance-variables", 
            "text": "Instance variables are defined using a single  @ . By defining the accessor methods we automatically get an instance variable. We could have modified the constructor as follows :  class   Person \n   attr_accessor   :first_name ,   :last_name \n\n   def   initialize ( first_name ,   last_name ) \n     @first_name   =   first_name \n     @last_name   =   last_name \n   end  end", 
            "title": "Instance variables"
        }, 
        {
            "location": "/classes_and_modules/#class-variables", 
            "text": "Class variables are defined using  @@  signs. The variables belong to the class not an instance of the object.  class   Person \n\n  @@total   =   0   # should be initialized before use \n\n   def   initialize (   fname ,   lname   ) \n     @fname   =   fname \n     @lname   =   lname \n     @@total   +=   1 \n   end \n\n   def   self . total \n     Total person objects created    +   @@total . to_s \n   end  end   We can now create objects of type Person and then call the  total  method. The method  total  belongs to the class not a specific object because we prefixed it with a  self  keyword.  p   =   Person . new ( J ,   K )  p2   =   Person . new ( K ,   J )  puts   Person . total", 
            "title": "Class variables"
        }, 
        {
            "location": "/classes_and_modules/#class-methods", 
            "text": "We can define class methods by using the  self  keyword or we can use the class name. In the above,  total  is a class method.     def   self . total \n     Total person objects created    +   @@total . to_s \n   end   We can also define a class method as follows :  class   Person \n\n  @@total   =   0   # should be initialized before use \n\n   def   initialize (   fname ,   lname   ) \n     @fname   =   fname \n     @lname   =   lname \n     @@total   +=   1 \n   end \n\n   def   Person . total \n     Total person objects created    +   @@total . to_s \n   end  end", 
            "title": "Class methods"
        }, 
        {
            "location": "/classes_and_modules/#inheritance", 
            "text": "In Ruby we use the   for inheritance. When a child class inherits from the parent class, it automatically inherits the methods and properties from the parent class :  class   Name \n  attr_accessor   :given_name ,   :family_name  end  class   Address     Name \n  attr_accessor   :street ,   :city ,   :state ,   :country  end  a   =   Address . new  puts   a . respond_to? ( :given_name )   # =  true", 
            "title": "Inheritance"
        }, 
        {
            "location": "/classes_and_modules/#nested-classes", 
            "text": "In Ruby, it\u2019s possible to define classes within other classes. These are called nested classes. Nested classes are useful when a class depends on other classes, but those classes aren\u2019t necessarily useful anywhere else. They can also be useful when you want to separate classes into groups of classes rather than keep them all distinct. Here\u2019s an example:  class   Drawing \n   class   Line \n   end \n\n   class   Circle \n   end  end   You can now create a new Line as follows :  line   =   Drawing :: Line . new   Instead of using nested class we could also define a module and next the classes inside :  module   Drawing \n   class   Line \n   end \n\n   class   Circle \n   end  end   and we will create the Line the same way as before :  line   =   Drawing :: Line . new", 
            "title": "Nested Classes"
        }, 
        {
            "location": "/blocks_procs_and_lambdas/", 
            "text": "Block, Procs and Lambdas\n\n\nBlocks are methods without names. They are usually used together with iterators. The blocks starts with a \ndo\n and finish with an \nend\n. Alternatively blocks use curl braces \n{}\n.\n\n\n[\n1\n,\n2\n,\n3\n,\n4\n].\neach\n \ndo\n \n|\nn\n|\n\n    \nputs\n \nn\n\n\nend\n\n\n\n\n\n\nusing curly braces for blocks :\n\n\n[\n1\n,\n2\n,\n3\n,\n4\n].\neach\n \n{\n \n|\nn\n|\n\n    \nputs\n \nn\n\n\n}\n\n\n\n\n\n\nYield keyword\n\n\nPass control between a method and block and back as required. The \nyield\n  executes the block associated with the method.\n\n\nIf we run the we call a method without a block an error will be thrown :\n\n\ndef\n \nno_block\n\n \nyield\n\n\nend\n\n\n:no_block\n\n\n\n\n\n\nand calling the method without a block yield an error :\n\n\nno_block\n\n\nLocalJumpError\n:\n \nno\n \nblock\n \ngiven\n \n(\nyield\n)\n\n    \nfrom\n \n(\nirb\n):\n2\n:in\n \n`no_block\n\n\n\n\n\n\nDefine another method and call the method with a block :\n\n\ndef\n \nblock_demo\n\n\nyield\n\n\nend\n\n\n\n\n\n\nAnd calling the method with a block yields the right result :\n\n\nblock_demo\n \n{\n \nputs\n \nHello World\n \n}\n\n\n=\n \nHello\n \nWorld\n\n\n\n\n\n\nLets run some code in the block and in the method as follows :\n\n\n \ndef\n \nhello\n\n   \nputs\n \nIn the Method\n\n   \nyield\n\n   \nputs\n \nBack in the method\n\n   \nyield\n\n \nend\n\n\n\n\n\n\nand using it as follows :\n\n\nhello\n \n{\n \nputs\n \nYou are in the block\n \n}\n\n\n\n\n\n\nWe can also access parameters from the block as follows :\n\n\ndef\n \nhello\n\n  \nputs\n \nHello Person\n\n  \nyield\n \nJoe\n\n  \nputs\n \nHello Person\n\n  \nyield\n \nPeter\n\n\nend\n\n\n\n\n\n\nand calling as follows :\n\n\nhello\n \n{\n|\nname\n|\n \nputs\n \nHello \n#{\nname\n}\n}\n\n\n\n\n\n\nWe can also check if the block is provided or not as follows :\n\n\ndef\n \nhello\n\n  \nputs\n \nHello Person\n\n  \nyield\n \nJoe\n,\n \nBloggs\n \nif\n \nblock_given?\n\n  \nputs\n \nHello Person\n\n  \nyield\n \nPeter\n,\n \nPan\n \nif\n \nblock_given?\n\n\nend\n\n\n\n\n\n\nand calling the method as follows :\n\n\nhello\n \n{\n|\nfirst_name\n,\n \nlast_name\n|\n \nputs\n \nHello \n#{\nfirst_name\n}\n \n#{\nlast_name\n}\n}\n\n\n\n\n\n\nPassing blocks into methods\n\n\nBlocks can be used as parameters into a method. The parameter should be preceded with \n character as follows :\n\n\ndef\n \nmy_iterator\n(\nx\n,\n \nb\n)\n\n  \ni\n \n=\n \n0\n\n  \nwhile\n(\ni\n \n \nx\n)\n\n    \nb\n.\ncall\n(\ni\n*\nx\n)\n \n# Use call with block parameter\n\n    \ni\n \n+=\n \n1\n\n  \nend\n\n\nend\n\n\n\n\n\n\nWe can invoke the block code by using the method \ncall\n on the block variable. We can use use the block as follows :\n\n\nmy_iterator\n(\n5\n){\n|\nx\n|\n \np\n \nx\n}\n\n\n\n\n\n\nNote that the parameter needs to be the last argument in the method.\n\n\nProcs\n\n\nA block that can be stored to a variable and executed\n\n\ntimes_two\n \n=\n \nProc\n.\nnew\n \ndo\n \n|\nn\n|\n\n  \nn\n \n*\n \n2\n\n\nend\n\n\n\n\n\n\nand using it :\n\n\nputs\n \n[\n1\n,\n2\n,\n \n3\n].\ncollect\n(\ntimes_two\n)\n\n\n# The \n convert the Proc to a block\n\n\n\n\n\n\nWe can also call the Proc directly using the \ncall\n method as follows :\n\n\ntimes_two\n.\ncall\n \n4\n\n\n\n\n\n\nLambdas\n\n\nSame as Procs but uses alternative syntax\n\n\ndef\n \nlambda_test\n(\nmy_lambda\n)\n\n  \nputs\n \nMethod here\n\n  \nmy_lambda\n.\ncall\n\n\nend\n\n\n\n\n\n\nand using it :\n\n\nlambda_test\n(\nlambda\n \n{\nputs\n \nLambda here\n})", 
            "title": "Blocks, Procs and Lambdas"
        }, 
        {
            "location": "/blocks_procs_and_lambdas/#block-procs-and-lambdas", 
            "text": "Blocks are methods without names. They are usually used together with iterators. The blocks starts with a  do  and finish with an  end . Alternatively blocks use curl braces  {} .  [ 1 , 2 , 3 , 4 ]. each   do   | n | \n     puts   n  end   using curly braces for blocks :  [ 1 , 2 , 3 , 4 ]. each   {   | n | \n     puts   n  }", 
            "title": "Block, Procs and Lambdas"
        }, 
        {
            "location": "/blocks_procs_and_lambdas/#yield-keyword", 
            "text": "Pass control between a method and block and back as required. The  yield   executes the block associated with the method.  If we run the we call a method without a block an error will be thrown :  def   no_block \n  yield  end  :no_block   and calling the method without a block yield an error :  no_block  LocalJumpError :   no   block   given   ( yield ) \n     from   ( irb ): 2 :in   `no_block   Define another method and call the method with a block :  def   block_demo  yield  end   And calling the method with a block yields the right result :  block_demo   {   puts   Hello World   }  =   Hello   World   Lets run some code in the block and in the method as follows :    def   hello \n    puts   In the Method \n    yield \n    puts   Back in the method \n    yield \n  end   and using it as follows :  hello   {   puts   You are in the block   }   We can also access parameters from the block as follows :  def   hello \n   puts   Hello Person \n   yield   Joe \n   puts   Hello Person \n   yield   Peter  end   and calling as follows :  hello   { | name |   puts   Hello  #{ name } }   We can also check if the block is provided or not as follows :  def   hello \n   puts   Hello Person \n   yield   Joe ,   Bloggs   if   block_given? \n   puts   Hello Person \n   yield   Peter ,   Pan   if   block_given?  end   and calling the method as follows :  hello   { | first_name ,   last_name |   puts   Hello  #{ first_name }   #{ last_name } }", 
            "title": "Yield keyword"
        }, 
        {
            "location": "/blocks_procs_and_lambdas/#passing-blocks-into-methods", 
            "text": "Blocks can be used as parameters into a method. The parameter should be preceded with   character as follows :  def   my_iterator ( x ,   b ) \n   i   =   0 \n   while ( i     x ) \n     b . call ( i * x )   # Use call with block parameter \n     i   +=   1 \n   end  end   We can invoke the block code by using the method  call  on the block variable. We can use use the block as follows :  my_iterator ( 5 ){ | x |   p   x }   Note that the parameter needs to be the last argument in the method.", 
            "title": "Passing blocks into methods"
        }, 
        {
            "location": "/blocks_procs_and_lambdas/#procs", 
            "text": "A block that can be stored to a variable and executed  times_two   =   Proc . new   do   | n | \n   n   *   2  end   and using it :  puts   [ 1 , 2 ,   3 ]. collect ( times_two )  # The   convert the Proc to a block   We can also call the Proc directly using the  call  method as follows :  times_two . call   4", 
            "title": "Procs"
        }, 
        {
            "location": "/blocks_procs_and_lambdas/#lambdas", 
            "text": "Same as Procs but uses alternative syntax  def   lambda_test ( my_lambda ) \n   puts   Method here \n   my_lambda . call  end   and using it :  lambda_test ( lambda   { puts   Lambda here })", 
            "title": "Lambdas"
        }, 
        {
            "location": "/errors_and_exceptions/", 
            "text": "Catching Errors and Exceptions\n\n\nErrors are child classes of \nStandardError\n class. To catch errors we surround the offending code in \nbegin\n and \nrescue\n block as follows :\n\n\nbegin\n\n  \nputs\n \n1\n \n/\n \n0\n \n# code that can generate an error\n\n\nrescue\n\n  \nputs\n \nCant divide by Zero\n \n# catch the error here\n\n\nend\n\n\n\n\n\n\nCatching specific exceptions\n\n\nWe can catch specifying their name in the rescue bloc as follows :\n\n\nbegin\n\n  \nfile\n \n=\n \nFile\n.\nopen\n \nnginx.conf\n\n  \nputs\n \n1\n \n/\n \n0\n\n\nrescue\n \nStandardError\n \n=\n \nerror\n \n# Catch the StandardError\n\n  \nputs\n \nCant divide by Zero\n\n  \nputs\n \nError was \n#{\nerror\n.\nclass\n}\n\n\nend\n\n\n\n\n\n\nWe can catch more errors in a block, the specific errors first and general at the end as follows :\n\n\nbegin\n\n  \nfile\n \n=\n \nFile\n.\nopen\n \nnginx.conf\n\n  \nputs\n \n1\n \n/\n \n0\n\n\nrescue\n \nZeroDivisionError\n \n=\n \nerror\n \n# more specific\n\n  \nputs\n \nCant divide by Zero\n\n  \nputs\n \nError \n#{\nerror\n.\nto_s\n}\n\n\nrescue\n \nErrno\n::\nENOENT\n \n=\n \nerror\n \n# general\n\n  \nputs\n \nSorry, we can\nt open the file specified\n\n  \nputs\n \nError: \n#{\nerror\n.\nto_s\n}\n\n\nend\n\n\n\n\n\n\nRaising Exceptions\n\n\nWe raise exceptions by using the \nraise\n keyword as follows :\n\n\nbegin\n\n  \nraise\n \nTesting an error\n \n# raise and exception\n\n  \nputs\n \n\u201c\nShouldn\nt\n \nexecute\n \nthis\n \ncode\n\n\nrescue Exception =\n error\n\n\n  puts \nRescued\n \nan\n \nexception\n:\n \n#{error.inspect}\n\n\nend\n\n\n\n\n\n\nCreating Our Own Exceptions\n\n\nWe can create custom exceptions by extending from the \nStandardError\n class as follows :\n\n\nclass\n \nMyException\n \n \nStandardError\n\n\n\nend\n\n\n\n\n\n\nEnsure block\n\n\nWe can have a block of code that always runs by using the \nensure\n keyword as follows : \n\n\nbegin\n\n  \nraise\n \nTesting an error\n \n# raise the error\n\n  \nputs\n \nShouldnt execute this code\n\n\nrescue\n \nException\n \n=\n \nerror\n \n# catch the error\n\n  \nputs\n \nRescued an exception: \n#{\nerror\n.\ninspect\n}\n\n\nensure\n\n  \nputs\n \nThis code will always run\n \n# this code always runs\n\n\nend", 
            "title": "Errors and Exceptions"
        }, 
        {
            "location": "/errors_and_exceptions/#catching-errors-and-exceptions", 
            "text": "Errors are child classes of  StandardError  class. To catch errors we surround the offending code in  begin  and  rescue  block as follows :  begin \n   puts   1   /   0   # code that can generate an error  rescue \n   puts   Cant divide by Zero   # catch the error here  end", 
            "title": "Catching Errors and Exceptions"
        }, 
        {
            "location": "/errors_and_exceptions/#catching-specific-exceptions", 
            "text": "We can catch specifying their name in the rescue bloc as follows :  begin \n   file   =   File . open   nginx.conf \n   puts   1   /   0  rescue   StandardError   =   error   # Catch the StandardError \n   puts   Cant divide by Zero \n   puts   Error was  #{ error . class }  end   We can catch more errors in a block, the specific errors first and general at the end as follows :  begin \n   file   =   File . open   nginx.conf \n   puts   1   /   0  rescue   ZeroDivisionError   =   error   # more specific \n   puts   Cant divide by Zero \n   puts   Error  #{ error . to_s }  rescue   Errno :: ENOENT   =   error   # general \n   puts   Sorry, we can t open the file specified \n   puts   Error:  #{ error . to_s }  end", 
            "title": "Catching specific exceptions"
        }, 
        {
            "location": "/errors_and_exceptions/#raising-exceptions", 
            "text": "We raise exceptions by using the  raise  keyword as follows :  begin \n   raise   Testing an error   # raise and exception \n   puts   \u201c Shouldn t   execute   this   code  rescue Exception =  error    puts  Rescued   an   exception :   #{error.inspect}  end", 
            "title": "Raising Exceptions"
        }, 
        {
            "location": "/errors_and_exceptions/#creating-our-own-exceptions", 
            "text": "We can create custom exceptions by extending from the  StandardError  class as follows :  class   MyException     StandardError  end", 
            "title": "Creating Our Own Exceptions"
        }, 
        {
            "location": "/errors_and_exceptions/#ensure-block", 
            "text": "We can have a block of code that always runs by using the  ensure  keyword as follows :   begin \n   raise   Testing an error   # raise the error \n   puts   Shouldnt execute this code  rescue   Exception   =   error   # catch the error \n   puts   Rescued an exception:  #{ error . inspect }  ensure \n   puts   This code will always run   # this code always runs  end", 
            "title": "Ensure block"
        }, 
        {
            "location": "/input_and_output/", 
            "text": "File Input/Output\n\n\nWe can read from the standard input using the \ngets\n method as follows :\n\n\nname\n \n=\n \ngets\n\n\nJoseph\n\n\n=\n \nJoseph\n\\n\n\n\n\n\n\n\nTo remove the extra newline at the end, we use the \nchomp\n methods as follows :\n\n\n2\n.\n2\n.\n5\n \n:\n200\n \n \nname\n \n=\n \ngets\n.\nchomp\n\n\nJoseph\n\n \n=\n \nJoseph\n\n\n\n\n\n\nManipulating files\n\n\nWe can work with files on the filesystem using the \nFile\n class. \nFile.open\n opens a files, and we can specify the mode in which we need to open the file.\n\n\n \nfile\n \n=\n \nFile\n.\nopen\n(\npgadmin.log\n,\n \nr\n)\n \n# open the file for reading\n\n\n=\n \n#\nFile:pgadmin.log\n\n\n \nfile\n.\ninspect\n\n\n=\n \n#\nFile:pgadmin.log\n\n\n \nfile\n.\nread\n\n\n \nfile\n.\nclose\n\n\n\n\n\n\nOpening a file for writing\n\n\nTo open the file for writing we specify the \nw\n mode as follows :\n\n\n \nfile\n \n=\n \nFile\n.\nopen\n(\ntest.txt\n,\n \nw\n)\n\n\n=\n \n#\nFile:test.txt\n\n\n \nfile\n.\nputs\n \nHello Joseph\n\n\n=\n \nnil\n\n\n \nfile\n.\nclose\n\n\n=\n \nnil\n\n\n\n\n\n\nOpen file for appending\n\n\nWe use the \na\n character to open the file for appending :\n\n\n \nfile\n \n=\n \nFile\n.\nopen\n(\ntest.txt\n,\n \na\n)\n\n\n=\n \n#\nFile:test.txt\n\n\n \nfile\n.\nputs\n \nHello there\n\n\n=\n \nnil\n\n\n \nfile\n.\nclose\n\n\n=\n \nnil\n\n\n\n\n\n\nNetwork Input/Output\n\n\nWe can perform low level networking using the \nBasicSocket\n, \nUDPScket\n and \nTCPSocket\n classes.\n\n\nHigher Level Network Input/Output\n\n\nWhen working with HTTP we can use use libraries to interact with the protocol. We need to require the library \nnet/http\n as follows :\n\n\nrequire\n \nnet/http\n\n\nconn\n \n=\n \nNet\n::\nHTTP\n.\nget_response\n(\nwww.peruzal.com\n,\n \n/\n)\n\n\n=\n \n#\nNet::HTTPOK 200 OK readbody=true\n\n\nconn\n.\nbody\n.\nscan\n(\n/\nimg src=\n(.*?)\n/\n)\n \n{\n|\nimg\n|\n \nputs\n \nimg\n}", 
            "title": "Input/Output"
        }, 
        {
            "location": "/input_and_output/#file-inputoutput", 
            "text": "We can read from the standard input using the  gets  method as follows :  name   =   gets  Joseph  =   Joseph \\n   To remove the extra newline at the end, we use the  chomp  methods as follows :  2 . 2 . 5   : 200     name   =   gets . chomp  Joseph \n  =   Joseph", 
            "title": "File Input/Output"
        }, 
        {
            "location": "/input_and_output/#manipulating-files", 
            "text": "We can work with files on the filesystem using the  File  class.  File.open  opens a files, and we can specify the mode in which we need to open the file.    file   =   File . open ( pgadmin.log ,   r )   # open the file for reading  =   # File:pgadmin.log    file . inspect  =   # File:pgadmin.log    file . read    file . close", 
            "title": "Manipulating files"
        }, 
        {
            "location": "/input_and_output/#opening-a-file-for-writing", 
            "text": "To open the file for writing we specify the  w  mode as follows :    file   =   File . open ( test.txt ,   w )  =   # File:test.txt    file . puts   Hello Joseph  =   nil    file . close  =   nil", 
            "title": "Opening a file for writing"
        }, 
        {
            "location": "/input_and_output/#open-file-for-appending", 
            "text": "We use the  a  character to open the file for appending :    file   =   File . open ( test.txt ,   a )  =   # File:test.txt    file . puts   Hello there  =   nil    file . close  =   nil", 
            "title": "Open file for appending"
        }, 
        {
            "location": "/input_and_output/#network-inputoutput", 
            "text": "We can perform low level networking using the  BasicSocket ,  UDPScket  and  TCPSocket  classes.", 
            "title": "Network Input/Output"
        }, 
        {
            "location": "/input_and_output/#higher-level-network-inputoutput", 
            "text": "When working with HTTP we can use use libraries to interact with the protocol. We need to require the library  net/http  as follows :  require   net/http  conn   =   Net :: HTTP . get_response ( www.peruzal.com ,   / )  =   # Net::HTTPOK 200 OK readbody=true  conn . body . scan ( / img src= (.*?) / )   { | img |   puts   img }", 
            "title": "Higher Level Network Input/Output"
        }, 
        {
            "location": "/files_and_directories/", 
            "text": "", 
            "title": "Files and Directories"
        }, 
        {
            "location": "/sinatra/", 
            "text": "Sinatra\n\n\nSinatra is simple opinionated Ruby web framework.\n\n\nInstalling the Gem\n\n\nTo start working with Sinatra you need to install the gem.\n\n\ngem\n \ninstall\n \nsinatra\n\n\n\n\n\n\nRunning A Simple Server\n\n\nCreating A Form\n\n\nParsing Query Arguments", 
            "title": "Sinatra"
        }, 
        {
            "location": "/sinatra/#sinatra", 
            "text": "Sinatra is simple opinionated Ruby web framework.", 
            "title": "Sinatra"
        }, 
        {
            "location": "/sinatra/#installing-the-gem", 
            "text": "To start working with Sinatra you need to install the gem.  gem   install   sinatra", 
            "title": "Installing the Gem"
        }, 
        {
            "location": "/sinatra/#running-a-simple-server", 
            "text": "", 
            "title": "Running A Simple Server"
        }, 
        {
            "location": "/sinatra/#creating-a-form", 
            "text": "", 
            "title": "Creating A Form"
        }, 
        {
            "location": "/sinatra/#parsing-query-arguments", 
            "text": "", 
            "title": "Parsing Query Arguments"
        }, 
        {
            "location": "/rails/", 
            "text": "Ruby on Rails\n\n\nInstalling Rails\n\n\nRunning The Server\n\n\nWhat Is MVC\n\n\nGenerating Controllers and Models", 
            "title": "Rails"
        }, 
        {
            "location": "/rails/#ruby-on-rails", 
            "text": "", 
            "title": "Ruby on Rails"
        }, 
        {
            "location": "/rails/#installing-rails", 
            "text": "", 
            "title": "Installing Rails"
        }, 
        {
            "location": "/rails/#running-the-server", 
            "text": "", 
            "title": "Running The Server"
        }, 
        {
            "location": "/rails/#what-is-mvc", 
            "text": "", 
            "title": "What Is MVC"
        }, 
        {
            "location": "/rails/#generating-controllers-and-models", 
            "text": "", 
            "title": "Generating Controllers and Models"
        }, 
        {
            "location": "/testing_with_rspec/", 
            "text": "Testing with RSpec\n\n\nRSpec is used for unit testing in Ruby.\n\n\nInstall RSpec\n\n\nRSpec comes as a set of gems, install the gem :\n\n\ngem\n \ninstall\n \nrspec\n\n\n\n\n\n\nStart using RSpec\n\n\nYou can using RSpec by initializing it as follows :\n\n\nrspec\n \n--\ninit\n\n\n\n\n\n\nRun this from the same folder with your code. Now we can run the \nrspec\n command line tool.\n\n\nFirst Testing\n\n\nRSpec uses the \ndescribe\n and \nit\n keywords when writing specs.\n\n\nRSpec\n.\ndescribe\n \nfirst test\n \ndo\n\n \nit\n \npasses\n \ndo\n\n    \ntrue\n\n \nend\n\n\nend", 
            "title": "Testing with RSpec"
        }, 
        {
            "location": "/testing_with_rspec/#testing-with-rspec", 
            "text": "RSpec is used for unit testing in Ruby.", 
            "title": "Testing with RSpec"
        }, 
        {
            "location": "/testing_with_rspec/#install-rspec", 
            "text": "RSpec comes as a set of gems, install the gem :  gem   install   rspec", 
            "title": "Install RSpec"
        }, 
        {
            "location": "/testing_with_rspec/#start-using-rspec", 
            "text": "You can using RSpec by initializing it as follows :  rspec   -- init   Run this from the same folder with your code. Now we can run the  rspec  command line tool.", 
            "title": "Start using RSpec"
        }, 
        {
            "location": "/testing_with_rspec/#first-testing", 
            "text": "RSpec uses the  describe  and  it  keywords when writing specs.  RSpec . describe   first test   do \n  it   passes   do \n     true \n  end  end", 
            "title": "First Testing"
        }
    ]
}