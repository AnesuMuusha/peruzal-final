<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>SQL Performance Analysis - SQL Server Performance and Tuning</title>
    <meta name="generator" content="Hugo 0.18.1" />

    
    <meta name="description" content="SQL Server Performance and Tuning">
    
    <link rel="canonical" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/sql-performance-analysis/">
    
    <meta name="author" content="Peruzal">
    

    <meta property="og:url" content="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/sql-performance-analysis/">
    <meta property="og:title" content="SQL Server Performance and Tuning">
    <meta property="og:image" content="http://guides.peruzal.com/images/logo.png">
    <meta name="apple-mobile-web-app-title" content="SQL Server Performance and Tuning">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/fonts/icon.eot');
        src: url('http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/fonts/icon.eot')
               format('embedded-opentype'),
             url('http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/fonts/icon.woff')
               format('woff'),
             url('http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/fonts/icon.ttf')
               format('truetype'),
             url('http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/stylesheets/application.css">
    <link rel="stylesheet" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/stylesheets/highlight/highlight.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/github-gist.min.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-deep-orange palette-accent-light-blue">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        SQL Performance Analysis
      </div>
    </div>

    
    <div class="button button-twitter" role="button" aria-label="Twitter">
       <a href="https://twitter.com/peruzal" title="@peruzal on Twitter" target="_blank" class="toggle-button icon icon-twitter"></a>
    </div>
    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/peruzal" title="@peruzal on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/logo.png">
        </div>
      
      <div class="name">
        <strong>SQL Server Performance and Tuning <span class="version">1.0.0</span></strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="Introduction" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/">
	
	Introduction
</a>



  
</li>



<li>
  
    



<a  title="Performance Tuning Overview" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/performance-tuning-overview/">
	
	Performance Tuning Overview
</a>



  
</li>



<li>
  
    



<a class="current" title="SQL Performance Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/sql-performance-analysis/">
	
	SQL Performance Analysis
</a>


<ul id="scrollspy">
</ul>


  
</li>



<li>
  
    



<a  title="SQL Query Performance Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/sql-query-performance-analysis/">
	
	SQL Query Performance Analysis
</a>



  
</li>



<li>
  
    



<a  title="Index Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/index-analysis/">
	
	Index Analysis
</a>



  
</li>



<li>
  
    



<a  title="Database Tuning Advisor" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/database-tuning-advisor/">
	
	Database Tuning Advisor
</a>



  
</li>



<li>
  
    



<a  title="Boomark Lookup Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/bookmark-lookup-analysis/">
	
	Boomark Lookup Analysis
</a>



  
</li>



<li>
  
    



<a  title="Statistics Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/statistics-analysis/">
	
	Statistics Analysis
</a>



  
</li>



<li>
  
    



<a  title="Index Fragmentation Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/index-fragmentation-analysis/">
	
	Index Fragmentation Analysis
</a>



  
</li>



<li>
  
    



<a  title="Execution Plan Cache Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/execution-plan-cache-analysis/">
	
	Execution Plan Cache Analysis
</a>



  
</li>



<li>
  
    



<a  title="Query Recompilation" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/query-recompilation/">
	
	Query Recompilation
</a>



  
</li>



<li>
  
    



<a  title="Query Design Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/query-design-analysis/">
	
	Query Design Analysis
</a>



  
</li>



<li>
  
    



<a  title="Blocking Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/blocking-analysis/">
	
	Blocking Analysis
</a>



  
</li>



<li>
  
    



<a  title="Deadlock Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/deadlock-analysis/">
	
	Deadlock Analysis
</a>



  
</li>



<li>
  
    



<a  title="Cursor Cost Analysis" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/cursor-cost-analysis/">
	
	Cursor Cost Analysis
</a>



  
</li>



<li>
  
    



<a  title="Database Performance Stress Testing" href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/database-performance-stress-testing/">
	
	Database Performance Stress Testing
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          
          <li>
            <a href="https://twitter.com/peruzal" target="_blank" title="@peruzal on Twitter">
              @peruzal on Twitter
            </a>
          </li>
          

          
          <li>
            <a href="https://github.com/peruzal" target="_blank" title="@peruzal on GitHub">
              @peruzal on GitHub
            </a>
          </li>
          

          
          <li>
            <a href="mailto:hello@peruzal.com" title="Email of hello@peruzal.com">
              Contact via email
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>SQL Performance Analysis </h1>

			

<h2 id="performance-monitor-tool">Performance Monitor Tool</h2>

<p>Performance Monitor tracks resource behavior by capturing performance data generated by hardware and software components of the system, such as a processor, a process, a thread, and so on.</p>

<p>To start Perfmon do the following :</p>

<ul>
<li>Click <strong>Start</strong></li>
<li>Type <strong>run</strong></li>
<li>Type <strong>perfmon</strong></li>
</ul>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/perfmon.png" alt="PerfMon" /></p>

<p>There can be multiple instances of a component and totals for all the components, e.g for the Processor component</p>

<ul>
<li>Performance object: Processor</li>
<li>Counter: % Processor Time</li>
<li>Instance: _Total</li>
</ul>

<p>You can use the graphical component to gather counters but the recommended way is to save the data collection set to a file and analyze off the production server.</p>

<h2 id="dynamic-management-views">Dynamic Management Views</h2>

<p>Dynamic management views and functions return server state information that can be used to monitor the health of a server instance, diagnose problems, and tune performance.</p>

<p>There are two types of dynamic management views and functions:</p>

<ul>
<li><strong>Server-scoped dynamic management views and functions</strong> -These require VIEW SERVER STATE permission on the server.</li>
<li><strong>Database-scoped dynamic management views and functions</strong> - These require VIEW DATABASE STATE permission on the database.</li>
</ul>

<p>All dynamic management views and functions exist in the sys schema and follow this naming convention <code>sys.dm_</code>.</p>

<p>Here are some execution dynamic management functions and views we will use in this guide :</p>

<h3 id="execution-related-dmvs">Execution Related DMVs</h3>

<ul>
<li>sys.dm_exec_query_plan</li>
<li>sys.dm_exec_query_stats</li>
<li>sys.dm_exec_sql_text</li>
<li>sys.dm_exec_cached_plans</li>
<li>sys.dm_exec_procedure_stats</li>
<li>sys.dm_exec_query_optimizer_info</li>
<li>sys.dm_exec_requests</li>
<li>sys.dm_exec_text_query_plan</li>
</ul>

<h3 id="i-o-related-dmvs">I/O Related DMVs</h3>

<ul>
<li>sys.dm_io_virtual_file_stats</li>
<li>sys.dm_io_pending_io_requests</li>
</ul>

<h3 id="transaction-related-dmvs">Transaction Related DMVs</h3>

<ul>
<li>sys.dm_tran_database_transaction</li>
<li>sys.dm_tran_session_transactions</li>
<li>sys.dm_tran_active_transactions</li>
<li>sys.dm_tran_current_transaction</li>
<li>sys.dm_tran_locks</li>
</ul>

<h3 id="sql-server-operating-system-related-dynamic-management-views">SQL Server Operating System Related Dynamic Management Views</h3>

<ul>
<li>sys.dm_os_buffer_descriptors</li>
<li>sys.dm_os_host_info</li>
<li>sys.dm_os_memory_brokers</li>
<li>sys.dm_os_memory_cache_counters</li>
<li>sys.dm_os_memory_cache_entries</li>
<li>sys.dm_os_memory_clerks</li>
<li>sys.dm_os_memory_nodes</li>
<li>sys.dm_os_performance_counters</li>
<li>sys.dm_os_process_memory</li>
<li>sys.dm_os_schedulers</li>
<li>sys.dm_os_sys_info</li>
<li>sys.dm_os_sys_memory</li>
<li>sys.dm_os_tasks</li>
<li>sys.dm_os_threads</li>
<li>sys.dm_os_volume_stats</li>
<li>sys.dm_os_wait_stats</li>
<li>sys.dm_os_waiting_tasks</li>
<li>sys.dm_os_windows_info</li>
<li>sys.dm_os_workers</li>
</ul>

<h3 id="object-related-dynamic-management-views-and-functions">Object Related Dynamic Management Views and Functions</h3>

<ul>
<li>sys.dm_db_stats_properties</li>
<li>sys.dm_db_stats_histogram</li>
</ul>

<h3 id="sys-dm-exec-requests-and-sys-dm-exec-sessions">sys.dm_exec_requests and sys.dm_exec_sessions</h3>

<ul>
<li><code>sys.dm_exec_requests</code> DMV is used to show resources currently used by an executing request</li>
<li><code>sys.dm_exec_sessions</code> shows the accumulated resources used on a session.</li>
</ul>

<p>To see the difference between the two DMVs let run the following :</p>

<pre><code class="language-sql"> -- copy and be ready to run the following code on that window:
DBCC FREEPROCCACHE
DBCC DROPCLEANBUFFERS
GO
SELECT * FROM Production.Product p1 CROSS JOIN
Production.Product p2
</code></pre>

<p>and in a new query window run the following and replace the SPID :</p>

<pre><code class="language-sql">-- copy the following code to a second window
SELECT cpu_time, reads, total_elapsed_time, logical_reads, row_count
FROM sys.dm_exec_requests
WHERE session_id = 56
GO
SELECT cpu_time, reads, total_elapsed_time, logical_reads, row_count
FROM sys.dm_exec_sessions
WHERE session_id = 56
</code></pre>

<h3 id="sys-dm-exec-query-stats">sys.dm_exec_query_stats</h3>

<p>Provides aggregated performance information for cached query plans. Using this information, you can avoid running server trace since the same information is available using this DMV.</p>

<p>Let&rsquo;s see how the DMV works by running the following queries :</p>

<pre><code class="language-sql">-- create the following stored procedure with three simple queries:
CREATE PROC test
AS
SELECT * FROM Sales.SalesOrderDetail WHERE SalesOrderID = 60677
SELECT * FROM Person.Address WHERE AddressID = 21
SELECT * FROM HumanResources.Employee WHERE BusinessEntityID = 229
</code></pre>

<p>Clean the buffer pool and the procedure cache and execute the stored procedure and notice the results from the DMV using the following :</p>

<pre><code class="language-sql">-- note that the code uses the sys.dm_exec_sql_text DMF
DBCC FREEPROCCACHE
DBCC DROPCLEANBUFFERS
GO
EXEC test
GO
SELECT execution_count, total_worker_time, total_physical_reads, total_logical_reads, text, sql_handle, plan_handle 
FROM sys.dm_exec_query_stats
CROSS APPLY sys.dm_exec_sql_text(sql_handle)
WHERE objectid = OBJECT_ID('dbo.test')
</code></pre>

<p>If you run several times you will notice the execution count value going up if the cached query plan is reused. The batch have the same <strong>sql_handle</strong> and <strong>query_handle</strong> and we can use those to retrieve the sql text within the batch and the query plan.</p>

<div class="admonition note">
<p class="admonition-title">Cached Plans</p>
<p>The DMV only displays the resource usage information for cached query plans. Due to memory pressure some query plans will not be cached, so you should be careful of missing expensive queries that might be running on the server but do not have their query plans cached. Instead you can use the <code>sys.dm_exec_query_requests</code> to currently executing queries.</p>
</div>

<h3 id="retrieving-the-actual-query-with-the-batch">Retrieving the Actual Query with the Batch</h3>

<p>Using the <code>statement_start_offset</code> and <code>statement_end_offset</code> we can retrieve the actual query within the batch. Both columns are the number of bytes where the query text begins and ends. Zero is the start of the batch and -1 the end of the batch.</p>

<p>The text data is stored as Unicode so we need to divide by 2 to get the length of the actual strings. We can use the SUBSTRING and DATALENGTH functions to get the desired result as follows :</p>

<pre><code class="language-sql">-- we can easily extend our previous query to inspect the plan cache to use statement_start_offset
-- and statement_end_offset and get something like the following code:
DBCC FREEPROCCACHE
DBCC DROPCLEANBUFFERS
GO
EXEC test
GO
SELECT SUBSTRING(text, (statement_start_offset/2) + 1,
((CASE statement_end_offset
WHEN -1
THEN DATALENGTH(text)
ELSE
statement_end_offset
END
- statement_start_offset)/2) + 1) AS statement_text, *
FROM sys.dm_exec_query_stats
CROSS APPLY sys.dm_exec_sql_text(sql_handle)
WHERE objectid = OBJECT_ID('dbo.test')
</code></pre>

<p>and we can manually test this be replacing the actual values as follows :</p>

<pre><code class="language-sql">-- to test the concept for a particular query
SELECT SUBSTRING(text, 44 / 2 + 1, (168 - 44) / 2 + 1) FROM sys.dm_exec_sql_text(
0x03000500996DB224E0B27201B7A1000001000000000000000000000000000000000000000000000000000000)
</code></pre>

<h3 id="retrieving-the-sql-text-and-plan-with-sql-handle-and-plan-handle">Retrieving the sql text and plan with sql_handle and plan_handle</h3>

<p>We can use the <code>sql_handle</code> and <code>plan_handle</code> to retrieve the sql text and plans respectively as follows :</p>

<p>&ndash; using the example before
SELECT * from sys.dm_exec_sql_text(
0x03000500996DB224E0B27201B7A1000001000000000000000000000000000000000000000000000000000000)</p>

<p>The sql_handle hash is guaranteed to be unique for every batch in the system. The text of the batch is stored in the SQL Manager Cache or SQLMGR, which you can inspect by running the following query:</p>

<pre><code class="language-sql">SELECT * FROM sys.dm_os_memory_objects WHERE type = ‘MEMOBJ_SQLMGR’
</code></pre>

<p>Because a sql_handle has a 1:N relationship with a plan_handle (that is, there can be more than one generated executed plan for a particular query), the text of the batch will remain on the SQLMGR cache store until the last of the generated plans is evicted from the plan cache.</p>

<p>The plan_handle is guaranteed to be unique for each batch in the system and we can retrieve the query plan as follows :</p>

<pre><code class="language-sql">-- here is an example:
SELECT * FROM sys.dm_exec_query_plan(
0x05000500996DB224B0C9B8F80100000001000000000000000000000000000000000000000000000000000000)
</code></pre>

<p>Cached execution plans are stored in the SQLCP and OBJCP cache stores: object plans, including stored procedures, triggers, and functions, are stored in the OBJCP cache stores, whereas plans for ad hoc, autoparameterized, and prepared queries are stored in the SQLCP cache store.</p>

<h2 id="finding-similar-query-plans-and-text-with-query-hash-and-plan-hash">Finding similar query plans and text with query_hash and plan_hash</h2>

<p>When a query is auto-parameterised, the query plan and hash will be the same even if different plans are generated for the query. But this is not always the case, let&rsquo;s look at an example :</p>

<pre><code class="language-sql">DBCC FREEPROCCACHE
DBCC DROPCLEANBUFFERS
GO
SELECT * FROM Person.Address
WHERE AddressID = 12
GO
SELECT * FROM Person.Address
WHERE AddressID = 37
GO
SELECT plan_handle, plan_generation_num, execution_count FROM sys.dm_exec_query_stats
</code></pre>

<p>and the result shows the following :</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/query-handle.png" alt="Query Handle" /></p>

<p>You will notice both queries have the same plan handle and the plan was re-used to execute the second query. The query hashes are different but the plan handle are the same. The optimizer parameterised the query. This is good since the same query plan doesnt need to be re-generated again.</p>

<p>Now lets run and different query and use a different column as follows :</p>

<pre><code class="language-sql">- however, we can see a different behavior with the following query:
DBCC FREEPROCCACHE
DBCC DROPCLEANBUFFERS
GO
SELECT * FROM Person.Address
WHERE StateProvinceID = 79
GO
SELECT * FROM Person.Address
WHERE StateProvinceID = 59
GO
SELECT * FROM sys.dm_exec_query_stats
</code></pre>

<p>Now notice this time that the plan handle is different since the optimizer generated separated query plans. The reason is because the StateProvinceID could return 0 , 1 or more rows and its not safe to parameterize them.</p>

<p>To aggregate the query and plan handle qe can use the <code>query_hash</code> and <code>query_plan_hash</code> values as they will be the same. the query_hash is computed from the tree of logical operators, so the text does not have to be exactly the same. Different queries will produce the same query_hash.</p>

<h3 id="finding-expensive-queries">Finding Expensive Queries</h3>

<p>Lets use the <code>sys.dm_exec_query_stats</code> to find expensive queries with cached plans. The query uses the <code>query_hash</code> to group all related queries regardless of whether they are parameterized or not as follows :</p>

<pre><code class="language-sql">-- note that the query is grouping on the query_hash value to aggregate similar queries
SELECT TOP 20 query_stats.query_hash,
SUM(query_stats.total_worker_time) / SUM(query_stats.execution_count)
AS avg_cpu_time,
MIN(query_stats.statement_text) AS statement_text
FROM
(SELECT qs.*,
SUBSTRING(st.text, (qs.statement_start_offset/2) + 1,
((CASE statement_end_offset
WHEN -1 THEN DATALENGTH(ST.text)
ELSE qs.statement_end_offset END
- qs.statement_start_offset)/2) + 1) AS statement_text
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st) AS query_stats
GROUP BY query_stats.query_hash
ORDER BY avg_cpu_time DESC
</code></pre>

<p>We can trim the query down and only focus on the query plans and the batch as follows :</p>

<pre><code class="language-sql">-- notice that there is no need to use the statement_start_offset and statement_end_offset columns 
-- to separate the particular queries and that this time we are grouping on the query_plan_hash value.
SELECT TOP 20 query_plan_hash,
SUM(total_worker_time) / SUM(execution_count) AS avg_cpu_time,
MIN(plan_handle) AS plan_handle, MIN(text) AS query_text
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.plan_handle) AS st
GROUP BY query_plan_hash
ORDER BY avg_cpu_time DESC
</code></pre>

<p>and we can find the most expensive queries currently executing as follows :</p>

<pre><code class="language-sql">-- finally, we could also apply the same concept to find the most expensive queries currently executing
SELECT TOP 20 SUBSTRING(st.text, (er.statement_start_offset/2) + 1,
((CASE statement_end_offset
WHEN -1
THEN DATALENGTH(st.text)
ELSE
er.statement_end_offset
END
- er.statement_start_offset)/2) + 1) AS statement_text
, *
FROM sys.dm_exec_requests er
CROSS APPLY sys.dm_exec_sql_text(er.sql_handle) st
ORDER BY total_elapsed_time DESC
</code></pre>

<h2 id="hardware-resource-bottlenecks">Hardware Resource Bottlenecks</h2>

<p>Typically, SQL Server database performance is affected by stress on the following hardware resources:</p>

<ul>
<li>Memory</li>
<li>Disk I/O</li>
<li>Processor</li>
<li>Network</li>
</ul>

<p>Stress beyond the capacity of a hardware resource forms a bottleneck. To address the overall performance of a system, you need to identify these bottlenecks because they form the limit on overall system performance.</p>

<h2 id="memory-bottleneck-analysis">Memory Bottleneck Analysis</h2>

<p>Memory can be a problematic bottleneck because a bottleneck in memory will manifest on other resources, too. When the SQL Server process is low on memory, the <em>lazy writer</em> process works extensively by writing pages from memory to disk causing high contention on I/O and also increasing CPU cycles.</p>

<h3 id="sql-server-memory-management">SQL Server Memory Management</h3>

<p>The biggest consumer of SQL Server memory is the <em>buffer pool</em>. SQL Server first reads the data from the physical file into the buffer pool. When there&rsquo;s limited physical memory the pages from the buffer pool are flushed to dish.</p>

<p>The default SQL Server configuration is to dynamically manage memory. SQL Server will use the amount it needs and occasionally release memory to the OS.</p>

<p>We can configure the memory using SQL Server Management Studio :</p>

<ul>
<li>Right-Click the <strong>Server</strong> node in SQL Server Management Studio</li>
<li>Click <strong>Properties</strong></li>
<li>Choose the <strong>Memory</strong> Tab</li>
</ul>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/sql-server-memory-configuration.png" alt="SQL Server Memory Configuration" /></p>

<p>We can also use the <code>sys.configurations</code> to show the configured values for the minimum and maximum amount of memory as follows :</p>

<pre><code class="language-sql">SELECT name, value, minimum, maximum, value_in_use, description, is_dynamic 
FROM sys.configurations
WHERE name IN ('max server memory (MB)','min server memory (MB)')
</code></pre>

<p>or we can use the <code>sp_configure</code> stored procedure as follows :</p>

<pre><code class="language-sql">--Enable showing advanced options
EXEC sp_configure 'show advanced options', 1;
GO
--Activate the new configuration
RECONFIGURE;
GO
EXEC sp_configure  'min server memory';
EXEC sp_configure  'max server memory';
</code></pre>

<p>We can also change the values using <code>sp_configure</code> but this is not recommended, e.g. to set the maximum memory to 10Gig and min server memory to 5Gig as follows :</p>

<pre><code class="language-sql">USE master;
EXEC sp_configure  'show advanced option',   1;
RECONFIGURE;
exec sp_configure  'min server memory (MB)',  5120;
exec sp_configure  'max server memory (MB)',  10240;
RECONFIGURE WITH OVERRIDE;
</code></pre>

<h3 id="performance-monitor-counters-for-memory-pressure">Performance Monitor Counters for Memory Pressure</h3>

<p>Here are Performance Monitors counters to monitor to detect memory pressure :</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/memory-perf-counters.jpg" alt="Performance Monitor Memory Counters" /></p>

<h3 id="buffer-cache-hit-ratio">Buffer Cache Hit Ratio</h3>

<p>This number of pages served from the buffer pool without having to read the data from the physical file. This value should be very high, in the 99 range for OLTP systems.</p>

<h3 id="page-life-expectancy">Page Life Expectancy</h3>

<p>This counter determines how long a page will stay in the buffer pool. On NUMA systems, the counter value is an average. To see specific measures, you’ll need to use the <em>Buffer Node:Page Life Expectancy</em> counter.</p>

<h3 id="checkpoint-pages-sec">Checkpoint Pages/Sec</h3>

<p>The number of pages written to disk during checkpoint. This value should be very low around 30 and below.</p>

<h3 id="lazy-writes-sec">Lazy Writes/Sec</h3>

<p>The lazy writer process writes buffer pages to the disk, this values represent the number of pages written per second. The value should be consistently less than 20.</p>

<h3 id="monitoring-memory-dmvs">Monitoring Memory DMVs</h3>

<p>The following DMVs can be used to monitor memory pressure with SQL Server :</p>

<ul>
<li><strong>sys.dm_os_memory_brokers</strong> - Allocations that are internal to SQL Server use the SQL Server memory manager. Tracking the difference between process memory counters from sys.dm_os_process_memory and internal counters can indicate memory use from external components in the SQL Server memory space.</li>
<li><strong>sys.dm_os_memory_clerks</strong> - Returns the set of all memory clerks that are currently active in the instance of SQL Server.</li>
</ul>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The SQL Server memory manager consists of a three-layer hierarchy. At the bottom of the hierarchy are memory nodes. The middle level consists of memory clerks, memory caches, and memory pools. The top layer consists of memory objects. These objects are generally used to allocate memory in an instance of SQL Server.</p>

<p>Memory nodes provide the interface and the implementation for low-level allocators. Inside SQL Server, only memory clerks have access to memory nodes. Memory clerks access memory node interfaces to allocate memory. Memory nodes also track the memory allocated by using the clerk for diagnostics. Every component that allocates a significant amount of memory must create its own memory clerk and allocate all its memory by using the clerk interfaces. Frequently, components create their corresponding clerks at the time SQL Server is started.</p>
</div>

<h2 id="memory-bottleneck-resolutions">Memory Bottleneck Resolutions</h2>

<p>A few of the common resolutions for memory bottlenecks are as follows:</p>

<ul>
<li>Optimizing application workload</li>
<li>Allocating more memory to SQL Server</li>
<li>Moving in-memory tables back to standard storage</li>
<li>Increasing system memory</li>
<li>Changing from a 32-bit to a 64-bit processor</li>
<li>Enabling 3GB of process space</li>
<li>Compressing data</li>
<li>Addressing fragmentation</li>
</ul>

<h2 id="disk-bottleneck-analysis">Disk Bottleneck Analysis</h2>

<p>The disk subsystem is the slowest component within when troubleshooting SQL Server performance.</p>

<p>The optimal number of files depends on workload and the underlying hardware. As a rule of thumb, create four data files if the server has up to 16 logical CPUs, keeping a 1/8th ratio between files and CPUs afterward.</p>

<h3 id="file-auto-growth">File Auto-growth</h3>

<p>Set the same initial size and auto-growth parameters, with grow size being defined in megabytes rather than by percentage for all files in a same filegroup. This helps the proportional fill algorithm balance write activities evenly across data files.</p>

<p>SQL Server 2016 introduces two options— <strong>AUTOGROW_SINGLE_FILE</strong> and <strong>AUTOGROW_ALL_FILES—</strong>which control auto-growth events on a per-filegroup level. With AUTOGROW_SINGLE_FILE, which is the default option, SQL Server 2016 grows the single file in the filegroup when needed. With AUTOGROW_ALL_FILES, SQL Server grows all files in the filegroup whenever one of the files is out of space.</p>

<h3 id="enable-instant-file-initialization">Enable Instant File Initialization</h3>

<p>SQL Server doesn’t have a setting or checkbox to enable IFI.</p>

<p>Instead, it detects whether or not the service account it’s running under has the Perform Volume Maintenance Tasks permission in the Windows Security Policy. You can find and edit this policy by running secpol.msc (Local Security Policy) in Windows. Then:</p>

<ol>
<li>Expand the Local Policies Folder</li>
<li>Click on User Rights Assignment</li>
<li>Go down to the “Perform Volume Maintenance Tasks” option and double click it</li>
<li>Add your SQL Server Service account, and click OK out of the dialog.</li>
</ol>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/secpol.png" alt="Enable Instant File Initialization" /></p>

<p>IFI setting can also be enabled during the installation of SQL Server by checking the following :</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/instant-file-initialization-during-install.jpg" alt="Enable Instant File Initialization During Install" /></p>

<div class="admonition note">
<p class="admonition-title">Restart SQL After Giving Permission</p>
<p>SQL Server checks to see if Instant File Initialization is enabled on startup. You need to restart the SQL Server service after you give the corresponding permission to the SQL Server startup account.</p>
</div>

<p>In order to check if Instant File Initialization is enabled, you can use the code below :</p>

<pre><code class="language-sql">dbcc traceon(3004,3605,-1)
go
create database Dummy
go
exec sp_readerrorlog
go
drop database Dummy
go
dbcc traceoff(3004,3605,-1)
go
</code></pre>

<p>This code sets two trace flags that force SQL Server to put additional information into the error log, create a small database, and read the content of the error log file.
If <strong>Instant File Initialization</strong> is not enabled, SQL Server will zero out both the .mdf file and .mdf files.</p>

<h3 id="data-pages-and-data-rows">Data Pages and Data Rows</h3>

<p>The space in the database is divided into logical 8KB pages. These pages are continuously numbered starting with zero, and they can be referenced by specifying a file ID and page number.</p>

<p>SQL Server does not let you create the table when this is not the case. For example, the code in Listing 1-8 produces an error.</p>

<pre><code class="language-sql">create table dbo.BadTable
(
    Col1 char(4000),
    Col2 char(4060)
)
</code></pre>

<p>You can reduce the size of the data row by creating tables in a manner in which variable-length columns, which usually store null values, are defined as the last ones in the <strong>CREATE TABLE</strong> statement. This is the only case in which the order of columns in the <strong>CREATE TABLE</strong> statement matters.</p>

<h3 id="large-objects-storage">Large Objects Storage</h3>

<p>Even though the fixed-length data and the internal attributes of a row must fit into a single page, SQL Server can store the variable-length data on different data pages. There are two different ways to store the data, depending on the data type and length.</p>

<ol>
<li>ROW-OVERFLOW STORAGE</li>
<li>LOB STORAGE</li>
</ol>

<h3 id="row-overflow-storage">ROW-OVERFLOW STORAGE</h3>

<p>SQL Server stores variable-length column data that does not exceed 8,000 bytes on special pages called row-overflow pages.</p>

<pre><code class="language-sql">create table dbo.RowOverflow
(
    ID int not null,
    Col1 varchar(8000) null,
    Col2 varchar(8000) null
);
insert into dbo.RowOverflow(ID, Col1, Col2) values (1,replicate('a',8000),replicate('b',8000));
</code></pre>

<p>As you see, SQL Server creates the table and inserts the data row without any errors, even though the data-row size exceeds 8,060 bytes. The data is store in the row-overflow pages.</p>

<h3 id="lob-storage">LOB STORAGE</h3>

<p>For the <em>text</em>, <strong>ntext</strong>, or <em>image</em> columns, SQL Server stores the data off-row by default. It uses another kind of pages called a LOB data pages.</p>

<p>You can control this behavior to a degree by using the <code>text in row</code> table option. For example,</p>

<pre><code class="language-sql">exec sp_table_option dbo.MyTable, 'text in row', 200
</code></pre>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/lob.jpg" alt="LOB" /></p>

<p>As with row-overflow data, there is a pointer to another piece of information called the LOB root structure, which contains a set of the pointers to other data pages and rows. When LOB data is less than 32 KB and can fit into five data pages, the LOB root structure contains the pointers to the actual chunks of LOB data. Otherwise, the LOB tree starts to include additional intermediate levels of pointers, similar to the index B-Tree</p>

<p>Lets store some data :</p>

<pre><code class="language-sql">create table dbo.TextData
(
    ID int not null,
    Col1 text null
);
insert into dbo.TextData(ID, Col1) values (1, replicate(convert(varchar(max),'a'),16000));
</code></pre>

<div class="admonition warning">
<p class="admonition-title">Deprecated Types</p>
<p><code>text</code>, <code>ntext</code>, and <code>image</code> data types are deprecated, and they will be removed in future versions of SQL Server. Use <code>varchar(max)</code>, <code>nvarchar(max)</code>, and <code>varbinary(max)</code> columns instead.</p>
</div>

<p>When a page does not have enough free space to accommodate a row, SQL Server allocates a new page and places the row.</p>

<h3 id="select-and-i-o">SELECT * and I/O</h3>

<p>There are plenty of reasons why selecting all columns from a table with the SELECT * operator is not a good idea. It is recommended that you avoid such a pattern and instead explicitly specify the list of columns needed by the client application. This is especially important with row-overflow and LOB storage, when one row can have data stored in multiple data pages. SQL Server needs to read all of those pages, which can significantly decrease the performance of queries.</p>

<p>As an example, let’s assume that we have table dbo.Employees, with one column storing employee pictures. The following code creates the table and populates it with some data.</p>

<pre><code class="language-sql">create table dbo.Employees
(
    EmployeeId int not null,
    Name varchar(128) not null,
    Picture varbinary(max) null
);

with N1(C) as (select 0 union all select 0) -- 2 rows
    ,N2(C) as (select 0 from N1 as T1 cross join N1 as T2) -- 4 rows
    ,N3(C) as (select 0 from N2 as T1 cross join N2 as T2) -- 16 rows
    ,N4(C) as (select 0 from N3 as T1 cross join N3 as T2) -- 256 rows
    ,N5(C) as (select 0 from N4 as T1 cross join N2 as T2) -- 1,024 rows
    ,IDs(ID) 
    as (
        select row_number() over (order by (select null)) from N5
    )
insert into dbo.Employees(EmployeeId, Name, Picture)
select ID, 
	'Employee ' + convert(varchar(5),ID), 
	convert(varbinary(max),
	replicate(convert(varchar(max),'a'),120000)) 
from Ids;
</code></pre>

<p>Compare the output from the two queries :</p>

<pre><code class="language-sql">SET STATISTICS IO ON;
SET STATISTICS TIME ON;
select * from dbo.Employees;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
</code></pre>

<p>and the output from the query :</p>

<pre><code class="language-sh">(1024 row(s) affected)
Table 'Employees'. Scan count 1, logical reads 7, physical reads 0, read-ahead reads 0, lob logical reads 90888, lob physical reads 0, lob read-ahead reads 0.
 SQL Server Execution Times:
   CPU time = 125 ms,  elapsed time = 3098 ms.
</code></pre>

<p>Take note of the 90888 number of <code>lob</code> reads.</p>

<p>and the query without choosing all columns :</p>

<pre><code class="language-sql">SET STATISTICS IO ON;
SET STATISTICS TIME ON;
select EmployeeId, Name from dbo.Employees;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
</code></pre>

<p>and the following output :</p>

<pre><code class="language-sh">(1024 row(s) affected)
Table 'Employees'. Scan count 1, logical reads 7, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 144 ms.
</code></pre>

<h3 id="extents-and-allocation-map-pages">Extents and Allocation Map Pages</h3>

<p>QL Server logically groups eight pages into 64 KB units called extents. There are two types of extents available:</p>

<ul>
<li><strong>mixed extents</strong> store data that belongs to different objects</li>
<li><strong>uniform extents</strong> store the data for the same object.</li>
</ul>

<p>By default, when a new object is created, SQL Server stores the first eight object pages in mixed extents. After that, all subsequent space allocation for that object is done with uniform extents.</p>

<p>SQL Server uses a special kind of pages, called allocation maps, to track extent and page usage in a file.</p>

<ul>
<li><strong>GAM</strong> - Global Allocation Map</li>
<li><strong>SGAM</strong> - Shared Global Allocation Map</li>
<li><strong>IAM</strong> - Index Allocation Map</li>
</ul>

<h3 id="data-modifications">Data Modifications</h3>

<p>SQL Server does not read or modify data rows directly on the disk. Every time you access data, SQL Server reads it into memory.</p>

<p>Initial state</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/data-modification-before.jpg" alt="Initial Stage" /></p>

<p>Data modification - modifying data</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/data-modification-second-stage.jpg" alt="Data Mofification" /></p>

<p>Data modifiation - checkpoint</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/data-modification-modification.jpg" alt="Data modification - checkpoint" /></p>

<p>There is another SQL Server process called <strong>lazy writer</strong> that can save dirty pages on disk. As the opposite to checkpoint, which saves dirty data pages by keeping them in the buffer pool, lazy writer processes the least recently used data pages (SQL Server tracks buffer pool page usage internally), releasing them from memory. It releases both dirty and clean pages, saving dirty data pages on disk during the process. As you can guess, lazy writer runs in case of memory pressure or when SQL Server needs to bring more data pages to the buffer pool.</p>

<h3 id="disk-performance-counters">Disk Performance Counters</h3>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/disk-counters.jpg" alt="Disk Performance Monitor Counters" /></p>

<h2 id="disk-bottleneck-resolutions">Disk Bottleneck Resolutions</h2>

<p>A few of the common disk bottleneck resolutions are as follows:</p>

<ul>
<li>Optimizing application workload</li>
<li>Using a faster I/O path</li>
<li>Using a RAID array</li>
<li>Using a SAN system</li>
<li>Using Solid State Drives</li>
<li>Aligning disks properly</li>
<li>Using a battery-backed controller cache</li>
<li>Adding system memory</li>
<li>Creating multiple files and filegroups</li>
<li>Moving the log files to a separate physical drive</li>
<li>Using partitioned tables</li>
</ul>

<h2 id="processor-bottleneck-analysis">Processor Bottleneck Analysis</h2>

<h3 id="performance-monitor-cpu-counters">Performance Monitor CPU Counters</h3>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/cpu-counters.jpg" alt="Performance Monitor CPU Counters" /></p>

<h2 id="processor-bottleneck-resolutions">Processor Bottleneck Resolutions</h2>

<p>You can use the following DMVs to monitor CPU pressure :</p>

<ul>
<li>sys.dm_os_workers</li>
<li>sys.dm_os_schedulers</li>
</ul>

<p>A few of the common processor bottleneck resolutions are as follows:</p>

<ul>
<li>Optimizing application workload</li>
<li>Eliminating or reducing excessive compiles/recompiles</li>
<li>Using more or faster processors</li>
<li>Not running unnecessary software</li>
</ul>

<h2 id="network-bottleneck-analysis">Network Bottleneck Analysis</h2>

<p>There are few issues related to networking issues on a production server but you should pay attention and monitor the performance of your network.</p>

<p><img src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/network-counters.jpg" alt="Network Counters" /></p>

<h2 id="network-bottleneck-resolutions">Network Bottleneck Resolutions</h2>

<p>A few of the common network bottleneck resolutions are as follows:</p>

<ul>
<li>Optimizing application workload</li>
<li>Adding network adapters</li>
<li>Moderating and avoiding interruptions</li>
<li>Let’s consider these resolutions in more detail</li>
</ul>

<h2 id="sql-server-overall-performance">SQL Server Overall Performance</h2>

<p>To analyze the overall performance of a SQL Server instance, besides examining hardware resource utilization, you should also examine some general aspects of SQL Server itself. You can use the performance counters presented below :</p>

<table>
<thead>
<tr>
<th>Object(Instance[,InstanceN])</th>
<th>Counter</th>
</tr>
</thead>

<tbody>
<tr>
<td>SQLServer:Access</td>
<td>Methods FreeSpace Scans/secFull Scans/secTable Lock Escalations/secWorktables Created/sec</td>
</tr>

<tr>
<td>SQLServer:Latches</td>
<td>Total Latch Wait Time (ms)</td>
</tr>

<tr>
<td>SQLServer:Locks(_Total)</td>
<td>Lock Timeouts/secLock Wait Time (ms)Number of Deadlocks/sec</td>
</tr>

<tr>
<td>SQLServer:SQL Statistics</td>
<td>Batch Requests/secSQL Re-Compilations/sec</td>
</tr>

<tr>
<td>SQLServer:General Statistics</td>
<td>Processes BlockedUser ConnectionsTemp Tables Creation RateTemp Tables for Destruction</td>
</tr>
</tbody>
</table>

<h2 id="creating-a-baseline">Creating a Baseline</h2>

<p>You can use the following steps to create a baseline :</p>

<ol>
<li>Create a reusable list of performance counters.</li>
<li>Create a counter log using your list of performance counters.</li>
<li>Minimize Performance Monitor overhead.</li>
</ol>


			<aside class="copyright" role="note">
				
				&copy; 2017 Copyright 2017 Peruzal &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/performance-tuning-overview/" title="Performance Tuning Overview">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              Performance Tuning Overview
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/sql-query-performance-analysis/" title="SQL Query Performance Analysis">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              SQL Query Performance Analysis
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

