<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcomes on SQL Server Performance and Tuning</title>
    <link>http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/welcome/index.xml</link>
    <description>Recent content in Welcomes on SQL Server Performance and Tuning</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright 2017 Peruzal</copyright>
    <lastBuildDate>Mon, 27 Feb 2017 22:58:49 +0200</lastBuildDate>
    <atom:link href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/welcome/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Getting Started</title>
      <link>http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/welcome/</link>
      <pubDate>Mon, 27 Feb 2017 22:58:49 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/welcome/</guid>
      <description>

&lt;h2 id=&#34;set-statistics-io&#34;&gt;Set STATISTICS IO&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SET STATISTICS IO&lt;/code&gt; displays the amount of disk activity generated by a query. To enable it, run the following statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET STATISTICS TIME ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now can run a query and check the message tab :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT DISTINCT(CustomerID)
FROM Sales.SalesOrderHeader
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clean-the-buffer-cache&#34;&gt;Clean the Buffer Cache&lt;/h3&gt;

&lt;p&gt;We can remove all the cached pages from the buffer by running :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DBCC DROPCLEANBUFFERS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When testing, its recommended to clean the buffer and run the query. This will give you a true picture of the performance of the query.&lt;/p&gt;

&lt;p&gt;Then run the following query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail WHERE ProductID = 870
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will show an output similar to the following:&lt;/p&gt;

&lt;p&gt;Here are the definitions of these items, which all use 8K pages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Logical reads&lt;/strong&gt; Number of pages read from the buffer pool.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Physical reads&lt;/strong&gt; Number of pages read from disk.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Read-ahead reads&lt;/strong&gt; Read-ahead is a performance optimization mechanism that anticipates the needed data pages and reads them from disk. It can read up to 64 contiguous pages from one data file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lob logical&lt;/strong&gt; reads Number of large object (LOB) pages read from the buffer pool.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lob physical&lt;/strong&gt; reads Number of large object (LOB) pages read from disk.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lob read-ahead&lt;/strong&gt; reads Number of large object (LOB) pages read from disk using the read-ahead mechanism, as explained earlier.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, if you run the same query again, you will no longer get physical and read-ahead reads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scan count&lt;/strong&gt;is defined as the number of seeks or scans started after reaching the leaf level (that is, the bottom level of an index). The only case when scan count will return 0 is when youâ€™re seeking for only one value on a unique index, like in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader WHERE SalesOrderID = 51119
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try the following query, in which SalesOrderID is defined in a nonunique index and can return more than one record, you can see that scan count now returns 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail WHERE SalesOrderID = 51119
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, in the following example, scan count is 4 because SQL Server has to perform four seeks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader WHERE SalesOrderID IN (51119, 43664, 63371, 75119)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;removing-plans-from-the-plan-cache&#34;&gt;Removing Plans from the Plan Cache&lt;/h2&gt;

&lt;p&gt;You can use a few different commands to remove plans from the plan cache :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;DBCC FREEPROCCACHE&lt;/code&gt; statement can be used to remove all the entries from the plan cache. It can also accept a plan handle or a SQL handle to remove only specific plans.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DBCC FREESYSTEMCACHE&lt;/code&gt; statement can be used to remove all the elements from the plan cache or only the elements associated with a Resource Governor pool name.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DBCC FLUSHPROCINDB&lt;/code&gt; can be used to remove all the cached plans for a particular database&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DBCC DROPCLEANBUFFERS&lt;/code&gt; statement can be used to remove all the buffers from the buffer pool. You can use this statement in cases where you want to simulate a query starting with a cold cache&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>