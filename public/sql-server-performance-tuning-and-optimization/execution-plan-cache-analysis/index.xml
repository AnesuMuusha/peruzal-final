<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Execution-plan-cache-analyses on SQL Server Performance and Tuning</title>
    <link>http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/execution-plan-cache-analysis/index.xml</link>
    <description>Recent content in Execution-plan-cache-analyses on SQL Server Performance and Tuning</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright 2017 Peruzal</copyright>
    <lastBuildDate>Sat, 18 Mar 2017 14:54:08 +0200</lastBuildDate>
    <atom:link href="http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/execution-plan-cache-analysis/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Execution Plan Cache Analysis</title>
      <link>http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/execution-plan-cache-analysis/</link>
      <pubDate>Sat, 18 Mar 2017 14:54:08 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/execution-plan-cache-analysis/</guid>
      <description>

&lt;h2 id=&#34;execution-plan-generation&#34;&gt;Execution Plan Generation&lt;/h2&gt;

&lt;p&gt;SQL Server uses a cost-based optimization technique to determine the processing strategy of a query. The optimizer considers both the metadata of the database objects, such as unique constraints or index size, and the current distribution statistics of the columns referred to in the query when deciding which index and join strategies should be used.&lt;/p&gt;

&lt;p&gt;The following techniques are performed in order :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Parsing&lt;/li&gt;
&lt;li&gt;Binding&lt;/li&gt;
&lt;li&gt;Query optimization&lt;/li&gt;
&lt;li&gt;Execution plan generation, caching, and hash plan generation&lt;/li&gt;
&lt;li&gt;Query execution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/query-optimization-process.jpg&#34; alt=&#34;Query Optimization Overview&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In order to arrive at an optimal plan, the query optimizer uses transformation rules and heuristics. The optimizer uses heuristics to reduce the amount of available optimization options. The plans are stored in memory is a component called the &lt;strong&gt;Memo&lt;/strong&gt;. The optimizer adopts different techniques, namely, the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Simplification&lt;/li&gt;
&lt;li&gt;Trivial plan match&lt;/li&gt;
&lt;li&gt;Multiple optimization phases&lt;/li&gt;
&lt;li&gt;Parallel plan optimization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;view-query-tree&#34;&gt;View Query Tree&lt;/h3&gt;

&lt;p&gt;We can use some undocumented query hints and view the query that sql server optimizaer generates as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT Count(*)
FROM Person.Person
OPTION (RECOMPILE,  QUERYTRACEON 8606, QUERYTRACEON 3604, QUERYTRACEON 8612, QUERYTRACEON 2372);
-- QUERYTRACEON 3604 Output to console
-- QUERYTRACEON 8606 Logical operators trees
-- QUERYTRACEON 8612   -- Add aditional cardinality info
-- QUERYTRACEON 2372,  -- Optimization stage memory info
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;costing-the-plan&#34;&gt;Costing the Plan&lt;/h3&gt;

&lt;p&gt;The query optimizer estimates the cost of each operator in the query tree and selects the least expensive one. SQL Server estimates the number of rows returned, cardinality estimate, by looking at the statistics available. It also considers the resources such as I/O, CPU and memory used by each operator.&lt;/p&gt;

&lt;h2 id=&#34;components-of-the-execution-plan&#34;&gt;Components of the Execution Plan&lt;/h2&gt;

&lt;p&gt;The execution plan generated by the optimizer contains two components.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Query plan&lt;/strong&gt; - This represents the commands that specify all the physical operations required to execute a query.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execution context&lt;/strong&gt; - This maintains the variable parts of a query within the context of a given user.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;aging-of-the-execution-plan&#34;&gt;Aging of the Execution Plan&lt;/h2&gt;

&lt;p&gt;The procedure cache is part of SQL Server’s buffer cache, which also holds data pages. As new execution plans are added to the procedure cache, the size of the procedure cache keeps growing, affecting the retention of useful data pages in memory. To avoid this, SQL Server dynamically controls the retention of the execution plans in the procedure cache, retaining the frequently used execution plans and discarding plans that are not used for a certain period of time.&lt;/p&gt;

&lt;p&gt;When an execution plan is generated, the age field is populated with the cost of generating the plan. A complex query requiring extensive optimization will have an age field value higher than that for a simpler query.&lt;/p&gt;

&lt;p&gt;The cheaper the execution plan was to generate, the sooner its cost will be reduced to 0. Once an execution plan’s cost reaches 0, the plan becomes a candidate for removal from memory.&lt;/p&gt;

&lt;h2 id=&#34;analyzing-the-execution-plan-cache&#34;&gt;Analyzing the Execution Plan Cache&lt;/h2&gt;

&lt;p&gt;You can obtain a lot of information about the execution plans in the procedure cache by accessing various dynamic management objects. The initial DMO for working with execution plans is sys.dm_exec_cached_plans.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT  *
FROM    sys.dm_exec_cached_plans;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;execution-plan-reuse&#34;&gt;Execution Plan Reuse&lt;/h2&gt;

&lt;p&gt;When a query is submitted, SQL Server checks the procedure cache for a matching execution plan. If one is not found, then SQL Server performs the query compilation and optimization to generate a new execution plan. However, if the plan exists in the procedure cache, it is reused with the private execution context. This saves the CPU cycles that otherwise would have been spent on the plan generation.&lt;/p&gt;

&lt;h2 id=&#34;query-plan-hash-and-query-hash&#34;&gt;Query Plan Hash and Query Hash&lt;/h2&gt;

&lt;p&gt;With SQL Server 2008, new functionality around execution plans and the cache was introduced called the query plan hash and the query hash. These are binary objects using an algorithm against the query or the query plan to generate the binary hash value.&lt;/p&gt;

&lt;p&gt;To see the hash values in action, create two queries.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT  *
FROM    Production.Product AS p
JOIN    Production.ProductSubcategory AS ps
        ON p.ProductSubcategoryID = ps.ProductSubcategoryID
JOIN    Production.ProductCategory AS pc
        ON ps.ProductCategoryID = pc.ProductCategoryID
WHERE   pc.[Name] = &#39;Bikes&#39;
        AND ps.[Name] = &#39;Touring Bikes&#39;;

SELECT  *
FROM    Production.Product AS p
JOIN    Production.ProductSubcategory AS ps
        ON p.ProductSubcategoryID = ps.ProductSubcategoryID
JOIN    Production.ProductCategory AS pc
        ON ps.ProductCategoryID = pc.ProductCategoryID
where   pc.[Name] = &#39;Bikes&#39;
        and ps.[Name] = &#39;Road Bikes&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After you execute each of these queries, you can see the results of these format changes from sys.dm_exec_query_stats :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT  deqs.execution_count,
        deqs.query_hash,
        deqs.query_plan_hash,
        dest.text
FROM    sys.dm_exec_query_stats AS deqs
CROSS APPLY sys.dm_exec_sql_text(deqs.plan_handle) dest
WHERE   dest.text LIKE &#39;SELECT  *
FROM    Production.Product AS p%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;query-plan-caching&#34;&gt;Query Plan Caching&lt;/h2&gt;

&lt;p&gt;The execution plan of a query generated by the optimizer is saved in a special part of SQL Server’s memory pool called the plan cache or procedure cache. Saving the plan in a cache allows SQL Server to avoid running through the whole query optimization process again when the same query is resubmitted. SQL Server supports different techniques such as plan cache aging and plan cache types to increase the reusability of the cached plans. It also stores two binary values called the &lt;strong&gt;query hash&lt;/strong&gt; and the &lt;strong&gt;query plan hash&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/plan-retrieved-from-cache.png&#34; alt=&#34;Query Caching&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When performing query tuning, you will need to clear the plan cache. You can use the DBCC command as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DBCC FREEPROCCACHE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;view-cached-query-plan&#34;&gt;View Cached Query Plan&lt;/h3&gt;

&lt;p&gt;We can view the cached query plans using the DMV &lt;code&gt;sys.dm_exec_cached_plans&lt;/code&gt; as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT usecounts, cacheobjtype, plan_handle
FROM sys.dm_exec_cached_plans
WHERE cacheobjtype = &#39;Compiled Plan&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;view-graphical-execution-plan-from-cache&#34;&gt;View Graphical Execution Plan from Cache&lt;/h3&gt;

&lt;p&gt;We can use the stored binary plan handle to retrieve the XML and graphical query plans using the DMF &lt;code&gt;sys.dm_exec_query_plan&lt;/code&gt; and passing the plan handle as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT query_plan 
FROM sys.dm_exec_query_plan(&amp;lt;query plan handle here&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;view-memory-used-by-cached-plans&#34;&gt;View Memory Used by Cached Plans&lt;/h3&gt;

&lt;p&gt;We can use the &lt;code&gt;sys.dm_os_memory_cache_entries&lt;/code&gt; to see the memory used by cached query plans for both Adhoc queries, stored procedures and bound tree with the following :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT name, in_use_count, original_cost, pages_kb
FROM sys.dm_os_memory_cache_entries
WHERE type in (&#39;CACHESTORE_OBJCP&#39;, &#39;CACHESTORE_SQLCP&#39;, &#39;CACHESTORE_PHDR&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reading-query-plans&#34;&gt;Reading Query Plans&lt;/h2&gt;

&lt;p&gt;SQL Server supports displaying the query plans as :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Graphical&lt;/li&gt;
&lt;li&gt;Text&lt;/li&gt;
&lt;li&gt;XML&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;display-graphical-query-plan&#34;&gt;Display Graphical Query Plan&lt;/h3&gt;

&lt;p&gt;Using SQL Server Management Studio we can display two types of the execution plan :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Estimated Execution Plan&lt;/li&gt;
&lt;li&gt;Actual Execution Plan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Running the following query on my machine :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE AdventureWorks2012
GO
SELECT DISTINCT(City)
FROM Person.Address
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;i get the following execution plan.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/graphical-execution-plan.png&#34; alt=&#34;Graphical Execution Plans&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;characterstics&#34;&gt;Characterstics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Each node represents an operation implemented by an &lt;strong&gt;iterator&lt;/strong&gt;, also called an operator. The logical operation is displayed in brackets. If both logical and physical are the same no brackets are displayed.&lt;/li&gt;
&lt;li&gt;Each node is related to its parent, and data flow is represented with arrows&lt;/li&gt;
&lt;li&gt;Data flows from left to right&lt;/li&gt;
&lt;li&gt;The arrow width represents the relative number of rows returned&lt;/li&gt;
&lt;li&gt;You can hover on the operator for more properties&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To perform their job, physical operators implement at least the following three methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Open()&lt;/strong&gt; - Causes an operator to be initialized, and may include setting up any required data structures&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GetRow()&lt;/strong&gt; - Requests a row from the operator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Close()&lt;/strong&gt; - Performs some cleanup operations and shuts down the operator once it has performed its role&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;display-text-plan&#34;&gt;Display Text Plan&lt;/h3&gt;

&lt;p&gt;The text plans will be deprecated in future, instead you should use the XML and graphical execution plan. The two options allow you to display estimated execution plans as text. We can also display query plan as text using the SET option &lt;code&gt;SHOWPLAN_TEXT&lt;/code&gt; and setting to &lt;strong&gt;ON&lt;/strong&gt; and &lt;strong&gt;OFF&lt;/strong&gt;  as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE AdventureWorks2012
GO
SET SHOWPLAN_TEXT ON
GO
SELECT DISTINCT(City) 
FROM Person.Address
GO
SET SHOWPLAN_TEXT OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we will get the follwing output :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;StmtText
----------------------------------------------
SELECT DISTINCT(City) 
FROM Person.Address

(1 row(s) affected)

StmtText
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  |--Hash Match(Aggregate, HASH:([AdventureWorks2012].[Person].[Address].[City]), RESIDUAL:([AdventureWorks2012].[Person].[Address].[City] = [AdventureWorks2012].[Person].[Address].[City]))
       |--Index Scan(OBJECT:([AdventureWorks2012].[Person].[Address].[IX_Address_AddressLine1_AddressLine2_City_StateProvinceID_PostalCode]))

(2 row(s) affected)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To display additional information, you can use the &lt;code&gt;SHOWPLAN_ALL&lt;/code&gt; SET option as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE AdventureWorks2012
GO
SET SHOWPLAN_ALL ON
GO
SELECT DISTINCT(City) 
FROM Person.Address
GO
SET SHOWPLAN_ALL OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;STATISTICS PROFILE&lt;/code&gt; SET options  actually runs the query  and displays the text plan with more detailed results as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;Use AdventureWorks2012
GO
SET STATISTICS PROFILE ON
GO
SELECT DISTINCT(City)
FROM Person.Address
GO
SET STATISTICS PROFILE OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/statistics-profile-on.png&#34; alt=&#34;Statistics Profile&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;missing-indexes-from-graphical-execution&#34;&gt;Missing Indexes from Graphical Execution&lt;/h3&gt;

&lt;p&gt;The graphical query execution plan can show when a query can benefit from missing indexes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/missing-index-from-execution-plan.png&#34; alt=&#34;Missing Indexes from Graphical Execution Plan&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;additional-plan-properties&#34;&gt;Additional Plan Properties&lt;/h3&gt;

&lt;p&gt;The query plan properties also display the reason for an early termination in the &lt;strong&gt;Optimization Level&lt;/strong&gt; property, e.g when we run the following query :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader
WHERE SalesOrderID = 43666
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you will notice that the level is displayed as a trivial as follows :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/trivial-plan.png&#34; alt=&#34;Trivial Plan&#34; /&gt;&lt;/p&gt;

&lt;p&gt;but we can use a query hint to disable the trivial plan instead as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM Sales.SalesOrderHeader
WHERE SalesOrderID = 43666
OPTION (QUERYTRACEON 8757)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Trace Flags&lt;/p&gt;
&lt;p&gt;The QUERYTRACEON query hint is used to apply a trace flag at the query level.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;CardinalityEstimationModelVersion&lt;/strong&gt; attribute refers to the version of the cardinality estimation model used by the query optimizer.  SQL Server 2014 introduces a new cardinality estimator, but you still have the choice of using the old one by changing the database compatibility level or using trace flags 2312 and 9481.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;NonParallelPlanReason&lt;/strong&gt; optimal gives a reason why a parallel plan was not chosen. E.g if we use the option hint to use only one processor by setting the &lt;strong&gt;MAXDOP&lt;/strong&gt; to 1 as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader
WHERE SalesOrderID = 43666
OPTION (MAXDOP 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/nonparallel-reason.png&#34; alt=&#34;Non Paralled Reason&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;warnings-on-execution-plans&#34;&gt;Warnings on Execution Plans&lt;/h3&gt;

&lt;p&gt;The query plan also shows warnings and these should be carefully reviewed. The following warnings are displayed :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ColumnsWithNoStatistics&lt;/li&gt;
&lt;li&gt;NoJoinPredicate&lt;/li&gt;
&lt;li&gt;SpillToTempDb&lt;/li&gt;
&lt;li&gt;TypeConversion&lt;/li&gt;
&lt;li&gt;Wait&lt;/li&gt;
&lt;li&gt;PlanAffectingConvert&lt;/li&gt;
&lt;li&gt;SpatialGuess&lt;/li&gt;
&lt;li&gt;UnmatchedIndexes&lt;/li&gt;
&lt;li&gt;FullUpdateForOnlineIndexBuild&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;columnswithnostatistics-warning&#34;&gt;ColumnsWithNoStatistics Warning&lt;/h3&gt;

&lt;p&gt;They were no statistics available to the query optimizer for the column.&lt;/p&gt;

&lt;p&gt;Run the following statement to drop the existing statistics for the VacationHours column, if available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP STATISTICS HumanResources.Employee._WA_Sys_0000000C_49C3F6B7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can view the statistics on the table with the following query :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT s.name, c.name, auto_created 
FROM sys.stats s
JOIN sys.columns c
ON s.object_id = c.object_id and s.stats_id = c.column_id
WHERE s.object_id = object_id(&#39;HumanResources.Employee&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, temporarily disable automatic creation of statistics at the database level:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER DATABASE AdventureWorks2012
SET AUTO_CREATE_STATISTICS OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run this query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM HumanResources.Employee
WHERE VacationHours = 48
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you will get a query plan as follows :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/missing-column-statistics.png&#34; alt=&#34;Query Plan Missing Statistics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Enable the auto creating of statistics with the following :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER DATABASE AdventureWorks2012 SET AUTO_CREATE_STATISTICS ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and re-run the query. You will notice the query plan no longer have warnings as the statistics have been auto created.&lt;/p&gt;

&lt;h3 id=&#34;nojoinpredicate-warning&#34;&gt;NoJoinPredicate Warning&lt;/h3&gt;

&lt;p&gt;A possible problem while using the old-style ANSI SQL-89 join syntax is accidentally missing the join predicate and getting a NoJoinPredicate warning. Let’s suppose you intend to run the following query but forgot to include the WHERE clause:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader soh, Sales.SalesOrderDetail sod WHERE soh.SalesOrderID = sod.SalesOrderID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first indication of a problem could be that the query takes way too long to execute, even for small tables. Later, you will see that the query also returns a huge result set.&lt;/p&gt;

&lt;h3 id=&#34;planaffectingconvert-warning&#34;&gt;PlanAffectingConvert Warning&lt;/h3&gt;

&lt;p&gt;This warning shows that type conversions were performed that may impact the performance of the resulting execution plan. Run the following example, which declares a variable as nvarchar and then uses it in a query to compare against a varchar column, CreditCardApprovalCode:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DECLARE @code NVARCHAR(15)
SET @code = &#39;95555Vi4081&#39;
SELECT * 
FROM Sales.SalesOrderHeader
WHERE CreditCardApprovalCode = @code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/plan-convert.png&#34; alt=&#34;Plan Convert Issue&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;spilltotempdb-warning&#34;&gt;SpillToTempDb Warning&lt;/h3&gt;

&lt;p&gt;This warning shows than an operation didn’t have enough memory and had to spill data to disk during execution, which can be a performance problem because of the extra I/O overhead. To simulate this problem, run the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail ORDER BY UnitPrice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very simple query, and depending on the memory available on your system, you may not get the warning in your test environment, so you may need to try with a larger table instead.&lt;/p&gt;

&lt;h3 id=&#34;unmatchedindexes&#34;&gt;UnmatchedIndexes&lt;/h3&gt;

&lt;p&gt;Finally, the UnmatchedIndexes element can show that the query optimizer was not able to match a filtered index for a particular query (for example, when it is not able to see the value of a parameter). Suppose you create the following filtered index:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX IX_Color ON Production.Product(Name, ProductNumber)
WHERE Color = ‘White’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then run the query :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DECLARE @color nvarchar(15)
SET @color = &#39;White&#39;
SELECT Name, ProductNumber FROM Production.Product
WHERE Color = @color
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will notice we get an unmatched index, however the following will use an index :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT Name, ProductNumber FROM Production.Product
WHERE Color = &#39;White&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and remove the index :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP INDEX Production.Product.IX_Color
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-plans-from-the-plan-cache&#34;&gt;Getting Plans from the Plan Cache&lt;/h2&gt;

&lt;p&gt;Most of the times you will not run the queries manually but you will need to invest the queries that have already been ran. We can can retrieve the query plan in cache using the &lt;code&gt;sys.sm_exec_cached_plans&lt;/code&gt; or from currently executing queries using &lt;code&gt;sys.dm_exec_requests&lt;/code&gt; and from query statistics using &lt;code&gt;sys.dm_exec_query_stats&lt;/code&gt; :&lt;/p&gt;

&lt;h3 id=&#34;retrive-from-current-executing-queries&#34;&gt;Retrive from current executing queries&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-- A plan_handle is a hash value that represents a specific execution plan
SELECT * FROM sys.dm_exec_requests
CROSS APPLY
sys.dm_exec_query_plan(plan_handle)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;from-query-stats&#34;&gt;From query stats&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- The sys.dm_exec_query_stats DMV contains one row per query statement within the cached plan
SELECT * FROM sys.dm_exec_query_stats
CROSS APPLY
sys.dm_exec_query_plan(plan_handle)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;retrieve-top-10-queries-by-usage&#34;&gt;Retrieve top 10 queries by usage&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- You can run the following query to get this information
SELECT TOP 10 total_worker_time/execution_count AS avg_cpu_time,
plan_handle, query_plan
FROM sys.dm_exec_query_stats
CROSS APPLY sys.dm_exec_query_plan(plan_handle)
ORDER BY avg_cpu_time DESC
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;removing-plans-from-the-plan-cache&#34;&gt;Removing Plans from the Plan Cache&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;DBCC FREEPROCCACHE&lt;/strong&gt; statement can be used to remove all the entries from the plan cache.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;DBCC FREESYSTEMCACHE&lt;/strong&gt; statement can be used to remove all the elements from the plan cache or only the elements associated with a Resource Governor pool name.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;DBCC FLUSHPROCINDB&lt;/strong&gt; can be used to remove all the cached plans for a particular database.&lt;/li&gt;
&lt;li&gt;Not related,  the &lt;strong&gt;DBCC DROPCLEANBUFFERS&lt;/strong&gt; statement can be used to remove all the buffers from the buffer pool.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;set-statistics-time-io&#34;&gt;SET STATISTICS TIME / IO&lt;/h2&gt;

&lt;p&gt;You can use SET STATISTICS TIME to see the number of milliseconds required to parse, compile, and execute each statement. For example, run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET STATISTICS TIME ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then run the following query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT DISTINCT(CustomerID)
FROM Sales.SalesOrderHeader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and turn it off :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET STATISTICS TIME OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SET STATISTICS IO&lt;/strong&gt; displays the amount of disk activity generated by a query. To enable it, run the following statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET STATISTICS IO ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this next statement to clean all the buffers from the buffer pool to make sure that no pages for this table are loaded in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DBCC DROPCLEANBUFFERS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the following query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail WHERE ProductID = 870
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will show an output similar to the following:&lt;/p&gt;

&lt;p&gt;Here are the definitions of these items, which all use 8K pages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Logical reads&lt;/strong&gt; Number of pages read from the buffer pool.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Physical reads&lt;/strong&gt; Number of pages read from disk.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read-ahead reads&lt;/strong&gt; Read-ahead is a performance optimization mechanism that anticipates the needed data pages and reads them from disk. It can read up to 64 contiguous pages from one data file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lob logical reads&lt;/strong&gt; Number of large object (LOB) pages read from the buffer pool.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lob physical reads&lt;/strong&gt; Number of large object (LOB) pages read from disk.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lob read-ahead reads&lt;/strong&gt; Number of large object (LOB) pages read from disk using the read-ahead mechanism, as explained earlier.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, if you run the same query again, you will no longer get physical and read-ahead reads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scan count&lt;/strong&gt; is defined as the number of seeks or scans started after reaching the leaf level (that is, the bottom level of an index). The only case when scan count will return 0 is when you’re seeking for only one value on a unique index, like in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader WHERE SalesOrderID = 51119
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try the following query, in which SalesOrderID is defined in a nonunique index and can return more than one record, you can see that scan count now returns 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail WHERE SalesOrderID = 51119
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, in the following example, scan count is 4 because SQL Server has to perform four seeks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderHeader WHERE SalesOrderID IN (51119, 43664, 63371, 75119)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;execution-plan-cache-recommendations&#34;&gt;Execution Plan Cache Recommendations&lt;/h2&gt;

&lt;p&gt;To ensure efficient use of the plan cache, follow these recommendations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Explicitly parameterize variable parts of a query.&lt;/li&gt;
&lt;li&gt;Use stored procedures to implement business functionality.&lt;/li&gt;
&lt;li&gt;Use sp_executesql to avoid stored procedure maintenance.&lt;/li&gt;
&lt;li&gt;Use the prepare/execute model to avoid resending a query string.&lt;/li&gt;
&lt;li&gt;Avoid ad hoc queries.&lt;/li&gt;
&lt;li&gt;Use sp_executesql over EXECUTE for dynamic queries.&lt;/li&gt;
&lt;li&gt;Parameterize variable parts of queries with care.&lt;/li&gt;
&lt;li&gt;Avoid modifying environment settings between connections.&lt;/li&gt;
&lt;li&gt;Avoid the implicit resolution of objects in queries.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;query-optimizer-in-depth&#34;&gt;Query Optimizer in-depth&lt;/h2&gt;

&lt;p&gt;In this part we will now go in-depth and look at the query optimization process. Here is the major steps of the query optimization process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/query-optimization-in-depth.png&#34; alt=&#34;Query Optimization in Depth&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;dmvs-for-query-optimization-sys-dm-exec-query-optimizer-info&#34;&gt;DMVs for Query Optimization sys.dm_exec_query_optimizer_info&lt;/h3&gt;

&lt;p&gt;Returns detailed statistics about the operation of the SQL Server query optimizer. You can use this view when tuning a workload to identify query optimization problems or improvements. For example, you can use the total number of optimizations, the elapsed time value, and the final cost value to compare the query optimizations of the current workload and any changes observed during the tuning process. Some counters provide data that is relevant only for SQL Server internal diagnostic use.&lt;/p&gt;

&lt;h3 id=&#34;viewing-statistics-on-optimizer-execution&#34;&gt;Viewing statistics on optimizer execution&lt;/h3&gt;

&lt;p&gt;What are the current optimizer execution statistics for this instance of SQL Server?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM sys.dm_exec_query_optimizer_info;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Data type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;counter&lt;/td&gt;
&lt;td&gt;nvarchar(4000)&lt;/td&gt;
&lt;td&gt;Name of optimizer statistics event.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;occurrence&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;td&gt;Number of occurrences of optimization event for this counter.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Average property value per event occurrence.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;viewing-the-total-number-of-optimizations&#34;&gt;Viewing the total number of optimizations&lt;/h3&gt;

&lt;p&gt;How many optimizations are performed?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT occurrence AS Optimizations FROM sys.dm_exec_query_optimizer_info
WHERE counter = &#39;optimizations&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;average-elapsed-time-per-optimization&#34;&gt;Average elapsed time per optimization&lt;/h3&gt;

&lt;p&gt;What is the average elapsed time per optimization?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT ISNULL(value,0.0) AS ElapsedTimePerOptimization  
FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;elapsed time&#39;;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fraction-of-optimizations-that-involve-subqueries&#34;&gt;Fraction of optimizations that involve subqueries&lt;/h3&gt;

&lt;p&gt;What fraction of optimized queries contained a subquery?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT (SELECT CAST (occurrence AS float) 
FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;contains subquery&#39;) /  
(SELECT CAST (occurrence AS float) FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;optimizations&#39;)  
AS ContainsSubqueryFraction;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and as a percentage of the total optimizations :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT (SELECT CAST (occurrence AS float) 
FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;contains subquery&#39;) /  
(SELECT CAST (occurrence AS float) FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;optimizations&#39;) * 100 
AS ContainsSubqueryFraction ;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;view-percentage-of-optimization-on-query-with-hints&#34;&gt;View percentage of optimization on query with hints&lt;/h3&gt;

&lt;p&gt;This will be a good indicator on the flexibility of the application. The application should use hints sparingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- for example, the next query displays the percentage of optimizations in the instance that include hints
SELECT (SELECT occurrence FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;hints&#39; ) * 100.0 / 
(SELECT occurrence FROM sys.dm_exec_query_optimizer_info WHERE counter = &#39;optimizations&#39; )
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;check-optimizations-for-a-specific-workload&#34;&gt;Check optimizations for a specific workload&lt;/h3&gt;

&lt;p&gt;We can use the DMV to check for the optimization applied to a specific workload but they are several issues. There is no easy way but we can get a snapshot of the before optimization and after optimization and subtract the value to have an idea of the optimizations applied.&lt;/p&gt;

&lt;p&gt;Here is a query that can do that&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- optimize these queries now
-- so they do not skew the collected results
GO
SELECT *
INTO after_query_optimizer_info
FROM sys.dm_exec_query_optimizer_info
GO
SELECT *
INTO before_query_optimizer_info
FROM sys.dm_exec_query_optimizer_info
GO
DROP TABLE before_query_optimizer_info
DROP TABLE after_query_optimizer_info
GO
-- real execution starts
GO
SELECT *
INTO before_query_optimizer_info
FROM sys.dm_exec_query_optimizer_info
GO
-- insert your query here
SELECT *
FROM Person.Address
-- keep this to force a new optimization
OPTION (RECOMPILE)
GO
SELECT *
INTO after_query_optimizer_info
FROM sys.dm_exec_query_optimizer_info
GO
SELECT a.counter,
(a.occurrence - b.occurrence) AS occurrence,
(a.occurrence * a.value - b.occurrence *
b.value) AS value
FROM before_query_optimizer_info b
JOIN after_query_optimizer_info a
ON b.counter = a.counter
WHERE b.occurrence &amp;lt;&amp;gt; a.occurrence
DROP TABLE before_query_optimizer_info
DROP TABLE after_query_optimizer_info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We list some queries twi so that the query optimizer can optimize them first so that when we run again no new optimizations are added.&lt;/p&gt;

&lt;h3 id=&#34;parsing-and-binding&#34;&gt;Parsing and Binding&lt;/h3&gt;

&lt;p&gt;The Algebrizer parse and binds the SQL queries. It validates the syntax and uses the query information to build a relation query tree. Parsing only checks for valid SQL syntax without accessing the table names or columns or checking for their existence.&lt;/p&gt;

&lt;p&gt;We can test the following in SMSS by setting the options to &lt;strong&gt;PARSE_ONLY&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT lname, fname FROM authors
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/parse-only.png&#34; alt=&#34;Parse Only in SSMS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The above will pass the syntax since that&amp;rsquo;s valid SQL statement.&lt;/p&gt;

&lt;p&gt;The next stage is the binding, which validates the existence of the tables and their columns against the system catalogs and the permissions. The output is a algebrizer tree that is sent to the optimizer for optimization.&lt;/p&gt;

&lt;p&gt;The tree contains logical operations that are closely related to the corresponding SQL statement. There is no documentation on this but there&amp;rsquo;s a DMV that have some information on the mappings of the logical operations :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM sys.dm_xe_map_values 
WHERE name = &#39;query_optimizer_tree_id&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are also several undocumented trace flags that can allow you to see these different logical trees. For example, you can use the following query with the undocumented trace flag 8605. But first enable trace flag 3604, as shown next:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DBCC TRACEON(3604)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and check in the message tab for the logical query tree :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail
WHERE SalesOrderID = 43659
OPTION (RECOMPILE, QUERYTRACEON 8605, QUERYTRACEON 3604)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tree gets verbose quickly even for a small query. Unfortunately, there is no documented information to help understand these output trees and their operations.&lt;/p&gt;

&lt;h3 id=&#34;simplification&#34;&gt;Simplification&lt;/h3&gt;

&lt;p&gt;At this stage of the optimization process the query tree is simplified into a simpler form to enable quick optimization. Here are some of the things that happens during the simplification stage :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Contradictions are detected and removed and SQL server will not even execute the query. The optimizer can detect that no row will be returned by using a certain set of predicate combination.&lt;/li&gt;
&lt;li&gt;Filters in the WHERE clause are pushed down the tree so that they are evaluated early and reduce the amount of data access and also enable using indexes to retrieve the data. This is called &lt;em&gt;predicate pushdown&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Subqueries are converted into joins if possible.&lt;/li&gt;
&lt;li&gt;Redudant inner and outer joins are removed, e.g in when a table is join with another table that have a foregin key relationship, the other table might not be needed to retrieve data in what is called a Foreign Key Join elimination.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;contradiction-detection&#34;&gt;Contradiction Detection&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s use a table with a check constraint and see how the optimizer does contradicition detection. There&amp;rsquo;s a check constraint on the &lt;strong&gt;HumanResources.Employee&lt;/strong&gt; called &lt;strong&gt;CK_Employee_VacationHours&lt;/strong&gt;. This constraint uses the following rule &lt;code&gt;([VacationHours]&amp;gt;=(-40) AND [VacationHours]&amp;lt;=(240))&lt;/code&gt;. The value needs to be between -40 and 240.&lt;/p&gt;

&lt;p&gt;Let run the following query and look at the query plan :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM HumanResources.Employee
WHERE VacationHours &amp;gt; 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL Server will use a clustered index scan to retrieve the results, now lets change the value to 300 as follows :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/contradiction-detection.png&#34; alt=&#34;Contradiction Detection&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM HumanResources.Employee
WHERE VacationHours &amp;gt; 300
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The query plan changes and SQL server now uses a constant scan and the table is not even accessed at all. Because there is no need to access the table at all, SQL Server saves resources such as I/O, locks, memory, and CPU, thus making the query execute faster.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/constant-scan.png&#34; alt=&#34;Constant Scan&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Disable the constraint and run again and the index will now be scanned :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER TABLE HumanResources.Employee NOCHECK CONSTRAINT CK_Employee_VacationHours
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enable the index back again :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE HumanResources.Employee WITH CHECK CHECK CONSTRAINT CK_Employee_VacationHours
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another contradiction is when the predicate does contain the contradiction as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM HumanResources.Employee 
WHERE VacationHours &amp;gt; 10 AND VacationHours &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A trivial plan might also be used instead of a constant scan operator.&lt;/p&gt;

&lt;h3 id=&#34;view-the-simplified-tree&#34;&gt;View the Simplified Tree&lt;/h3&gt;

&lt;p&gt;Using the undocumented query hint from before, we can examine the generated simplified query tree by running following query and looking at the messages tab :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM HumanResources.Employee
WHERE VacationHours &amp;gt; 300
OPTION(RECOMPILE, QUERYTRACEON 8606,QUERYTRACEON 3604)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the output truncated :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;*** Input Tree: ***
        LogOp_Project QCOL: [AdventureWorks2012].[HumanResources].[Employee].BusinessEntityID QCOL: [AdventureWorks2012].[HumanResources].
            LogOp_Select
*** Simplified Tree: ***
LogOp_ConstTableGet (0) COL: IsBaseRow1000  QCOL: [AdventureWorks2012].[HumanResources].[Employee].BusinessEntityID QCOL:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreign-key-join-elimination&#34;&gt;Foreign Key Join Elimination&lt;/h3&gt;

&lt;p&gt;For the demonstration run the following query and observe the execution plan :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT soh.CustomerID, c.AccountNumber
FROM Sales.SalesOrderHeader soh
JOIN Sales.Customer c
on soh.CustomerID = c.CustomerID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the generated execution plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/join-elimination-1.png&#34; alt=&#34;Join Elimination&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You will notice a merge join was used and both tables are read.&lt;/p&gt;

&lt;p&gt;Now comment out the &lt;strong&gt;AccountNumber&lt;/strong&gt; column and run the query again :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT soh.CustomerID --, c.AccountNumber
FROM Sales.SalesOrderHeader soh
JOIN Sales.Customer c
on soh.CustomerID = c.CustomerID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is the generated execution plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/join-elimination-2.png&#34; alt=&#34;Join Elimination&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notice that only &lt;strong&gt;Sales.SalesOrderHeader&lt;/strong&gt; table is being read. The optimizer simplified the query using the foreign key constraint and in this case we do not need any rows from the &lt;strong&gt;Customers&lt;/strong&gt; table so there is no need to access the table at all, and the foreign key guarantees the data returned is correct.&lt;/p&gt;

&lt;p&gt;We can inspect the logical query tree using the trace flags :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT soh.CustomerID --, c.AccountNumber
FROM Sales.SalesOrderHeader soh
JOIN Sales.Customer c
on soh.CustomerID = c.CustomerID
OPTION(RECOMPILE, QUERYTRACEON 8606,QUERYTRACEON 3604)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the generated query tree truncated looks as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;*** Simplified Tree: ***
        LogOp_Join

            LogOp_Get TBL: Sales.SalesOrderHeader(alias TBL: soh) Sales.SalesOrderHeader

            LogOp_Get TBL: Sales.Customer(alias TBL: c) Sales.Customer

*******************
*** Join-collapsed Tree: ***
        LogOp_Get TBL: Sales.SalesOrderHeader(alias TBL: soh) Sales.SalesOrderHeader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the simplified query tree still retrieves from both tables but the join collapsed tree only retrieves the data from one table.&lt;/p&gt;

&lt;p&gt;Try disabling the constraint and run the query, you will notice the generated plan have to use the join as there is no other way to retrieve the data.&lt;/p&gt;

&lt;h3 id=&#34;trivial-plan&#34;&gt;TRIVIAL PLAN&lt;/h3&gt;

&lt;p&gt;The optimizer chooses a trivial plan when there&amp;rsquo;s no other way to run the query. SQL Server uses it to avoid the expensive operation of query optimization for queries that does not involve any cost estimation, e.g the following query will use a trivial plan :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- for example, testing with a very simple AdventureWorks2012 query, such as
SELECT * FROM Sales.SalesOrderDetail
WHERE SalesOrderID = 43659
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason is being the there&amp;rsquo;s a unique index &lt;strong&gt;PK_SalesOrderDetail_SalesOrderID_SalesOrderDetailID&lt;/strong&gt; that can only contain 0 or 1 row.
We can use a trace flag 8757 to disable the use a trivial plan as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- let’s again add the undocumented trace flag 8757 to avoid a trivial plan
SELECT * FROM Sales.SalesOrderDetail
WHERE SalesOrderID = 43659
OPTION (RECOMPILE, QUERYTRACEON 8757)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you notice from the properties in &lt;strong&gt;SSMS&lt;/strong&gt; that we get a full optimization. Use the &lt;code&gt;sys.dm_exec_query_optimizer_info&lt;/code&gt; and check the optimization information. You will notice instead of a trivial optimization, we have a hint and the optimization goes to search 1.&lt;/p&gt;

&lt;p&gt;Now use a different column and you will get full optimization :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Sales.SalesOrderDetail
WHERE ProductID = 870
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason is because they are several plans available and the query optimizer need to find the optimal plan to execute the query.&lt;/p&gt;

&lt;h3 id=&#34;statistics&#34;&gt;STATISTICS&lt;/h3&gt;

&lt;p&gt;The optimizer maintains statistics on columns and indexes that it uses during costing in the optimization process.&lt;/p&gt;

&lt;h2 id=&#34;query-operators&#34;&gt;Query Operators&lt;/h2&gt;

&lt;p&gt;The operators or iterators are used by the execution engine to perform the operation of retrieving data based on the execution plan. The operators have different characteristics, some are memory consuming, and some have to build the input before they start executing. In this section we will look at the common operators using the execution engine.&lt;/p&gt;

&lt;h2 id=&#34;data-access-operators&#34;&gt;Data Access Operators&lt;/h2&gt;

&lt;p&gt;These are the most common operators as they are used to retrieve data :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i-msdn.sec.s-msft.com/dynimg/IC121534.gif&#34; alt=&#34;Table Scan&#34; /&gt; Heap Table Scan&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i-msdn.sec.s-msft.com/dynimg/IC72069.gif&#34; alt=&#34;Index Scan&#34; /&gt; Clustered Index Scan&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i-msdn.sec.s-msft.com/dynimg/IC322.gif&#34; alt=&#34;Clustered Index Seek&#34; /&gt; Clustered Index Seek&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://i-msdn.sec.s-msft.com/dynimg/IC72069.gif&#34; alt=&#34;Index Scan&#34; /&gt; Non-clustered Index Scan&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://i-msdn.sec.s-msft.com/dynimg/IC322.gif&#34; alt=&#34;Clustered Index Seek&#34; /&gt; Non-Clustered Index Seek&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;scan&lt;/strong&gt; reads an entire structure, which could be a heap, a clustered index, or a nonclustered index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A seek, on the other hand, does not scan an entire structure, but instead efficiently retrieves rows by navigating an index. Can only be performed on a clustered on nonclustered index.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;scans&#34;&gt;Scans&lt;/h3&gt;

&lt;p&gt;Let’s start with the simplest example, by scanning a heap, which is performed by the Table Scan operator&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- the following query on the AdventureWorks2012 database will use a Table Scan
SELECT * FROM DatabaseLog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, the following query will show a Clustered Index Scan operator :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM Person.Address
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scan operator does not guarantee returning sorted results. The storage engine uses efficient methods to return the data without sorting. Some features are only available in the Enterprise Edition. You can check the properties of the query plan to see if the results were return sorted by looking at the &lt;strong&gt;Ordered&lt;/strong&gt; property.&lt;/p&gt;

&lt;p&gt;Run the following and check the Ordered property :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- if you want to know whether your data has been sorted, the Ordered property can show if the data 
SELECT * FROM Person.Address
ORDER BY AddressID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you will notice that its now true.&lt;/p&gt;

&lt;h3 id=&#34;non-clustered-index-scan&#34;&gt;Non-clustered index scan&lt;/h3&gt;

&lt;p&gt;The following query will produce a non-clustered index scan. The data will be returned without querying the base table :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT AddressID, City, StateProvinceID
FROM Person.Address
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each non-clustered index contains a clustering key, so in this case we didn&amp;rsquo;t have to query the base table because the index also contains the clustering key.&lt;/p&gt;

&lt;h3 id=&#34;seeks&#34;&gt;Seeks&lt;/h3&gt;

&lt;p&gt;An Index Seek does not scan the entire index, but instead navigates the B-tree index structure to quickly find one or more records. These can be performed by both the Clustered Index Seek and the Index Seek operators.&lt;/p&gt;

&lt;p&gt;The following query produces a clustered index seek :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt; -- now let’s look at Index Seeks
SELECT AddressID, City, StateProvinceID FROM Person.Address
WHERE AddressID = 12037
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the following produces a non-clustered index seek :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- the next query and Figure 4-6 both illustrate a nonclustered Index Seek operator
SELECT AddressID, StateProvinceID FROM Person.Address
WHERE StateProvinceID = 32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a clustered index seek can also return multiple rows, e,g in the following query :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- the previous query just returned one row, but you can change it to a new parameter like in the following example:
SELECT AddressID, StateProvinceID FROM Person.Address
WHERE StateProvinceID = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The query have been auto-parameterized, so any query will use the same plan, we can try to drop the cached query plans but you will notice the same query plan will be used.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DBCC FREEPROCCACHE
GO
Use AdventureWorks2012
GO
-- the previous query just returned one row, but you can change it to a new parameter like in the following example:
SELECT AddressID, StateProvinceID FROM Person.Address
WHERE StateProvinceID = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The query is using a partial ordered scan. It first finds the initial row and continues scanning the index for all matching rows which are logically together in the same leaf pages on the index. In this case, the data was retrieved without ever touching the base table.&lt;/p&gt;

&lt;p&gt;A more complicated example of partial ordered scans involves using a nonequality operator or a BETWEEN clause, like in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- a more complicated example of partial ordered scans involves using a nonequality operator or a BETWEEN clause
SELECT AddressID, City, StateProvinceID FROM Person.Address
WHERE AddressID BETWEEN 10000 and 20000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Clustered Index Seek operation will be used to find the first row that qualifies to the filter predicate and will continue scanning the index, row by row, until the last row that qualifies is found. More accurately, the scan will stop on the first row that does not qualify.&lt;/p&gt;

&lt;h3 id=&#34;bookmark-lookup&#34;&gt;Bookmark Lookup&lt;/h3&gt;

&lt;p&gt;The bookmark operator is used when a nonclustered index is useful to find one or more rows but does not cover all the columns in the query. Because the nonclustered index contains the clustering key, the base table is accessed using the clustering key to retrieve the columns not covered by the index.&lt;/p&gt;

&lt;p&gt;For example, in our previous query, an existing nonclustered index covers both AddressID and StateProvinceID columns. What if we also request the City and ModifiedDate columns on the same query? This is shown in the next query, which returns one record :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT AddressID, City, StateProvinceID, ModifiedDate
FROM Person.Address
WHERE StateProvinceID = 32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The query optimizer is choosing the index &lt;strong&gt;IX_Address_StateProvinceID&lt;/strong&gt; to find the records quickly. However, because the index does not cover the additional columns, it also needs to use the base table (in this case, the clustered index) to get that additional information. This operation is called a &lt;strong&gt;bookmark lookup&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Text and XML plans can show whether a Clustered Index Seek operator is performing a bookmark lookup by looking at the LOOKUP keyword and Lookup attributes :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET SHOWPLAN_TEXT ON
GO
SELECT AddressID, City, StateProvinceID, ModifiedDate
FROM Person.Address
WHERE StateProvinceID = 32
GO
SET SHOWPLAN_TEXT OFF
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;StmtText
----------------------------------------------------------------------------------------------------------------------------------------
  |--Nested Loops(Inner Join, OUTER REFERENCES:([AdventureWorks2012].[Person].[Address].[AddressID]))
       ....
       |--Clustered Index Seek(OBJECT:.. SEEK:([Person].[Address].[AddressID]) LOOKUP ORDERED FORWARD)

(3 row(s) affected)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run the same query, but this time, request StateProvinceID equal to 20. Now this will produce an index scan :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT AddressID, City, StateProvinceID, ModifiedDate
FROM Person.Address
WHERE StateProvinceID = 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the query optimizer is producing two different execution plans for the same query, with the only difference being the value of the StateProvinceID parameter. In this case, the query optimizer uses the value of the query’s &lt;strong&gt;StateProvinceID&lt;/strong&gt; parameter to estimate the cardinality of the predicate as it tries to produce an efficient plan for that parameter.&lt;/p&gt;

&lt;p&gt;The bookmark lookup performs random I/O so it is an expensive operation when more records need to be returned, so the optimizer instead chose to scan the index. The optimizer is cost based, so it used the statistics to find an optimal plan.&lt;/p&gt;

&lt;h2 id=&#34;aggregations&#34;&gt;Aggregations&lt;/h2&gt;

&lt;p&gt;SQL Server have two physical operators for implementing aggregations :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stream Aggregate&lt;/li&gt;
&lt;li&gt;Hash Aggregate&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sorting-and-hashing&#34;&gt;Sorting and Hashing&lt;/h3&gt;

&lt;p&gt;Lets discuss sorting and hashing before continuing with the rest of the operators as this plays an important roles.  The optimizer employs different methods to provide sorted data :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use an index&lt;/li&gt;
&lt;li&gt;use the Sort operator&lt;/li&gt;
&lt;li&gt;Use hashing algorithms&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;stream-aggregate&#34;&gt;Stream Aggregate&lt;/h3&gt;

&lt;p&gt;The Stream Aggregate is used for scalar aggregates, aggregates that return only a single value, e.g the SUM, COUNT, AVG, ect.c functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT AVG(ListPrice) FROM Production.Product
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and produces the following plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/scalar-aggregate.png&#34; alt=&#34;Scalar Aggregate&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Use the ext plan to reveal more information :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET SHOWPLAN_TEXT ON
GO
SELECT AVG(ListPrice) FROM Production.Product
GO
SET SHOWPLAN_TEXT OFF
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;In order to implement the &lt;strong&gt;AVG&lt;/strong&gt; aggregation function, the &lt;strong&gt;Stream Aggregate&lt;/strong&gt; is computing both a &lt;strong&gt;COUNT&lt;/strong&gt; and a &lt;strong&gt;SUM&lt;/strong&gt; aggregate, the results of which will be stored in the computed expressions &lt;strong&gt;Expr1003&lt;/strong&gt; and &lt;strong&gt;Expr1004&lt;/strong&gt;, respectively.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Compute Scalar&lt;/strong&gt; verifies that there is no division by zero by using a &lt;strong&gt;CASE&lt;/strong&gt; expression.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;group-by-clause&#34;&gt;Group By Clause&lt;/h3&gt;

&lt;p&gt;When using a GROUP BY clause, the input needs to be sorted first, if not an operator is introduced to sort the results first :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- now let’s see an example of a query using the GROUP BY clause
SELECT ProductLine, COUNT(*) FROM Production.Product
GROUP BY ProductLine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/group-by-aggregate.png&#34; alt=&#34;Group By&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The first query did not use a sort operator because without a &lt;strong&gt;GROUP BY&lt;/strong&gt; clause, the input is considered a single group.&lt;/p&gt;

&lt;h3 id=&#34;sort-with-an-index&#34;&gt;Sort with an Index&lt;/h3&gt;

&lt;p&gt;The Stream Aggregate can also use an index to provide sorted results :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- a Stream Aggregate can also use an index to have its input sorted, as in the following query
SELECT SalesOrderID, SUM(LineTotal)FROM Sales.SalesOrderDetail
GROUP BY SalesOrderID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/index-sort-aggregate.png&#34; alt=&#34;Index Sort&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No Sort operator is needed in this plan because the Clustered Index Scan provides the data already sorted by &lt;strong&gt;SalesOrderID&lt;/strong&gt;, which is part of the clustering key of the &lt;strong&gt;SalesOrderDetail&lt;/strong&gt; table&lt;/p&gt;

&lt;h3 id=&#34;hash-aggregate&#34;&gt;Hash Aggregate&lt;/h3&gt;

&lt;p&gt;Its implemented with the &lt;strong&gt;Hash Match&lt;/strong&gt; physical operator.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Works on unsorted data for big tables&lt;/li&gt;
&lt;li&gt;Cardinality estimates should produce few groups&lt;/li&gt;
&lt;li&gt;Builds a hash table in memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, the &lt;strong&gt;SalesOrderHeader&lt;/strong&gt; table has no index on the &lt;strong&gt;TerritoryID&lt;/strong&gt; column, so the following query will use a &lt;strong&gt;Hash Aggregate&lt;/strong&gt; operator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- for example, the SalesOrderHeader table has no index on the TerritoryID column, 
-- so the following query will use a Hash Aggregate operator
SELECT TerritoryID, COUNT(*)
FROM Sales.SalesOrderHeader
GROUP BY TerritoryID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and produces the following output :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/hash-aggregate.png&#34; alt=&#34;Hash Aggregate&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The algorithm for the Hash Aggregate operator is similar to the Stream Aggregate, with the exceptions that, in this case, the input data does not have to be sorted, a hash table is created in memory, and a hash value is calculated for each row processed.&lt;/p&gt;

&lt;p&gt;When data is sorted the optimizer might choose a stream aggregate instead, try the following :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- run the following statement to create an index
CREATE INDEX IX_TerritoryID ON Sales.SalesOrderHeader(TerritoryID)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and re-run the query. Notice the stream aggregate is now used, as the index is providing sorted input.&lt;/p&gt;

&lt;p&gt;Drop the index when done :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- to clean up, drop the index using the following DROP INDEX statement:
DROP INDEX Sales.SalesOrderHeader.IX_TerritoryID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the input is not sorted and order is explicitly requested in a query, the query optimizer may introduce a Sort operator and a Stream Aggregate, as shown previously, or it may decide to use a Hash Aggregate and then sort the results as in the following query :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- the query optimizer will estimate which operation is the least expensive
SELECT TerritoryID, COUNT(*)
FROM Sales.SalesOrderHeader
GROUP BY TerritoryID
ORDER BY TerritoryID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the plan produced :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/sort-with-hash-aggregate.png&#34; alt=&#34;Sort with Hash Aggregate&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;distinct-sort&#34;&gt;Distinct Sort&lt;/h3&gt;

&lt;p&gt;A query using the &lt;strong&gt;DISTINCT&lt;/strong&gt; keyword can be implemented by a :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stream Aggregate&lt;/li&gt;
&lt;li&gt;Hash Aggregate&lt;/li&gt;
&lt;li&gt;Distinct Sort operator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Distinct Sort operator is used to both remove duplicates and sort its input. In fact, a query using DISTINCT can be rewritten as a GROUP BY query, and both can generate the same execution plan.&lt;/p&gt;

&lt;p&gt;The following two queries return the same data and produce the same execution plan :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- the following two queries return the same data and produce the same execution plan
SELECT DISTINCT(JobTitle)
FROM HumanResources.Employee
GO
SELECT JobTitle
FROM HumanResources.Employee
GROUP BY JobTitle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/distinct-sort-operator.png&#34; alt=&#34;Distinct Sort&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note that the plan is using a Distinct Sort operator. This operator will sort the rows and eliminate duplicates.&lt;/p&gt;

&lt;p&gt;If we create an index, the query optimizer may instead use a Stream Aggregate operator because the plan can take advantage of the fact that the data is already sorted. To test it, run this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX IX_JobTitle ON HumanResources.Employee(JobTitle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the previous two queries again. Both queries will now produce a plan showing a Stream Aggregate operator. Drop the index before continuing by using this statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP INDEX HumanResources.Employee.IX_JobTitle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, for a bigger table without an index to provide order, a Hash Aggregate may be used, as in the two following examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- finally, for a bigger table without an index to provide order, a Hash Aggregate may be used, as in the two following examples:
SELECT DISTINCT(TerritoryID)
FROM Sales.SalesOrderHeader
GO
SELECT TerritoryID
FROM Sales.SalesOrderHeader
GROUP BY TerritoryID
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;join-operators&#34;&gt;Join Operators&lt;/h2&gt;

&lt;p&gt;SQL Server uses three physical join operators to implement joins :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nested Loops Join&lt;/li&gt;
&lt;li&gt;Merge Join&lt;/li&gt;
&lt;li&gt;Hash Join&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nested-loops-join&#34;&gt;Nested Loops Join&lt;/h3&gt;

&lt;p&gt;The optimizer uses the Nested Join for workloads with a small resultset. Lets us the following query and see the query plan :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT e.BusinessEntityID, TerritoryID
FROM HumanResources.Employee AS e
JOIN Sales.SalesPerson AS s ON e.BusinessEntityID = s.BusinessEntityID;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notes-of-the-nested-loop&#34;&gt;Notes of the Nested Loop&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Smaller results&lt;/li&gt;
&lt;li&gt;The operator used to access the outer input is executed only once&lt;/li&gt;
&lt;li&gt;The operator used to access the inner input is executed once for every record that qualifies on the outer input&lt;/li&gt;
&lt;li&gt;The outer table is shown on top in the graphical query plan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/nested-loop-join.png&#34; alt=&#34;Nested Loop&#34; /&gt;_&lt;/p&gt;

&lt;p&gt;This query produces a plan similar to the one shown previously using the SalesPerson as the outer input and a Clustered Index Seek on the Employee table as the inner input. The filter on the SalesPerson table is asking for TerritoryID equal to 1, and only three records qualify this time. As a result, the Clustered Index Seek, which is the operator on the inner input, is executed only three times. You can verify this information by looking at the properties of each operator, as we did for the previous query.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET STATISTICS PROFILE ON
GO
-- let’s change the query to add a filter by TerritoryID:
SELECT e.BusinessEntityID, HireDate
FROM HumanResources.Employee AS e
JOIN Sales.SalesPerson AS s ON e.BusinessEntityID = s.BusinessEntityID
WHERE TerritoryID = 1
GO
SET STATISTICS PROFILE OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/nested-loop-executions.png&#34; alt=&#34;Nested Loop Execution&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The query optimizer is more likely to choose a Nested Loops Join when the outer input is small and the inner input has an index on the join key. This join type can be especially effective when the inner input is potentially large, as only a few rows, indicated by the outer input, will be searched.&lt;/p&gt;

&lt;h3 id=&#34;merge-join&#34;&gt;Merge Join&lt;/h3&gt;

&lt;p&gt;the Mere Join have the following characteristics :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The optimizer chooses for medium workloads&lt;/li&gt;
&lt;li&gt;Requires sorted inputs&lt;/li&gt;
&lt;li&gt;Requires an equality operator&lt;/li&gt;
&lt;li&gt;Can use an index to provide sorted inputs&lt;/li&gt;
&lt;li&gt;Reads the inputs only once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets look at an example :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT h.SalesOrderID, s.SalesOrderDetailID, OrderDate
FROM Sales.SalesOrderHeader h
JOIN Sales.SalesOrderDetail s ON h.SalesOrderID = s.SalesOrderID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and produces the following plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/merge-join.png&#34; alt=&#34;Merge Join&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Taking benefit from the fact that both of its inputs are sorted on the join predicate, a Merge Join simultaneously reads a row from each input and compares them. If the rows match, they are returned. If the rows do not match, the smaller value can be discarded—because both inputs are sorted, the discarded row will not match any other row on the other input table.&lt;/p&gt;

&lt;p&gt;If the inputs are not already sorted, the query optimizer is not likely to choose a Merge Join. However, it might decide to sort one or even both inputs if it deems the cost is cheaper than the alternatives. Let’s follow an exercise to see what happens if we force a Merge Join on, for example, a Nested Loops join plan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- if you run the following query, you will notice that it uses a Nested Loops Join
SELECT * FROM Sales.SalesOrderDetail s
JOIN Production.Product p ON s.ProductID = p.ProductID
WHERE SalesOrderID = 43659
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and produces the following plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/nested-loop-merge-join.png&#34; alt=&#34;Nested loop&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this case, a good plan is created using efficient Clustered Index Seek operators. If we force a Merge Join using a hint, as in the following query, the query optimizer has to introduce sorted sources such as Clustered Index Scan and Sort operators, both of which can be seen on the plan&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- obviously, these additional operations are more expensive than a Clustered Index Seek
SELECT * FROM Sales.SalesOrderdetail s
JOIN Production.Product p ON s.ProductID = p.ProductID
WHERE SalesOrderID = 43659
OPTION (MERGE JOIN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces the following plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/merge-join-forced.png&#34; alt=&#34;Merge Join Forced&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In summary, given the nature of the Merge Join, the query optimizer is more likely to choose this algorithm when faced with medium to large inputs, where there is an equality operator on the join predicate, and the inputs are sorted.&lt;/p&gt;

&lt;h3 id=&#34;hash-join&#34;&gt;Hash Join&lt;/h3&gt;

&lt;p&gt;The query optimizer uses hash joins to process large, unsorted, non-indexed inputs efficiently. Lets run an example :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT h.SalesOrderID, s.SalesOrderDetailID FROM Sales.SalesOrderHeader h
JOIN Sales.SalesOrderDetail s ON h.SalesOrderID = s.SalesOrderID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces the following plan :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guides.peruzal.com/sql-server-performance-tuning-and-optimization/images/hash-match.png&#34; alt=&#34;Hash Match&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;characteristics&#34;&gt;Characteristics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The Hash Join requires an equality operator on the join predicate,&lt;/li&gt;
&lt;li&gt;Unlike the Merge Join, it does not require its inputs to be sorted&lt;/li&gt;
&lt;li&gt;In addition, the operations in both inputs are executed only once&lt;/li&gt;
&lt;li&gt;Hash Join works by creating a hash table in memory&lt;/li&gt;
&lt;li&gt;The query optimizer will use cardinality estimation to detect the smaller of the two inputs, called the &lt;strong&gt;build input&lt;/strong&gt;, and will use it to build a hash table in memory&lt;/li&gt;
&lt;li&gt;If there is not enough memory to host the hash table, SQL Server can use a &lt;strong&gt;workfile&lt;/strong&gt; in &lt;strong&gt;tempdb&lt;/strong&gt;, which can impact the performance of the query.&lt;/li&gt;
&lt;li&gt;A Hash Join is a blocking operation, but only during the time the build input is hashed&lt;/li&gt;
&lt;li&gt;After the build input is hashed, the second table, called the probe input, will be read and compared to the hash table&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In summary, the query optimizer can choose a Hash Join for large inputs where there is an equality operator on the join predicate. Because both tables are scanned, the cost of a Hash Join is the sum of both inputs.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms191158(v=sql.110).aspx&#34;&gt;https://msdn.microsoft.com/en-us/library/ms191158(v=sql.110).aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-query-optimizer-info-transact-sql&#34;&gt;https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-query-optimizer-info-transact-sql&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>