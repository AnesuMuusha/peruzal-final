<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xamarin iOS Guides</title>
    <link>http://guides.peruzal.com/ios-guides/index.xml</link>
    <description>Recent content on Xamarin iOS Guides</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Peruzal</copyright>
    <lastBuildDate>Mon, 12 Dec 2016 02:22:43 +0200</lastBuildDate>
    <atom:link href="http://guides.peruzal.com/ios-guides/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Multi-Threading</title>
      <link>http://guides.peruzal.com/ios-guides/multithreading/</link>
      <pubDate>Mon, 12 Dec 2016 02:22:43 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/multithreading/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Production applications will often need to perform heavier operations such as downloading high-resolution images or a executing non-cached database queries. To prevent stalling the main thread (and a hit in frame rate), Apple has provided a few tools to help you out! We&amp;rsquo;ll take a look at Grand Central Dispatch, &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/&#34;&gt;&lt;code&gt;NSOperation&lt;/code&gt;&lt;/a&gt;s, and the &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/occ/instm/NSObject/performSelectorInBackground:withObject:&#34;&gt;&lt;code&gt;performSelectorInBackground&lt;/code&gt;&lt;/a&gt; method on &lt;code&gt;NSObject&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;available-options&#34;&gt;Available Options&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Grand Central Dispatch

&lt;ul&gt;
&lt;li&gt;Grand Central Dispatch is a technology that abstracts away the low-level details of multithreading. When using GCD, you only have to think about the tasks you want to perform. These tasks can then be added to serial or concurrent queues. Moreover, you can add tasks to groups and run code after all tasks within the group complete!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSOperation&lt;/code&gt; and &lt;code&gt;NSOperationQueue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NSOperation&lt;/code&gt;s and &lt;code&gt;NSOperationQueue&lt;/code&gt;s provide you with a higher-level API, when compared to GCD. They were first introduced in iOS 4 and are actually implemented with GCD under the hood. Typically, you&amp;rsquo;ll want to use this API over GCD, unless you&amp;rsquo;re performing a simple unit of work on a specific queue. &lt;code&gt;NSOperation&lt;/code&gt;s provide you with powerful functionality such as cancellation and dependencies.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;performSelectorInBackground&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;If you need to perform a simple unit of work on a new thread, &lt;code&gt;NSObject&lt;/code&gt; provides you with
&lt;code&gt;performSelectorInBackground(_:withObject:)&lt;/code&gt;. Using this, you can run a function (with an argument) on a background thread.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;grand-central-dispatch&#34;&gt;Grand Central Dispatch&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://imgur.com/cjRYJZq.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s walk through an example where we download an image from a remote URL and then use it to populate a &lt;code&gt;UIImageView&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Assume we have an `imageView` property on self
private func loadWallpaper() {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) { [weak self] in
        guard
            let wallpaperURL = NSURL(string: &amp;quot;http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-157301.jpg&amp;quot;),
            let imageData = NSData(contentsOfURL: wallpaperURL)
        else {
            return
        }

        dispatch_async(dispatch_get_main_queue()) {
            self?.imageView.image = UIImage(data: imageData)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Most uses of GCD start with a call to &lt;code&gt;dispatch_async&lt;/code&gt;, which takes in a queue to use and the block to execute&lt;/li&gt;
&lt;li&gt;In our example, we&amp;rsquo;d like to execute the wallpaper download on a background queue, so we make use of the system-defined global queue with a background quality of service (QoS), &lt;code&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND&lt;/code&gt;.

&lt;ul&gt;
&lt;li&gt;The flag passed into &lt;code&gt;dispatch_get_global_queue&lt;/code&gt; should always be 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Now we have the block of work to execute

&lt;ul&gt;
&lt;li&gt;We construct a &lt;code&gt;NSURL&lt;/code&gt; via its failable &lt;code&gt;String&lt;/code&gt; initializer and then fetch the data associated with that resource via &lt;code&gt;NSData(contentsOfURL:)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If the above step completes successfully (else we just return from the block), we now have our data at hand!&lt;/li&gt;
&lt;li&gt;To update &lt;code&gt;imageView&lt;/code&gt;&amp;rsquo;s &lt;code&gt;image&lt;/code&gt; property, we need to make sure we return to the main thread via &lt;code&gt;dispatch_async(dispatch_get_main_queue()) { /* ... */ }&lt;/code&gt;. &lt;em&gt;Remember in iOS, all UI updates should be performed on the main thread&lt;/em&gt;. Inside the main thread block, we set the image using the &lt;code&gt;NSData&lt;/code&gt; initializer on &lt;code&gt;UIImage&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that we&amp;rsquo;ve seen a one-off block example, let&amp;rsquo;s dive into how you can accomplish groups of dependent tasks. Imagine you wanted to download multiple wallpapers and present an alert to the user when all of the images finish loading. Dispatch groups will be your best friends in these scenarios!&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s refactor the &lt;code&gt;loadWallpaper&lt;/code&gt; function from the previous example to accept a &lt;code&gt;dispatch_group_t&lt;/code&gt; and a target URL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private func loadWallpaper(group: dispatch_group_t, url: String) {
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) { [weak self] in
        defer {
            dispatch_group_leave(group)
        }

        guard
            let wallpaperURL = NSURL(string: url),
            let imageData = NSData(contentsOfURL: wallpaperURL)
        else {
            // In production scenarios, we would want error handing here
            return
        }

        // Use imageData in some manner, e.g. persisting to a cache, present in view hierarchy, etc.
        print(&amp;quot;Image downloaded \(url)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The function has been modified slightly to accept a parameter &lt;code&gt;group&lt;/code&gt; of type &lt;code&gt;dispatch_group_t&lt;/code&gt; (we&amp;rsquo;ll go into how to create these groups in the next snippet) and a target URL. Additionally, our previous call to &lt;code&gt;dispatch_async&lt;/code&gt; has been replaced with &lt;code&gt;dispatch_group_async&lt;/code&gt;, signaling that the block should be associated with &lt;code&gt;group&lt;/code&gt;. Lastly, after completing our work with the resulting &lt;code&gt;imageData&lt;/code&gt; we must notify &lt;code&gt;group&lt;/code&gt; that the block is complete via &lt;code&gt;dispatch_group_leave&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To use &lt;code&gt;loadWallpaper(_:url:)&lt;/code&gt; a call site could look like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private func fetchAllWallpapers() {
        let urls = [
            &amp;quot;http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-329991.jpg&amp;quot;,
            &amp;quot;http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-329805.jpg&amp;quot;,
            &amp;quot;http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-330201.jpg&amp;quot;
        ]

        let wallpaperGroup = dispatch_group_create()

        urls.forEach {
            dispatch_group_enter(wallpaperGroup)
            loadWallpaper(wallpaperGroup, url: $0)
        }

        dispatch_group_notify(wallpaperGroup, dispatch_get_main_queue()) { [weak self] in
            let alertController = UIAlertController(title: &amp;quot;Done!&amp;quot;, message: &amp;quot;All images have downloaded&amp;quot;, preferredStyle: .Alert)
            alertController.addAction(UIAlertAction(title: &amp;quot;OK&amp;quot;, style: .Default, handler: nil))

            self?.presentViewController(alertController, animated: true, completion: nil)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;We start by creating a dispatch group, &lt;code&gt;wallpaperGroup&lt;/code&gt;, using &lt;code&gt;dispatch_group_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;With the group in hand, we loop over all of the wallpaper URLs, first signaling to the group that we are about to start an operation by making a call to &lt;code&gt;dispatch_group_enter(wallpaperGroup)&lt;/code&gt; (each group entry call must pair with a group leave call). We then proceed to call &lt;code&gt;loadWallpaper(_:url:)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;To run code after completion of the group, we specify a block in a &lt;code&gt;dispatch_group_notify&lt;/code&gt; call. In our case, we&amp;rsquo;ll simply present a &lt;code&gt;UIAlertController&lt;/code&gt; letting the user know that all of the downloads have finished.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While GCD can be extremely powerful, it can be a bit cumbersome to work with in practice. To help with this, &lt;a href=&#34;https://github.com/beeth0ven&#34;&gt;Luo Jie&lt;/a&gt; came up with a &lt;a href=&#34;http://nshipster.com/new-years-2016/#swiftier-gcd&#34;&gt;Swifty GCD wrapper&lt;/a&gt; that I often use in my projects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol ExcutableQueue {
    var queue: dispatch_queue_t { get }
}

extension ExcutableQueue {
    func execute(closure: () -&amp;gt; Void) {
        dispatch_async(queue, closure)
    }
}

enum Queue: ExcutableQueue {
    case Main
    case UserInteractive
    case UserInitiated
    case Utility
    case Background

    var queue: dispatch_queue_t {
        switch self {
        case .Main:
            return dispatch_get_main_queue()
        case .UserInteractive:
            return dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0)
        case .UserInitiated:
            return dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0)
        case .Utility:
            return dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
        case .Background:
            return dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)
        }
    }
}

enum SerialQueue: String, ExcutableQueue {
    case DownLoadImage = &amp;quot;myApp.SerialQueue.DownLoadImage&amp;quot;
    case UpLoadFile = &amp;quot;myApp.SerialQueue.UpLoadFile&amp;quot;

    var queue: dispatch_queue_t {
        return dispatch_queue_create(rawValue, DISPATCH_QUEUE_SERIAL)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this wrapper, our example above could be rewritten as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Queue.Background.execute {
    guard
        let url = NSURL(string: &amp;quot;http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-157301.jpg&amp;quot;),
        let data = NSData(contentsOfURL: url)
    else {
        return
    }

    Queue.Main.execute { [weak self] in
        self?.imageView.image = UIImage(data: data)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nsoperation&#34;&gt;NSOperation&lt;/h3&gt;

&lt;p&gt;To start, we&amp;rsquo;ll port the wallpaper downloading example to use an &lt;code&gt;NSBlockOperation&lt;/code&gt;. &lt;code&gt;NSBlockOperation&lt;/code&gt; is a simple wrapper on a block of work that can be added to a queue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private func loadWallpaper(queue: NSOperationQueue, url: String) {
    guard let wallpaperURL = NSURL(string: url) else { return }

    let downloadOperation = NSBlockOperation {
        guard let imageData = NSData(contentsOfURL: wallpaperURL) else { return }

        NSOperationQueue.mainQueue().addOperationWithBlock { [weak self] in
            self?.imageView.image = UIImage(data: imageData)
        }
    }

    queue.addOperation(downloadOperation)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The initializer for &lt;code&gt;NSBlockOperation&lt;/code&gt; simply takes a block to run. In our case, we&amp;rsquo;ll download the data from &lt;code&gt;wallpaperURL&lt;/code&gt; and return to the main queue to set the &lt;code&gt;image&lt;/code&gt; property on &lt;code&gt;imageView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;After initializing &lt;code&gt;downloadOperation&lt;/code&gt;, we add it to &lt;code&gt;queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When creating an &lt;code&gt;NSOperationQueue&lt;/code&gt;, you have a few points of customization&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let queue = NSOperationQueue()
queue.maxConcurrentOperationCount = 1

// If you want to hold the queue, use the `suspended` property
queue.suspended = true
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;maxConcurrentOperationCount&lt;/code&gt; property allows you to set a limit on how many operations may run concurrently in a given queue. Setting this to 1, implies your queue will be serial (queing order may not be preserved, as operations only run when their &lt;code&gt;ready&lt;/code&gt; flag is set to true). If this property isn&amp;rsquo;t set, it defaults to &lt;code&gt;NSOperationQueueDefaultMaxConcurrentOperationCount&lt;/code&gt;, which is dictated by system conditions.&lt;/li&gt;
&lt;li&gt;By default, all operations that are ready (&lt;code&gt;ready&lt;/code&gt; property is true) are run when added to a queue. You can halt all execution on a queue by setting the &lt;code&gt;suspended&lt;/code&gt; property to true.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;NSOperation&lt;/code&gt;s become really powerful when you separate them out into operation subclasses. To demonstrate this, let&amp;rsquo;s make a wallpaper resizing operation. We&amp;rsquo;ll need to subclass a &lt;a href=&#34;https://gist.github.com/Jasdev/ba9f03747086d4939e55&#34;&gt;custom wrapper&lt;/a&gt; of &lt;code&gt;NSOperation&lt;/code&gt; that has the proper KVO notifications in place (see &amp;lsquo;Subclassing Notes&amp;rsquo; in the &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/&#34;&gt;docs&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ResizeImageOperation: Operation {

    enum Error {
        case FileReadError
        case ResizeError
        case WriteError
    }

    let targetSize: CGSize
    let path: NSURL
    var error: Error?

    init(size: CGSize, path: NSURL) {
        self.targetSize = size
        self.path = path
    }

    override func execute() {
        // Need to signal KVO notifications for operation completion
        defer {
            finish()
        }

        guard let sourceImage = UIImage(contentsOfFile: path.absoluteString) else {
            error = Error.FileReadError
            return
        }

        let finalWidth: CGFloat, finalHeight: CGFloat
        let ratio = sourceImage.size.width / sourceImage.size.height

        // Scale aspect fit the image
        if sourceImage.size.width &amp;gt;= sourceImage.size.height {
            finalWidth = targetSize.width
            finalHeight = finalWidth / ratio
        } else {
            finalHeight = targetSize.height
            finalWidth = finalHeight * ratio
        }

        let imageSize = CGSize(width: finalWidth, height: finalHeight)
        UIGraphicsBeginImageContextWithOptions(imageSize, true, 0.0)
        defer { UIGraphicsEndImageContext() }

        let rect = CGRect(origin: .zero, size: imageSize)
        sourceImage.drawInRect(rect)

        guard
            let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
            let imageData = UIImageJPEGRepresentation(resizedImage, 1.0)
        else {
            error = Error.ResizeError
            return
        }

        guard imageData.writeToFile(path.absoluteString, atomically: true) else {
            error = Error.WriteError
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;To help with error handling, we add a nested &lt;code&gt;Error&lt;/code&gt; enum with a few cases.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ResizeImageOperation&lt;/code&gt; can be initialized with a target size and path to write,&lt;/li&gt;
&lt;li&gt;The meat of the operation is placed in the &lt;code&gt;execute&lt;/code&gt; method (overridden from &lt;code&gt;Operation&lt;/code&gt;). We need to make sure to &lt;code&gt;defer&lt;/code&gt; a call to &lt;code&gt;finish()&lt;/code&gt;, so that the &lt;code&gt;Operation&lt;/code&gt; superclass can signal the proper KVO notifications.&lt;/li&gt;
&lt;li&gt;We then proceed with the resizing the image (scale aspect fit) and saving it to disk.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that we have a resizing operation in hand, let&amp;rsquo;s refactor our download operation a bit to work with it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private func downloadWallpaper(url: NSURL, path: NSURL) -&amp;gt; NSOperation {
    return NSBlockOperation {
        guard
            let imageData = NSData(contentsOfURL: url),
            let image = UIImage(data: imageData)
        else { return }

        UIImageJPEGRepresentation(image, 1.0)?.writeToFile(path.absoluteString, atomically: true)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;We now return an &lt;code&gt;NSOperation&lt;/code&gt; and have the operation write the image data to disk.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lastly, to make the download and resize operations dependent, we can use them like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Assume self has `imageView` and `wallpaperQueue` properties

if
    let cacheDirectory = NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true).first,
    let cacheDirectoryURL = NSURL(string: cacheDirectory)
{

    let targetURL = cacheDirectoryURL.URLByAppendingPathComponent(&amp;quot;wallpaper.jpg&amp;quot;)
    let downloadOperation = downloadWallpaper(NSURL(string: &amp;quot;http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-329991.jpg&amp;quot;)!, path: targetURL)

    let resizeOperation = ResizeImageOperation(size: CGSize(width: imageView.bounds.size.width * 2, height: imageView.bounds.size.height * 2), path: targetURL)
    resizeOperation.addDependency(downloadOperation)

    resizeOperation.completionBlock = { [weak self, weak resizeOperation] in
        if let error = resizeOperation?.error {
            print(error)
            return
        }

        guard
            let path = resizeOperation?.path,
            let imageData = NSData(contentsOfFile: path.absoluteString)
        else {
            return
        }

        NSOperationQueue.mainQueue().addOperationWithBlock {
            self?.imageView.image = UIImage(data: imageData)
        }
    }

    wallpaperQueue.suspended = true
    wallpaperQueue.addOperation(downloadOperation)
    wallpaperQueue.addOperation(resizeOperation)
    wallpaperQueue.suspended = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The key line to notice is &lt;code&gt;resizeOperation.addDependency(downloadOperation)&lt;/code&gt;. That&amp;rsquo;s how we express the resizing operation&amp;rsquo;s dependency on &lt;code&gt;downloadOperation&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Moreover, in the completion block of &lt;code&gt;resizeOperation&lt;/code&gt;, we check for errors and proceed with displaying the resized image.&lt;/li&gt;
&lt;li&gt;Note: we make sure to suspend the queue first, then add the operations. This prevents the operations from beginning immediately upon addition.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;performselectorinbackground&#34;&gt;PerformSelectorInBackground&lt;/h3&gt;

&lt;p&gt;To wrap up, let&amp;rsquo;s show a simple example of &lt;code&gt;performSelectorInBackground&lt;/code&gt;. Assuming &lt;code&gt;self&lt;/code&gt; has a method &lt;code&gt;sleepAndPrint(_:)&lt;/code&gt;, we can make the following call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;performSelectorInBackground(&amp;quot;sleepAndPrint:&amp;quot;, withObject: &amp;quot;supsup&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our target selector had no argument, the selector would simply be &lt;code&gt;&amp;quot;sleepAndPrint&amp;quot;&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sleepAndPrint(message: String) {
    NSThread.sleepForTimeInterval(1)
    print(message)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;key-takeaways&#34;&gt;Key Takeaways&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve used GCD, &lt;code&gt;NSoperation&lt;/code&gt;s, and &lt;code&gt;NSObject&lt;/code&gt;&amp;rsquo;s &lt;code&gt;performSelectorInBackground&lt;/code&gt; method as means of performing work in a multithreaded fashion. If you have small units of work to perform, you&amp;rsquo;ll want to reach for GCD or &lt;code&gt;performSelectorInBackground&lt;/code&gt;. On the other hand, if you have larger operations that may have dependencies, &lt;code&gt;NSOperation&lt;/code&gt; should be your tool of choice. For more info on these topics check out Apple&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html&#34;&gt;Thread Programming Guide&lt;/a&gt; and the WWDC 2015 session on &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2015-226/&#34;&gt;Advanced NSOperations&lt;/a&gt;!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/jasdev&#34;&gt;@jasdev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Model View Controller in Frameworks</title>
      <link>http://guides.peruzal.com/ios-guides/mvc/</link>
      <pubDate>Mon, 12 Dec 2016 02:20:42 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/mvc/</guid>
      <description>

&lt;p&gt;Most iOS apps follow the same basic structure and patterns.&lt;/p&gt;

&lt;h1 id=&#34;model-view-controller&#34;&gt;Model-View-Controller&lt;/h1&gt;

&lt;p&gt;Most of your code can be broken into three categories: model, view, controller.&lt;/p&gt;

&lt;h2 id=&#34;model&#34;&gt;Model&lt;/h2&gt;

&lt;p&gt;The model layer handles the important logic of your app. In a photo-sharing social network, it would include entities like &amp;ldquo;Users&amp;rdquo; and &amp;ldquo;Photos.&amp;rdquo; Often, the model handles storing data.&lt;/p&gt;

&lt;p&gt;The model should be presentation agnostic. A well designed model could be reused between iPhone, iPad, and Mac.&lt;/p&gt;

&lt;h2 id=&#34;view&#34;&gt;View&lt;/h2&gt;

&lt;p&gt;Everything involving UI and presentation falls into the view. UIKit provides the base classes, such as &lt;code&gt;UIView&lt;/code&gt;, &lt;code&gt;UIButton&lt;/code&gt;, and &lt;code&gt;UIImageView&lt;/code&gt;. You can subclass and create your own views, but the views provided by UIKit are highly customizable, and you should stick to them whenever possible.&lt;/p&gt;

&lt;h2 id=&#34;controller&#34;&gt;Controller&lt;/h2&gt;

&lt;p&gt;The controller sits between your model and view. When you tap a button, the view controller should handle the event and update the model. If the model updates, the view controller reflects this by updating the view.&lt;/p&gt;

&lt;p&gt;Each view controller usually correlates to one screen within your app. For instance, an email client would probably have an &lt;code&gt;AccountsListViewController&lt;/code&gt;. If you clicked on an account, it would push in to an &lt;code&gt;InboxViewController&lt;/code&gt;, which displays a list of emails. If you tapped an email, it would display the full email within an &lt;code&gt;EmailDetailsViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your view controllers will always subclass from &lt;code&gt;UIViewController&lt;/code&gt;, provided by UIKit. You can handle common events by overriding methods. For instance, if you want to start polling an endpoint when your view appears on screen, you could override &lt;code&gt;viewDidAppear(animated: Bool)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-app-delegate&#34;&gt;The App Delegate&lt;/h1&gt;

&lt;p&gt;If you want to hook into important events in the application lifecycle, you implement delegate methods in your app delegate. Events could include application launch, entering the background, and receiving incoming push notifications.&lt;/p&gt;

&lt;p&gt;For instance, if you want to execute code after the application launches, you override:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func application(application: UIApplication!, didFinishLaunchingWithOptions launchOptions: NSDictionary!) -&amp;gt; Bool {
  // Your code here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;services-and-extensions&#34;&gt;Services and Extensions&lt;/h1&gt;

&lt;p&gt;Your app may provide services to the OS, and other apps. For instance, you can register a custom URL scheme, so when someone launches, &lt;code&gt;myApp://home&lt;/code&gt;, it opens your app, and you present the user with their home screen. You can add this support by adding a few keys to your &lt;code&gt;Info.plist&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With iOS 8, there are a number of new extensions available. You can add content to Notification Center, provide custom keyboards, or add a new sharing option. These extensions are run independent of your main app, but they are bundled within your main app.&lt;/p&gt;

&lt;p&gt;More: &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionOverview.html&#34;&gt;Understand How an App Extension Works&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;system-frameworks&#34;&gt;System Frameworks&lt;/h1&gt;

&lt;p&gt;The more interesting functionality of the device is exposed to you via system frameworks. For instance, if you want to get the user&amp;rsquo;s current location, you only need to import the &lt;em&gt;Core Location&lt;/em&gt; framework, and write a few lines of code.&lt;/p&gt;

&lt;p&gt;You spend most of your time working with UIKit, which provides all the view classes. You&amp;rsquo;ll often work with Foundation, which provides the basic building blocks of the language, such as strings, numbers, arrays, dictionaries.&lt;/p&gt;

&lt;p&gt;Other interesting frameworks include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Address Book - Accessing the user&amp;rsquo;s contacts&lt;/li&gt;
&lt;li&gt;Map Kit - Displaying maps&lt;/li&gt;
&lt;li&gt;EventKit - Working with the user&amp;rsquo;s calendar&lt;/li&gt;
&lt;li&gt;Core Graphics - Drawing&lt;/li&gt;
&lt;li&gt;AVFoundation - Displaying audio and video&lt;/li&gt;
&lt;li&gt;Core Motion - Accesing accelerometer and gyroscope data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The higher level frameworks are usually exposed in Objective-C or Swift, higher level languages. Lower level APIs, such as Core Graphics, follow a C API.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/Introduction/Introduction.html&#34;&gt;iOS Technologies Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/miscellaneous/conceptual/iphoneostechoverview/iPhoneOSFrameworks/iPhoneOSFrameworks.html&#34;&gt;iOS Frameworks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/WhatAreFrameworks.html&#34;&gt;What are Frameworks?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;external-frameworks&#34;&gt;External Frameworks&lt;/h1&gt;

&lt;p&gt;If you&amp;rsquo;re coming from web or backend development, you&amp;rsquo;ll find yourself using fewer external libraries than you&amp;rsquo;re used to. You&amp;rsquo;ll find yourself getting surprisingly far with only the frameworks Apple provides. However, you will likely integrate an external library here and there to fill in gaps. It may be an open source library, or an internal library used by your company.&lt;/p&gt;

&lt;p&gt;The Apple-recommended solution is to use a dynamic framework. Dynamic frameworks behave similar to system frameworks, but you can bundle them alongside your app.&lt;/p&gt;

&lt;p&gt;A more extensive solution is the &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; open source project. This tool acts similar to Ruby&amp;rsquo;s &lt;em&gt;Bundler&lt;/em&gt;, allowing you to specify external dependencies in a &lt;code&gt;.podspec&lt;/code&gt; file, and run a single command to load them into your project.&lt;/p&gt;

&lt;p&gt;More: &lt;a href=&#34;http://subjectiveobserver.wordpress.com/2014/06/&#34;&gt;Framing Your Work&lt;/a&gt; - Bundling your work in a dynamic framework&lt;/p&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOS/index.html#//apple_ref/doc/uid/TP40011343&#34;&gt;Start Developing iOS Apps Today&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Working with Camera</title>
      <link>http://guides.peruzal.com/ios-guides/camera/</link>
      <pubDate>Mon, 12 Dec 2016 02:18:44 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/camera/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;This is a quickstart guide for using the taking a photo or picking an image from the camera roll using the stock camera and camera roll. In both cases, we&amp;rsquo;ll modally present the &lt;code&gt;UIImagePickerController&lt;/code&gt; class which has a delegate. The delegate has a method which is called after a user takes/picks a picture.&lt;/p&gt;

&lt;h2 id=&#34;taking-a-picture&#34;&gt;Taking a Picture&lt;/h2&gt;

&lt;h3 id=&#34;step-1-instantiate-a-uiimagepickercontroller&#34;&gt;Step 1: Instantiate a UIImagePickerController&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let vc = UIImagePickerController()
vc.delegate = self
vc.allowsEditing = true
vc.sourceType = UIImagePickerControllerSourceType.camera

self.present(vc, animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-2-implement-the-delegate&#34;&gt;Step 2: Implement the delegate&lt;/h3&gt;

&lt;p&gt;In the class interface, declare that it implements two protocols: &lt;code&gt;UIImagePickerControllerDelegate&lt;/code&gt; and &lt;code&gt;UINavigationControllerDelegate&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func imagePickerController(_ picker: UIImagePickerController, 
didFinishPickingMediaWithInfo info: [String : Any]) {
    // Get the image captured by the UIImagePickerController
    let originalImage = info[UIImagePickerControllerOriginalImage] as! UIImage
    let editedImage = info[UIImagePickerControllerEditedImage] as! UIImage

    // Do something with the images (based on your use case)

    // Dismiss UIImagePickerController to go back to your original view controller
    dismiss(animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the user finishes taking the picture, &lt;code&gt;UIImagePickerController&lt;/code&gt; returns a dictionary that contains the image and some other meta data. The full set of keys are listed &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIImagePickerControllerDelegate_Protocol/index.html#//apple_ref/doc/constant_group/Editing_Information_Keys&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;picking-a-picture-from-the-camera-roll&#34;&gt;Picking a Picture from the Camera Roll&lt;/h2&gt;

&lt;h3 id=&#34;step-1-instantiate-a-uiimagepickercontroller-1&#34;&gt;Step 1: Instantiate a UIImagePickerController&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let vc = UIImagePickerController()
vc.delegate = self
vc.allowsEditing = true
vc.sourceType = UIImagePickerControllerSourceType.photoLibrary

self.present(vc, animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-2-implement-the-delegate-1&#34;&gt;Step 2: Implement the delegate&lt;/h3&gt;

&lt;p&gt;This is the same as Step 2 above.&lt;/p&gt;

&lt;h2 id=&#34;things-to-keep-in-mind&#34;&gt;Things to Keep in Mind&lt;/h2&gt;

&lt;p&gt;Make sure you add &lt;code&gt;UIImagePickerControllerDelegate&lt;/code&gt; and &lt;code&gt;UINavigationControllerDelegate&lt;/code&gt; when defining your class&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with Location</title>
      <link>http://guides.peruzal.com/ios-guides/location/</link>
      <pubDate>Mon, 12 Dec 2016 02:18:10 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/location/</guid>
      <description>

&lt;h2 id=&#34;location&#34;&gt;Location&lt;/h2&gt;

&lt;h3 id=&#34;step-1-add-the-location-framework&#34;&gt;Step 1: Add the Location Framework&lt;/h3&gt;

&lt;p&gt;In build phases, add the location framework.&lt;/p&gt;

&lt;h3 id=&#34;step-2-identifying-the-desired-location-permission&#34;&gt;Step 2: Identifying the desired location permission&lt;/h3&gt;

&lt;p&gt;So the first thing you need to do is to add one or both of the following keys to your Info.plist file:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSLocationWhenInUseUsageDescription&lt;/li&gt;
&lt;li&gt;NSLocationAlwaysUsageDescription&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step-3-create-the-location-manager&#34;&gt;Step 3: Create the location manager&lt;/h3&gt;

&lt;p&gt;In the app delegate,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import CoreLocation

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    var locationManager: CLLocationManager! = CLLocationManager()

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-4-request-permission&#34;&gt;Step 4: Request permission&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;locationManager.requestAlwaysAuthorization()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-5-start-updating-location&#34;&gt;Step 5: Start Updating Location&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;locationManager.startUpdatingLocation()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-6-implement-location-delegate&#34;&gt;Step 6: Implement Location Delegate&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) {
    var location = locations[0] as CLLocation
    
    println(location)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ScrollView Guide</title>
      <link>http://guides.peruzal.com/ios-guides/scrollview/</link>
      <pubDate>Mon, 12 Dec 2016 02:13:41 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/scrollview/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Scroll views allow you to display content in an area on the screen that
is smaller than the size of the content.  They allow the user to pan
(scroll) and/or zoom the content.  The
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/index.html&#34;&gt;&lt;code&gt;UITableView&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/index.html#//apple_ref/occ/cl/UICollectionView&#34;&gt;&lt;code&gt;UICollectionView&lt;/code&gt;&lt;/a&gt;
are a subclasses of &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html&#34;&gt;&lt;code&gt;UIScrollView&lt;/code&gt;&lt;/a&gt;, so many of the
points below will apply to them as well.&lt;/p&gt;

&lt;h2 id=&#34;basic-usage&#34;&gt;Basic Usage&lt;/h2&gt;

&lt;h3 id=&#34;step-1-add-scroll-view-to-view-hierarchy&#34;&gt;Step 1: Add scroll view to view hierarchy&lt;/h3&gt;

&lt;p&gt;Add a scroll view to your view controller by dragging one from the
Object Library.  The size of the scroll view is the size of the area
that is visible to the user.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/oJzRkUE&#34;&gt;&lt;img src=&#34;http://i.imgur.com/oJzRkUE.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-2-set-content-size&#34;&gt;Step 2: Set content size&lt;/h3&gt;

&lt;p&gt;Tell the scroll view about the size of your content area by setting the
&lt;code&gt;contentSize&lt;/code&gt; property.  In this example the content has the same width
as the scroll view and three times its height.  The user will have to
scroll vertically to access the lower parts of the content area.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {
    @IBOutlet weak var scrollView: UIScrollView!

    override func viewDidLoad() {
        super.viewDidLoad()

        let contentWidth = scrollView.bounds.width
        let contentHeight = scrollView.bounds.height * 3
        scrollView.contentSize = CGSizeMake(contentWidth, contentHeight)
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-3-add-content-subviews&#34;&gt;Step 3. Add content subviews&lt;/h3&gt;

&lt;p&gt;What is shown in the scrollable content area of a scroll view is
determined by its subviews.  The frame of each subview is relative to
the top left of the content area.  A scroll view can contain more than
one subview.  In this example we add a series differently-colored
subviews.  Each subview has the same width as the scroll view, but we
offset the top of their frames so they do not overlap each other.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {
    @IBOutlet weak var scrollView: UIScrollView!

    override func viewDidLoad() {
        super.viewDidLoad()

        let contentWidth = scrollView.bounds.width
        let contentHeight = scrollView.bounds.height * 3
        scrollView.contentSize = CGSizeMake(contentWidth, contentHeight)

        let subviewHeight = CGFloat(120)
        var currentViewOffset = CGFloat(0);

        while currentViewOffset &amp;lt; contentHeight {
            let frame = CGRectMake(0, currentViewOffset, contentWidth, subviewHeight).rectByInsetting(dx: 5, dy: 5)
            let hue = currentViewOffset/contentHeight
            let subview = UIView(frame: frame)
            subview.backgroundColor = UIColor(hue: hue, saturation: 1, brightness: 1, alpha: 1)
            scrollView.addSubview(subview)

            currentViewOffset += subviewHeight
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what our example looks like when running:
&lt;a href=&#34;http://imgur.com/nLFfOM4&#34;&gt;&lt;img src=&#34;http://i.imgur.com/nLFfOM4.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;scrolling-programatically&#34;&gt;Scrolling programatically&lt;/h2&gt;

&lt;h3 id=&#34;set-content-offset&#34;&gt;Set content offset&lt;/h3&gt;

&lt;p&gt;You can programatically scroll the contents a scroll view by setting its
&lt;code&gt;contentOffset&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {
    @IBOutlet weak var scrollView: UIScrollView!

    ...

    @IBAction func didTapDownButton(sender: AnyObject) {
        let newOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y + 300)
        scrollView.setContentOffset(newOffset, animated: true)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/qtu6gAP&#34;&gt;&lt;img src=&#34;http://i.imgur.com/qtu6gAP.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;scrolling-to-a-a-subview&#34;&gt;Scrolling to a a subview&lt;/h3&gt;

&lt;p&gt;If you want to make sure a given view is visible on screen you can
you can use the &lt;code&gt;scrollRectToVisible&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {
    @IBOutlet weak var scrollView: UIScrollView!
    var grayView: UIView!

    override func viewDidLoad() {
        ...
        grayView = UIView(frame: CGRectMake(50, 620, scrollView.contentSize.width - 100, 150))
        grayView.backgroundColor = UIColor.grayColor()
        scrollView.addSubview(grayView)
    }

    @IBAction func didTapScrollButton(sender: AnyObject) {
        scrollView.scrollRectToVisible(grayView.frame, animated: true)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/uLlEhV5&#34;&gt;&lt;img src=&#34;http://i.imgur.com/uLlEhV5.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-paging-mode&#34;&gt;Using paging mode&lt;/h2&gt;

&lt;h3 id=&#34;enabling-paging&#34;&gt;Enabling paging&lt;/h3&gt;

&lt;p&gt;You can force the scroll view to to snap to &amp;ldquo;page&amp;rdquo; boundaries by setting
the &lt;code&gt;pagingEnabled&lt;/code&gt; property.  The size of a page is equal to the size
of the scroll view.  You&amp;rsquo;ll generally want to disable to scroll
indicators when paging is enabled.  Here we allow the user to
horizontally page through three views.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UIScrollViewDelegate {
    @IBOutlet weak var scrollView: UIScrollView!

    override func viewDidLoad() {
        super.viewDidLoad()

        let pageWidth = scrollView.bounds.width
        let pageHeight = scrollView.bounds.height

        scrollView.contentSize = CGSizeMake(3*pageWidth, pageHeight)
        scrollView.pagingEnabled = true
        scrollView.showsHorizontalScrollIndicator = false

        let view1 = UIView(frame: CGRectMake(0, 0, pageWidth, pageHeight))
        view1.backgroundColor = UIColor.blueColor()
        let view2 = UIView(frame: CGRectMake(pageWidth, 0, pageWidth, pageHeight))
        view2.backgroundColor = UIColor.orangeColor()
        let view3 = UIView(frame: CGRectMake(2*pageWidth, 0, pageWidth, pageHeight))
        view3.backgroundColor = UIColor.purpleColor()

        scrollView.addSubview(view1)
        scrollView.addSubview(view2)
        scrollView.addSubview(view3)

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-a-page-control&#34;&gt;Adding a page control&lt;/h3&gt;

&lt;p&gt;The paging behavior is often combined with a &lt;code&gt;UIPageControl&lt;/code&gt; that
displays a dot for each page and allows the user to switch pages by
tapping.  This behavior can be achieved by implementing the
&lt;code&gt;UIScrollViewDelegate&lt;/code&gt; and adding an action handler for the page
control.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UIScrollViewDelegate {
    @IBOutlet weak var scrollView: UIScrollView!
    @IBOutlet weak var pageControl: UIPageControl!

    override func viewDidLoad() {
        ...
        scrollView.delegate = self
        pageControl.numberOfPages = 3
    }

    @IBAction func pageControlDidPage(sender: AnyObject) {
        let xOffset = scrollView.bounds.width * CGFloat(pageControl.currentPage)
        scrollView.setContentOffset(CGPointMake(xOffset,0) , animated: true)
    }

    func scrollViewDidEndDecelerating(scrollView: UIScrollView) {
        pageControl.currentPage = Int(scrollView.contentOffset.x / scrollView.bounds.width)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/PFnCulU&#34;&gt;&lt;img src=&#34;http://i.imgur.com/PFnCulU.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pinch-to-zoom&#34;&gt;Pinch to zoom&lt;/h2&gt;

&lt;p&gt;Basic zooming behavior via pinch gestures is provided by the scroll view
if you implement the &lt;code&gt;viewForZoomingInScrollView&lt;/code&gt; delegate method.
Since a scroll view can have more than one subview, this method will
identify which view will be zoomed when the pinch gesture fires.  You&amp;rsquo;ll
also need to set the &lt;code&gt;minimumZoomScale&lt;/code&gt; and &lt;code&gt;maximumZoomScale&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UIScrollViewDelegate {
    @IBOutlet weak var scrollView: UIScrollView!
    var imageView: UIImageView!

    override func viewDidLoad() {
        super.viewDidLoad()
        scrollView.delegate = self
        scrollView.minimumZoomScale = 0.25
        scrollView.maximumZoomScale = 2

        let image = UIImage(named: &amp;quot;romanesco-broccoli&amp;quot;)
        imageView = UIImageView(image: image)
        scrollView.contentSize = image!.size
        scrollView.addSubview(imageView)
        scrollView.zoomScale = 0.5
    }

    func viewForZoomingInScrollView(scrollView: UIScrollView) -&amp;gt; UIView? {
        return imageView
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/xmLhLet&#34;&gt;&lt;img src=&#34;http://i.imgur.com/xmLhLet.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-scroll-views-with-auto-layout&#34;&gt;Using scroll views with auto layout&lt;/h2&gt;

&lt;p&gt;As noted &lt;a href=&#34;#basic-usage&#34;&gt;above&lt;/a&gt;, there are two sizes that are relevant
when working with a scroll view:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the scroll view&amp;rsquo;s (frame) size.  This determines how the scroll view
fits inside its parent view and its size as it appears on the screen to the user.&lt;/li&gt;
&lt;li&gt;the scroll view&amp;rsquo;s &lt;em&gt;content size&lt;/em&gt;.  This determines the size of
available to the scrollable content within the scroll view.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In order to use a scroll view with auto layout you must still specify
&lt;em&gt;both&lt;/em&gt; of these sizes.&lt;/p&gt;

&lt;p&gt;One approach to accomplishing this is to use auto layout constraints
&lt;em&gt;only&lt;/em&gt; to determine the scroll view&amp;rsquo;s size relative to its parents and
neighbors.  The content size and size of subviews inside the scroll
view are still set programatically as we have been doing throughout this
guide.&lt;/p&gt;

&lt;p&gt;A second approach uses only Auto Layout constraints.  In particular,
this means there must be a way for Auto Layout to specify the content
size of a scroll view.  Altogether, the constraints must be enough to
determine three things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The size of the scroll view.  You can use the pin and align tools to
create constraints to parent and sibling views.  Unlike other views,
you cannot rely on the size of child views of the scroll view here.&lt;/li&gt;
&lt;li&gt;The content size of the scroll view.  This is specified by creating
constraints between the scroll view&amp;rsquo;s edges and the &lt;em&gt;subviews within&lt;/em&gt;
the scroll view.  Note that these constraints have a different
meaning than normal constraints between a parent view and its child
views.  The only size being determined here is the &lt;em&gt;content size&lt;/em&gt; of the
scroll view.&lt;/li&gt;
&lt;li&gt;Finally you must set constraints to determine the size of the actual
subviews containing the scrollable content.
&lt;strong&gt;These constraints cannot depend on the edges of the scroll
view&lt;/strong&gt;&amp;mdash;since as we just saw, they would then be interpreted as
constraints on the content size.  It is typical here to set a fixed size
for a single main scrollable subview and to place other views inside this
subview.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A comprehensive discussion of this topic can be found &lt;a href=&#34;https://developer.apple.com/library/ios/technotes/tn2154/_index.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Search Bar Controller</title>
      <link>http://guides.peruzal.com/ios-guides/searchbar/</link>
      <pubDate>Mon, 12 Dec 2016 02:09:57 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/searchbar/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://imgur.com/8YFquIY&#34;&gt;&lt;img src=&#34;http://i.imgur.com/8YFquIY.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Providing a way for users to search through a collection of items is a
fairly common task in iOS projects.  A standard interface for
implementing search behaviors is the &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/UIKitUICatalog/UISearchBar.html#//apple_ref/doc/uid/TP40012857-UISearchBar-SW1&#34;&gt;search bar&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are a few common ways to work with Search Bars:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Directly using a &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchBar_Class/&#34;&gt;&lt;code&gt;UISearchBar&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.  This is the most
bare bones way to use &lt;code&gt;UISearchBars&lt;/code&gt;.  This can be extremely flexible if
you want to design and program your own search interface, however does
not provide as many built-in features as the other methods.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Using a &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UISearchDisplayController_Class/&#34;&gt;&lt;code&gt;UISearchDisplayController&lt;/code&gt;&lt;/a&gt; to
help manage a search interface.&lt;/strong&gt;  The &lt;code&gt;UISearchDisplayController&lt;/code&gt;
allows you to present a standard search interface with built-in
animations.  This method forces you to display search results in a table
view. - &lt;strong&gt;DEPRECATED&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Using a &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchController/&#34;&gt;&lt;code&gt;UISearchController&lt;/code&gt;&lt;/a&gt; to help manage a
search interface.&lt;/strong&gt;  The &lt;code&gt;UISearchController&lt;/code&gt;  is a newer controller
(available only in iOS 8+) that helps you present a search interface
using any kind of view to display the search results.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This guide covers the very basics of working with each of these classes.
None of these classes actually implements the &amp;ldquo;searching&amp;rdquo; behavior of
finding items that match a given query string, since determining which
objects match will vary with the domain specific use case (e.g. when
searching for &amp;ldquo;people&amp;rdquo; you might want to match on just their names,
whereas you may want a full-text pre-indexed search when searching
through e-mails).  You&amp;rsquo;ll have to implement any search/filtering
behavior yourself.&lt;/p&gt;

&lt;h2 id=&#34;working-with-uisearchbars-directly&#34;&gt;Working with UISearchBars directly&lt;/h2&gt;

&lt;p&gt;At its core, a search bar is nothing more than a glorified text field
packaged with a &lt;a href=&#34;#search-bar-scopes&#34;&gt;scope&lt;/a&gt; control and some animations
and a couple of buttons.  Each search bar has a delegate that gives you
an opportunity to respond to user actions.  The most important delegate
methods are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchBarDelegate_Protocol/index.html#//apple_ref/occ/intfm/UISearchBarDelegate/searchBar:textDidChange:&#34;&gt;&lt;code&gt;textDidChange&lt;/code&gt;&lt;/a&gt; - most of the time you&amp;rsquo;ll respond to
this event by updating the displayed set of search results as the user
is typing out a query&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchBarDelegate_Protocol/index.html#//apple_ref/occ/intfm/UISearchBarDelegate/searchBarSearchButtonClicked:&#34;&gt;&lt;code&gt;searchBarSearchButtonClicked&lt;/code&gt;&lt;/a&gt; - in some cases
if the search operation is slow (e.g. requires making a slow API call)
you&amp;rsquo;ll want to wait until the user taps the search button before
updating the search results.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-searching-a-table&#34;&gt;Example searching a table&lt;/h3&gt;

&lt;p&gt;We start out with a single view application with &lt;a href=&#34;Table-View-Guide#reusing-uitableviewcells&#34;&gt;a basic
UITableView&lt;/a&gt;.  You can add a
&lt;code&gt;UISearchBar&lt;/code&gt; as you would with any other control by dragging one to
your view controller in interface builder or by programmatically adding
it.&lt;/p&gt;

&lt;p&gt;The delegate property of search bar must be set to an object that
implements UISearchBarDelegate. Typically you make your view controller
implement UISearchBarDelegate and set &lt;code&gt;searchBar.delegate = self&lt;/code&gt;
in &lt;code&gt;viewDidLoad&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/TbVI3Yv&#34;&gt;&lt;img src=&#34;http://i.imgur.com/TbVI3Yv.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The code to implement the search behavior is as follows.  We maintain an
additional array &lt;code&gt;filteredData&lt;/code&gt; to represent rows of data that match our
search text.  When the search text changes we update &lt;code&gt;filteredData&lt;/code&gt; and
reload our table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource, UISearchBarDelegate {
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var searchBar: UISearchBar!

    let data = [&amp;quot;New York, NY&amp;quot;, &amp;quot;Los Angeles, CA&amp;quot;, &amp;quot;Chicago, IL&amp;quot;, &amp;quot;Houston, TX&amp;quot;,
        &amp;quot;Philadelphia, PA&amp;quot;, &amp;quot;Phoenix, AZ&amp;quot;, &amp;quot;San Diego, CA&amp;quot;, &amp;quot;San Antonio, TX&amp;quot;,
        &amp;quot;Dallas, TX&amp;quot;, &amp;quot;Detroit, MI&amp;quot;, &amp;quot;San Jose, CA&amp;quot;, &amp;quot;Indianapolis, IN&amp;quot;,
        &amp;quot;Jacksonville, FL&amp;quot;, &amp;quot;San Francisco, CA&amp;quot;, &amp;quot;Columbus, OH&amp;quot;, &amp;quot;Austin, TX&amp;quot;,
        &amp;quot;Memphis, TN&amp;quot;, &amp;quot;Baltimore, MD&amp;quot;, &amp;quot;Charlotte, ND&amp;quot;, &amp;quot;Fort Worth, TX&amp;quot;]

    var filteredData: [String]!

    override func viewDidLoad() {
        super.viewDidLoad()
        tableView.dataSource = self
        searchBar.delegate = self
        filteredData = data
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;TableCell&amp;quot;, for: indexPath) as UITableViewCell
        cell.textLabel?.text = filteredData[indexPath.row]
        return cell
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return filteredData.count
    }

    // This method updates filteredData based on the text in the Search Box
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        // When there is no text, filteredData is the same as the original data
        // When user has entered text into the search box
        // Use the filter method to iterate over all items in the data array
        // For each item, return true if the item should be included and false if the
        // item should NOT be included
        filteredData = searchText.isEmpty ? data : data.filter({(dataString: String) -&amp;gt; Bool in
            // If dataItem matches the searchText, return true to include it
            return dataString.range(of: searchText, options: .caseInsensitive) != nil
        })
        
        tableView.reloadData()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what this looks like when running.  Notice that the search
results are displayed in the same table, and there is no presentation of
a separate search interface.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/xDqRQEJ&#34;&gt;&lt;img src=&#34;http://i.imgur.com/xDqRQEJ.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;example-searching-a-collection-view&#34;&gt;Example searching a collection view&lt;/h3&gt;

&lt;p&gt;Since the &lt;code&gt;UISearchBar&lt;/code&gt; is quite simple, it can be combined with any
abitrary view to build your own search interface.  Here&amp;rsquo;s what it might
look like paired with a collection view.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/PKY6m7O&#34;&gt;&lt;img src=&#34;http://i.imgur.com/PKY6m7O.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The code for this is essentially the same as in the case with table views.&lt;/p&gt;

&lt;h3 id=&#34;cancelling-out-of-search-and-hiding-keyboard&#34;&gt;Cancelling out of Search and hiding keyboard&lt;/h3&gt;

&lt;p&gt;Once user taps on search bar, the keyboard will appear, and you will notice
that it won&amp;rsquo;t go away when you tap on X.
You can show Cancel button when user taps on search bar, and when user taps
on Cancel, hide the keyboard.&lt;/p&gt;

&lt;p&gt;There is a nifty &lt;code&gt;searchBarTextDidBeginEditing&lt;/code&gt; method for UISearchBarDelegate
that gets called when user starts editing search text. You can show Cancel
button in that method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        self.searchBar.showsCancelButton = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When user taps on cancel button, delegate&amp;rsquo;s &lt;code&gt;searchBarCancelButtonClicked&lt;/code&gt;
method gets called. At this point, you can hide the Cancel button,
clear existing text in search bar and hide the keyboard like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        searchBar.showsCancelButton = false
        searchBar.text = &amp;quot;&amp;quot;
        searchBar.resignFirstResponder()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-uisearchcontrollers-ios-8&#34;&gt;Using UISearchControllers (iOS 8+)&lt;/h2&gt;

&lt;p&gt;A newer way to manage the presentation of a search interface (only
available in iOS 8 and above) is via the &lt;code&gt;UISearchController&lt;/code&gt;.  This
controller handles some of the logic and animation of presenting a
separate search interface for you while still allowing you to specify
how your search results are displayed.&lt;/p&gt;

&lt;h3 id=&#34;example-searching-a-table-1&#34;&gt;Example searching a table&lt;/h3&gt;

&lt;p&gt;There is currently no built-in object in the Interface Builder Object
Library for a &lt;code&gt;UISearchController&lt;/code&gt;.  The easiest way to create one is to
do it programatically.  This also creates a &lt;code&gt;UISearchBar&lt;/code&gt; and sets the
search controller&amp;rsquo;s
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchController/#//apple_ref/occ/instp/UISearchController/searchBar&#34;&gt;&lt;code&gt;searchBar&lt;/code&gt;&lt;/a&gt;
property to it.  You can add this search bar to your view hierarchy
programatically.&lt;/p&gt;

&lt;p&gt;In order to update your search results you&amp;rsquo;ll have to implement the
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchResultsUpdating_ClassRef/&#34;&gt;&lt;code&gt;UISearchResultsUpdating&lt;/code&gt;&lt;/a&gt;
protocol and set the search controller&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchController/#//apple_ref/occ/instp/UISearchController/searchResultsUpdater&#34;&gt;&lt;code&gt;searchResultsUpdater&lt;/code&gt;&lt;/a&gt; property.&lt;/p&gt;

&lt;p&gt;You don&amp;rsquo;t need to implement the
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISearchControllerDelegate_Ref/index.html#//apple_ref/swift/intf/UISearchControllerDelegate&#34;&gt;&lt;code&gt;UISearchControllerDelegate&lt;/code&gt;&lt;/a&gt;
unless you need to hook into the events around the presentation of the
search interface.&lt;/p&gt;

&lt;p&gt;Putting it all together the code looks like this.  Notice that we have
to read the search text from the search bar in
&lt;code&gt;updateSearchResultsForSearchController&lt;/code&gt;.  One other thing to note is
that we set this view controller&amp;rsquo;s &lt;code&gt;definesPresentationContext&lt;/code&gt; property
to true.  This means that the search controller should use this view
controller&amp;rsquo;s frame (as oppposed to the root view controller) when
presenting the search interface.  In this case it means that the search
interface will expand above the carrier bar.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource, UISearchResultsUpdating {
    @IBOutlet weak var tableView: UITableView!

    let data = [&amp;quot;New York, NY&amp;quot;, &amp;quot;Los Angeles, CA&amp;quot;, &amp;quot;Chicago, IL&amp;quot;, &amp;quot;Houston, TX&amp;quot;,
        &amp;quot;Philadelphia, PA&amp;quot;, &amp;quot;Phoenix, AZ&amp;quot;, &amp;quot;San Diego, CA&amp;quot;, &amp;quot;San Antonio, TX&amp;quot;,
        &amp;quot;Dallas, TX&amp;quot;, &amp;quot;Detroit, MI&amp;quot;, &amp;quot;San Jose, CA&amp;quot;, &amp;quot;Indianapolis, IN&amp;quot;,
        &amp;quot;Jacksonville, FL&amp;quot;, &amp;quot;San Francisco, CA&amp;quot;, &amp;quot;Columbus, OH&amp;quot;, &amp;quot;Austin, TX&amp;quot;,
        &amp;quot;Memphis, TN&amp;quot;, &amp;quot;Baltimore, MD&amp;quot;, &amp;quot;Charlotte, ND&amp;quot;, &amp;quot;Fort Worth, TX&amp;quot;]

    var filteredData: [String]!

    var searchController: UISearchController!

    override func viewDidLoad() {
        super.viewDidLoad()

        tableView.dataSource = self
        filteredData = data

        // Initializing with searchResultsController set to nil means that
        // searchController will use this view controller to display the search results
        searchController = UISearchController(searchResultsController: nil)
        searchController.searchResultsUpdater = self

        // If we are using this same view controller to present the results
        // dimming it out wouldn&#39;t make sense. Should probably only set
        // this to yes if using another controller to display the search results.
        searchController.dimsBackgroundDuringPresentation = false

        searchController.searchBar.sizeToFit()
        tableView.tableHeaderView = searchController.searchBar

        // Sets this view controller as presenting view controller for the search interface
        definesPresentationContext = true
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;TableCell&amp;quot;) as UITableViewCell
        cell.textLabel?.text = filteredData[indexPath.row]
        return cell
    }

    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return filteredData.count
    }

    func updateSearchResultsForSearchController(searchController: UISearchController) {
        if let searchText = searchController.searchBar.text {
            filteredData = searchText.isEmpty ? data : data.filter({(dataString: String) -&amp;gt; Bool in
                return dataString.rangeOfString(searchText, options: .CaseInsensitiveSearch) != nil
            })

            tableView.reloadData()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what this looks like when running.  Notice that unlike in the
search display controller example, we are using the same table view to
display the search results instead of overlaying of a separate table
view.  However, unlike when working with just the search bar, we still
have the built in animation when transitioning to the search interface.&lt;/p&gt;

&lt;p&gt;Also, you get the logic to show Cancel button and hide keyboard when
user taps on cancel button for free when you use this.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/AgUYVoN&#34;&gt;&lt;img src=&#34;http://i.imgur.com/AgUYVoN.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;example-searching-a-collection-view-1&#34;&gt;Example searching a collection view&lt;/h3&gt;

&lt;p&gt;We can just as easily use the search controller to search a collection
view in place.   We still have the presentation of a search interface,
but unlike when working with the search display controller we are not
restricted to using a table view to display the search results.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/ZEyaPyz&#34;&gt;&lt;img src=&#34;http://i.imgur.com/ZEyaPyz.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The code for this is almost the same as when searching the the table
view above.  The only notable difference is that we had to introduce a
placeholder view in interface builder for the search bar since there are
still some quirks with placing a search controller&amp;rsquo;s search bar inside a
collection view&amp;rsquo;s supplementary view.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UICollectionViewDataSource, UISearchResultsUpdating {
    @IBOutlet weak var collectionView: UICollectionView!
    @IBOutlet weak var searchBarPlaceholder: UIView!
    ...
    override func viewDidLoad() {
        ...
        searchController.searchBar.sizeToFit()
        searchBarPlaceholder.addSubview(searchController.searchBar)
        automaticallyAdjustsScrollViewInsets = false
        definesPresentationContext = true
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;search-bar-in-navigation-view&#34;&gt;Search Bar in Navigation View&lt;/h2&gt;

&lt;p&gt;A common requirement is to place the search bar inside the navigation
bar.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/RDnRxNO&#34;&gt;&lt;img src=&#34;http://i.imgur.com/RDnRxNO.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This can be configured programatically in your view controller&amp;rsquo;s
&lt;code&gt;viewDidLoad&lt;/code&gt; as follows.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;When working directly with a search bar:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        // create the search bar programatically since you won&#39;t be
        // able to drag one onto the navigation bar
        searchBar = UISearchBar()
        searchBar.sizeToFit()

        // the UIViewController comes with a navigationItem property
        // this will automatically be initialized for you if when the
        // view controller is added to a navigation controller&#39;s stack
        // you just need to set the titleView to be the search bar
        navigationItem.titleView = searchBar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Using a search display controller:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        searchDisplayController?.displaysSearchBarInNavigationBar = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Using a search controller:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        searchController.searchBar.sizeToFit()
        navigationItem.titleView = searchController.searchBar

        // By default the navigation bar hides when presenting the
        // search interface.  Obviously we don&#39;t want this to happen if
        // our search bar is inside the navigation bar.
        searchController.hidesNavigationBarDuringPresentation = false
&lt;/code&gt;&lt;/pre&gt;

&lt;!--
Search Bar Scopes
--&gt;
</description>
    </item>
    
    <item>
      <title>Handling Form Input</title>
      <link>http://guides.peruzal.com/ios-guides/form-input/</link>
      <pubDate>Mon, 12 Dec 2016 02:04:33 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/form-input/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;This guide covers how to handle basic form input in iOS.&lt;/p&gt;

&lt;p&gt;Unlike &lt;a href=&#34;http://www.w3.org/TR/html4/interact/forms.html#adef-action&#34;&gt;HTML forms&lt;/a&gt;, in iOS there is no standard &lt;a href=&#34;http://www.w3.org/TR/html4/interact/forms.html#adef-action&#34;&gt;form
submission action&lt;/a&gt;.  This means that it is up to you to
define &lt;em&gt;when&lt;/em&gt; a form&amp;rsquo;s contents should be processed.  It also means that
you are responsible for &lt;em&gt;how&lt;/em&gt; to translate a form&amp;rsquo;s state into
meaningful information for the the application&amp;rsquo;s
&lt;a href=&#34;Application-Architecture#models&#34;&gt;models&lt;/a&gt;, and vice versa.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll focus on the very common use case of embedding form inputs in a
table view.  This will allow us to highlight some points that require
extra care when working with inputs in iOS.  For example, if the table
view uses &lt;a href=&#34;Table-View-Guide#reusing-uitableviewcells&#34;&gt;reusable cells&lt;/a&gt;, a
cell containing a form input may be removed from memory as soon as it
disappears from the screen when the user scrolls the table.  This means
that you cannot necessarily rely on the state of the form itself to
store information the user has input.  We&amp;rsquo;ll cover how to overcome this and
other problems below.&lt;/p&gt;

&lt;p&gt;Here is a typical example of form inputs in a table view:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/e4vUMW4&#34;&gt;&lt;img src=&#34;http://i.imgur.com/e4vUMW4.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;static-forms&#34;&gt;Static Forms&lt;/h2&gt;

&lt;p&gt;One way to avoid some complexity when working with form input in a table
view is to use &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/TableView_iPhone/TableViewCells/TableViewCells.html#//apple_ref/doc/uid/TP40007451-CH7-SW20&#34;&gt;static cells&lt;/a&gt;.  However, this is only
applicable when using Interface Builder and when your table view is
backed by a
&lt;a href=&#34;Table-View-Guide#uitableview-vs-uitableviewcontroller&#34;&gt;UITableViewController&lt;/a&gt;.
Additionally you should only use static cells when the structure of your
forms will never change.&lt;/p&gt;

&lt;p&gt;To create a table with static cells you&amp;rsquo;ll need to drag a &lt;code&gt;Table View
Controller&lt;/code&gt; into the scene from the Object Library and set &lt;code&gt;Content&lt;/code&gt; to
&lt;code&gt;Static Cells&lt;/code&gt; in the Attributes Inspector.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/dtxyIoX&#34;&gt;&lt;img src=&#34;http://i.imgur.com/dtxyIoX.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can now control the number of sections in your table and the the
number of cells by selecting either the &amp;ldquo;Table View&amp;rdquo; or &amp;ldquo;Section&amp;rdquo; in the
Outline view and using the Attributes Inspector.  Using Interface
Builder you can now design each individual cell as it would appear in
your app.  You can also connect the controls in your cells to
&lt;code&gt;@IBOutlets&lt;/code&gt; and &lt;code&gt;@IBActions&lt;/code&gt; in your UITableViewController&amp;rsquo;s
corresponding subclass.  Since there is no danger of static cells being
removed from memory when they scroll off screen, you can choose whenever
you want to process the information from any form inputs into useful
information for the rest of your app.&lt;/p&gt;

&lt;h3 id=&#34;example-basic-preferences-page&#34;&gt;Example: Basic preferences page&lt;/h3&gt;

&lt;p&gt;Here is how we might implement a simple preferences page for an app.  To
demonstrate the fact that the preferences will be used in the rest of
the app we have a main &lt;code&gt;ViewController&lt;/code&gt; that initializes and displays
the preferences.  It has an &amp;ldquo;Edit Preferences&amp;rdquo; button that will open up
our &lt;code&gt;PreferencesTableViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NB: In practice, you might instead opt to use the &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html#//apple_ref/doc/uid/10000059i-CH6-SW5&#34;&gt;iOS Settings
Bundle&lt;/a&gt; feature when creating a preferences page.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/jt3Pmf6&#34;&gt;&lt;img src=&#34;http://i.imgur.com/jt3Pmf6.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The preferences table has three &lt;em&gt;static&lt;/em&gt; cells each containing a single
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UISwitch_Class/index.html&#34;&gt;switch&lt;/a&gt; corresponding to an on/off preference.  The swiches
are connected to &lt;code&gt;@IBOutlets&lt;/code&gt; in our &lt;code&gt;PreferencesTableViewController&lt;/code&gt;.
The preferences table view controller also has &amp;ldquo;Save&amp;rdquo; and &amp;ldquo;Cancel&amp;rdquo;
buttons connected to unwind segues in our main &lt;code&gt;ViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/rF4Ww3W&#34;&gt;&lt;img src=&#34;http://i.imgur.com/rF4Ww3W.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Preferences&lt;/code&gt; class provides us with a model to store the
preferences.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Preferences {
   var autoRefresh = true, playSounds = true, showPhotos = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our preferences table view controller we initialize the state of the
switches to match the current preferences&amp;mdash;which will be set by our
main view controller.&lt;/p&gt;

&lt;p&gt;Notice that when a switch is toggled, we do not mutate the current
preferences since we might still cancel our changes.  Instead we provide
a way to create a new &lt;code&gt;Preferences&lt;/code&gt; object from the current state of the
switches in the UI with the &lt;code&gt;preferencesFromTableData&lt;/code&gt; method.  We&amp;rsquo;ll use this
method in the unwind segue associated with the &amp;ldquo;Save&amp;rdquo; button.&lt;/p&gt;

&lt;p&gt;We can wait to convert the state of the switches (as they appear in the
UI) to a &lt;code&gt;Preferences&lt;/code&gt; object until we are ready to save because we are
using &lt;em&gt;static cells&lt;/em&gt;.  This means that the cells do not get allocated
and removed from memory dynamically and that we can obtain &lt;code&gt;@IBOutlets&lt;/code&gt;
to controls inside each specific cell.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

class PreferencesTableViewController: UITableViewController {

    @IBOutlet weak var autoRefreshSwitch: UISwitch!
    @IBOutlet weak var soundsSwitch: UISwitch!
    @IBOutlet weak var showPhotosSwitch: UISwitch!

    // should be set by the class that instantiates this view controller
    var currentPrefs: Preferences!

    override func viewDidLoad() {
        super.viewDidLoad()
        currentPrefs = currentPrefs ?? Preferences()
        initSwitches()
    }

    private func initSwitches() {
        autoRefreshSwitch?.on = currentPrefs.autoRefresh
        soundsSwitch?.on = currentPrefs.playSounds
        showPhotosSwitch?.on = currentPrefs.showPhotos
    }

    func preferencesFromTableData() -&amp;gt; Preferences {
        var newPrefs = Preferences()
        newPrefs.autoRefresh = autoRefreshSwitch.on
        newPrefs.playSounds = soundsSwitch.on
        newPrefs.showPhotos = showPhotosSwitch.on
        return newPrefs
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our main &lt;code&gt;ViewController&lt;/code&gt; we set up the
&lt;code&gt;PreferencesTableViewController&lt;/code&gt; with the current preferences before our
segue.  When coming back from the segue via the &amp;ldquo;Save&amp;rdquo; button we read
off the new preferences from the switches and update our &lt;code&gt;preferences&lt;/code&gt;
object.  We don&amp;rsquo;t take any action if the edit was &amp;ldquo;Canceled&amp;rdquo; because the
&lt;code&gt;PreferencesTableViewController&lt;/code&gt; does not modify the &lt;code&gt;preferences&lt;/code&gt;
object we pass in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {

    @IBOutlet weak var autoRefreshLabel: UILabel!
    @IBOutlet weak var playSoundsLabel: UILabel!
    @IBOutlet weak var showPhotosLabel: UILabel!

    var preferences: Preferences = Preferences() {
        didSet {
            updateLabels()
        }
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        updateLabels()
    }

    private func updateLabels() {
        autoRefreshLabel.text = preferences.autoRefresh ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;
        playSoundsLabel.text = preferences.playSounds ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;
        showPhotosLabel.text = preferences.showPhotos ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;
    }

    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if segue.identifier == &amp;quot;showPreferencesSegue&amp;quot; {
            // we wrapped our PreferencesTableViewController inside a UINavigationController
            let navController = segue.destinationViewController as UINavigationController
            let prefsVC = navController.topViewController as PreferencesTableViewController
            prefsVC.currentPrefs = self.preferences
        }
    }

    @IBAction func didSavePreferences(segue: UIStoryboardSegue) {
        if let prefsVC = segue.sourceViewController as? PreferencesTableViewController {
            self.preferences = prefsVC.preferencesFromTableData()
        }
    }

    @IBAction func didCancelPreferences(segue: UIStoryboardSegue) {
        // do nothing
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dynamic-forms&#34;&gt;Dynamic Forms&lt;/h2&gt;

&lt;p&gt;Static cells are quite limited because single &lt;code&gt;UITableView&lt;/code&gt; has to
contain either &lt;em&gt;all static cells&lt;/em&gt; or have &lt;em&gt;all&lt;/em&gt; of its content be
provided dynamically.  For example it would not be possible to use
static cells if the number of rows in &lt;em&gt;any&lt;/em&gt; section of your table was
based on data loaded at runtime.&lt;/p&gt;

&lt;p&gt;Furthermore, you can only use static cells in Interface Builder and when
your table view is backed by &lt;code&gt;UITableViewController&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;challenges-of-tables-with-dynamically-created-form-inputs&#34;&gt;Challenges of tables with dynamically created form inputs&lt;/h3&gt;

&lt;p&gt;There are a few additional challenges to overcome when working with form
inputs in a table with dynamic content:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Since the cells are dynamically allocated, &lt;em&gt;inside your view
controller&lt;/em&gt; there is no way to obtain &lt;code&gt;@IBOutlets&lt;/code&gt; to an form input
inside a specific cell.  You must arrange a way for the cells to read
the state of its own form inputs and for the view controller to get this
information from the cell.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Likewise, if your view controller needs to respond to events from an
individual cell, you must arrange a way for the cell to propagate the
event to the view controller.  You cannot simply associate an
&lt;code&gt;@IBAction&lt;/code&gt; inside the view controller with an element inside a specific
cell.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generally you&amp;rsquo;ll be getting reusable cells to configure by calling
&lt;code&gt;dequeueReusableCellWithIdentifier&lt;/code&gt;.  This means you cannot rely on
the information contained in the form inputs in an individual cell to
persist when it scrolls off screen.  You will have to maintain all the
information necessary to populate the state of all form inputs in each
cell somewhere else.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You&amp;rsquo;ll also have to update this information immediately if the user
interacts with the cell because, again, the form input itself cannot be
used to to store information once the cell is no longer on the screen.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your form is used for editing data and provides a &amp;ldquo;Cancel&amp;rdquo; option,
you must maintain an additional copy of the data seperate from the
initial data and seperate from the current value inside the form inputs.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;example-basic-preferences-page-revisited&#34;&gt;Example: Basic preferences page revisited&lt;/h3&gt;

&lt;p&gt;To see how these factors come into play, we&amp;rsquo;ll reimplement our basic
preferences page example from &lt;a href=&#34;#example-basic-preferences-page&#34;&gt;above&lt;/a&gt;
to use dynamically created cells based on &lt;a href=&#34;Table-View-Guide#using-prototype-cells&#34;&gt;prototype
cells&lt;/a&gt; instead of static cells.&lt;/p&gt;

&lt;p&gt;As before we have a main &lt;code&gt;ViewController&lt;/code&gt; displays the current
preferences and has an &amp;ldquo;Edit Preferences&amp;rdquo; button that does a modal segue
to our &lt;code&gt;PreferencesViewController&lt;/code&gt;.  The &lt;code&gt;ViewController&lt;/code&gt; class also
contains &lt;code&gt;@IBActions&lt;/code&gt; for unwind segues that happen when the user either
saves or cancels editing preferences.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/8nbwUnu&#34;&gt;&lt;img src=&#34;http://i.imgur.com/8nbwUnu.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We renamed our &lt;code&gt;PreferencesTableViewController&lt;/code&gt; to
&lt;code&gt;PreferencesViewController&lt;/code&gt;.  It no longer has to be a subclass of
&lt;code&gt;UITableViewController&lt;/code&gt;, and instead it only implements the
&lt;code&gt;UITableViewDataSource&lt;/code&gt; protocol.  Other than replacing this type name,
the code in our &lt;code&gt;ViewController&lt;/code&gt; class remains the same as above.  The
code for our &lt;code&gt;Preferences&lt;/code&gt; model has not changed from above at all.&lt;/p&gt;

&lt;p&gt;The bulk of our changes are in &lt;code&gt;PreferencesViewController&lt;/code&gt;.  We need to
maintain the temporary state of our table as we are editing our
preferences outside of the cells themselves.  We introduce two
properties &lt;code&gt;tableStructure&lt;/code&gt; and &lt;code&gt;prefValues&lt;/code&gt; to keep track of this
state.&lt;/p&gt;

&lt;p&gt;We write logic to convert a &lt;code&gt;Preferences&lt;/code&gt; object into our &lt;code&gt;prefValues&lt;/code&gt;.
This allow us to update the &lt;code&gt;prefValues&lt;/code&gt; to store the state of table as
we are editing without modifying the original &lt;code&gt;Preferences&lt;/code&gt; object that
is passed in.  Likewise we have a procedure to obtain a new &lt;code&gt;Preferences&lt;/code&gt;
object from the &lt;code&gt;prefValues&lt;/code&gt;.  This allows the rest of the application
to obtain an updated &lt;code&gt;Preferences&lt;/code&gt; once the user hits &amp;ldquo;Save&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum PrefRowIdentifier : String {
    case AutoRefresh = &amp;quot;Auto Refresh&amp;quot;
    case PlaySounds = &amp;quot;Play Sounds&amp;quot;
    case ShowPhotos = &amp;quot;Show Photos&amp;quot;
}

class PreferencesViewController: UIViewController, UITableViewDataSource, PreferenceSwitchCellDelegate {
    @IBOutlet weak var tableView: UITableView!
    let tableStructure: [[PrefRowIdentifier]] = [[.AutoRefresh], [.PlaySounds, .ShowPhotos]]
    var prefValues: [PrefRowIdentifier: Bool] = [:]

    // should be set by the class that instantiates this view controller
    var currentPrefs: Preferences! {
        didSet {
            prefValues[.AutoRefresh] = currentPrefs.autoRefresh
            prefValues[.PlaySounds] = currentPrefs.playSounds
            prefValues[.ShowPhotos] = currentPrefs.showPhotos
            tableView?.reloadData()
        }
    }

    func preferencesFromTableData() -&amp;gt; Preferences {
        let ret = Preferences()
        ret.autoRefresh = prefValues[.AutoRefresh] ?? ret.autoRefresh
        ret.playSounds = prefValues[.PlaySounds] ?? ret.playSounds
        ret.showPhotos = prefValues[.ShowPhotos] ?? ret.showPhotos
        return ret
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        currentPrefs = currentPrefs ?? Preferences()
        tableView.dataSource = self
    }

    func numberOfSectionsInTableView(tableView: UITableView) -&amp;gt; Int {
        return tableStructure.count
    }

    func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -&amp;gt; String? {
        return &amp;quot; &amp;quot;
    }

    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return tableStructure[section].count
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;PreferenceSwitchCell&amp;quot;) as PreferenceSwitchCell
        let prefIdentifier = tableStructure[indexPath.section][indexPath.row]
        cell.prefRowIdentifier = prefIdentifier
        cell.onOffSwitch.on = prefValues[prefIdentifier]!
        cell.delegate = self
        return cell
    }

    func preferenceSwitchCellDidToggle(cell: PreferenceSwitchCell, newValue: Bool) {
        prefValues[cell.prefRowIdentifier] = newValue
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;!--- TODO link to delegate pattern --&gt;

&lt;p&gt;Finally we need a way for our custom cell containing a single switch to
know which preference it represents and to notify our view controller
immediately once its switch is toggled.  We do this by implementing a
custom &lt;code&gt;PreferenceSwitchCell&lt;/code&gt; class with a corresponding delegate
&lt;code&gt;PreferenceSwitchCellDelegate&lt;/code&gt; that is implemented by our
&lt;code&gt;PreferencesViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The action of the switch in our protoype cell is connected to our code
in &lt;code&gt;PreferenceSwitchCell&lt;/code&gt; by an &lt;code&gt;@IBAction&lt;/code&gt;.  We notify our view
controller once this event is triggered by propagating the change
through the delegate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol PreferenceSwitchCellDelegate: class {
    func preferenceSwitchCellDidToggle(cell: PreferenceSwitchCell, newValue:Bool)
}

class PreferenceSwitchCell: UITableViewCell {
    @IBOutlet weak var descriptionLabel: UILabel!
    @IBOutlet weak var onOffSwitch: UISwitch!

    weak var delegate: PreferenceSwitchCellDelegate?

    var prefRowIdentifier: PrefRowIdentifier! {
        didSet {
            descriptionLabel?.text = prefRowIdentifier?.rawValue
        }
    }

    @IBAction func didToggleSwitch(sender: AnyObject) {
        delegate?.preferenceSwitchCellDidToggle(self, newValue: onOffSwitch.on)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;!---
### Example: Multi-Select with Dynamic Content

### Example: Drop-Down Select
--&gt;
</description>
    </item>
    
    <item>
      <title>Passing Data between View Controllers</title>
      <link>http://guides.peruzal.com/ios-guides/passing-data/</link>
      <pubDate>Mon, 12 Dec 2016 02:03:30 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/passing-data/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;While your application runs, as &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html&#34;&gt;events are triggered and
processed&lt;/a&gt;, you&amp;rsquo;ll need a way for objects in your
application to propagate these events and to get the data they need from
each other in order to respond properly.&lt;/p&gt;

&lt;p&gt;In iOS, there are quite a few standard ways to pass data and propagate
events between objects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Delegate pattern&lt;/li&gt;
&lt;li&gt;Passing blocks (closures) around&lt;/li&gt;
&lt;li&gt;Target-Action pattern&lt;/li&gt;
&lt;li&gt;Publish/Subscribe message bus with &lt;code&gt;NSNotificationCenter&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This guide gives an high-level overview of each of these mechanisms with
a focus on passing data and propagating events between two different
view controllers and between view controllers and views.  Generally when
working with view controllers and views, the following steps are typical&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A view controller &lt;code&gt;VC1&lt;/code&gt; configures a view or another view controller
&lt;code&gt;V2&lt;/code&gt;.  This can be done by calling an initializer or by
obtaining a reference to and setting properties on &lt;code&gt;V2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second view or view controller &lt;code&gt;V2&lt;/code&gt; is loaded and shown on the
screen.  Additionally &lt;code&gt;V2&lt;/code&gt; may request more information from &lt;code&gt;VC1&lt;/code&gt;
while it&amp;rsquo;s on the screen.&lt;/li&gt;
&lt;li&gt;The user triggers an event in &lt;code&gt;V2&lt;/code&gt; that needs to be handled in &lt;code&gt;VC1&lt;/code&gt;.
This means that &lt;code&gt;V2&lt;/code&gt; will need to propagate the event and possibly
send some information about it&amp;rsquo;s current state to &lt;code&gt;VC1&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;basic-example&#34;&gt;Basic example&lt;/h2&gt;

&lt;p&gt;To demonstrate this basic use case, we&amp;rsquo;ll use a standard example
throughout. We&amp;rsquo;ll build a demo app that lets the user change the
background color of the main view controller by opening up a secondary
color picker view controller.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/XgIWavY&#34;&gt;&lt;img src=&#34;http://i.imgur.com/XgIWavY.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;delegate-pattern&#34;&gt;Delegate Pattern&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html&#34;&gt;delegate pattern&lt;/a&gt; is a common pattern in iOS. It can be used to communicate events between multiple
view controllers, between view controllers and views, etc. If you&amp;rsquo;ve implemented a TableView, then you&amp;rsquo;ve used the delegate pattern when you implemented &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol&#34;&gt;UITableViewDataSource&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDelegate_Protocol&#34;&gt;UITableViewDelegate&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It can be really useful to create your own delegate. To do so, requires the following 4 steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create a &lt;a href=&#34;http://guides.codepath.com/ios/Understanding-Swift#protocols&#34;&gt;protocol&lt;/a&gt; that has methods for each event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol ColorPickerDelegate: class {
    func colorPicker(picker: ColorPickerViewController, didPickColor color: UIColor?)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the source class, create a property to hold a reference to the listener.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ColorPickerViewController: UIViewController {
    weak var delegate: ColorPickerDelegate?

    // ... Rest of class ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the source class, call the appropriate delegate method when an event occurs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ColorPickerViewController: UIViewController {

    weak var delegate: ColorPickerDelegate?

    @IBOutlet weak var colorsSegmentedControl: UISegmentedControl!

    let colors = [(&amp;quot;Cyan&amp;quot;, UIColor.cyanColor()),  (&amp;quot;Magenta&amp;quot;, UIColor.magentaColor()), (&amp;quot;Yellow&amp;quot;, UIColor.yellowColor())]

    override func viewDidLoad() {
        super.viewDidLoad()

        // initialize segmented control and select the starting color if it is one of our segments
        colorsSegmentedControl.removeAllSegments()
        var selectedIndex = UISegmentedControlNoSegment

        for (index, color) in colors.enumerate() {
            if color.1.isEqual(initialColor) {
                selectedIndex = index
            }
            colorsSegmentedControl.insertSegmentWithTitle(color.0, atIndex: index, animated: false)
        }
        colorsSegmentedControl.selectedSegmentIndex = selectedIndex
    }

    func colorFromSelection() -&amp;gt; UIColor? {
        let selectedIndex = colorsSegmentedControl.selectedSegmentIndex
        if selectedIndex != UISegmentedControlNoSegment {
            return colors[selectedIndex].1
        }
        return nil
    }

    @IBAction func doneButtonTapped(sender: AnyObject) {
        delegate?.colorPicker(self, didPickColor: colorFromSelection())
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the listening class, implement the protocol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, ColorPickerDelegate {
    @IBAction func openColorPickerTapped(sender: AnyObject) {
        let storyboard = UIStoryboard(name: &amp;quot;Main&amp;quot;, bundle: NSBundle.mainBundle())
        let colorPickerVC = storyboard.instantiateViewControllerWithIdentifier(&amp;quot;ColorPicker&amp;quot;) as ColorPickerViewController
        colorPickerVC.delegate = self
        presentViewController(colorPickerVC, animated: true, completion: nil)
    }

    func colorPicker(picker: ColorPickerViewController, didPickColor color: UIColor?) {
        if let selectedColor = color {
            view.backgroundColor = selectedColor
        }
        dismissViewControllerAnimated(true, completion: nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;passing-blocks&#34;&gt;Passing blocks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html&#34;&gt;Closures in Swift&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html&#34;&gt;blocks in
Objective-C&lt;/a&gt; are first class concepts.  This means
that you can pass closures as parameters and assign them to variables to
be exectuted later.  These concepts allow you to implement a basic
callback mechanism that can be used to propagate and pass on the
responsibility of handling an event.&lt;/p&gt;

&lt;p&gt;Passing blocks is common in iOS frameworks and libraries where a single
callback (as opposed to a protocol containing many methods used with
delegates) is required.  It also provides the advantage of being able to
define the closure inline so that it &lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_%28computer_programming%29&#34;&gt;closes over&lt;/a&gt; the
current environment and hence you will have access to any variables that
are currently in scope.&lt;/p&gt;

&lt;p&gt;An example of an iOS library that uses blocks is
&lt;a href=&#34;Network-Programming#nsurlconnection&#34;&gt;&lt;code&gt;NSURLConnection&lt;/code&gt;&lt;/a&gt;.  It allows you
to specify a block that will be executed asynchronously when a network
request returns.  Another example is the
&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/#//apple_ref/occ/instm/NSNotificationCenter/addObserverForName:object:queue:usingBlock:&#34;&gt;&lt;code&gt;NSNotificationCenter.addObserverForName:object:queue:usingBlock:&lt;/code&gt;&lt;/a&gt;
method called &lt;a href=&#34;#broadcasting-messages-with-nsnotificationcenter&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One downside to using blocks is that it may be difficult to get
the type definitions correct for complicated closures having optionals,
collection types, or other closures as parameters or return values.&lt;/p&gt;

&lt;p&gt;We can see block callbacks in action continuing with our &lt;a href=&#34;#basic-example&#34;&gt;running
example&lt;/a&gt;.  We still have our &lt;code&gt;ViewController&lt;/code&gt;
instantiate and configure the &lt;code&gt;ColorPickerViewController&lt;/code&gt;.  The
&lt;code&gt;ColorPickerViewController&lt;/code&gt; now has a &lt;code&gt;doneHandler&lt;/code&gt; which we set to be a
block that calls our method &lt;code&gt;didPickColor&lt;/code&gt;.  We present the
&lt;code&gt;ColorPickerViewController&lt;/code&gt; to the user after finishing our
configuration.&lt;/p&gt;

&lt;p&gt;As before, the method &lt;code&gt;didPickColor&lt;/code&gt; updates our background color and
dismisses the &lt;code&gt;ColorPickerViewController&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {
    @IBAction func openColorPickerTapped(sender: AnyObject) {
        let storyboard = UIStoryboard(name: &amp;quot;Main&amp;quot;, bundle: NSBundle.mainBundle())
        let colorPickerVC = storyboard.instantiateViewControllerWithIdentifier(&amp;quot;ColorPicker&amp;quot;) as ColorPickerViewController
        colorPickerVC.doneHandler = {(color: UIColor?) -&amp;gt; Void in
            self.didPickColor(color)
        }

        presentViewController(colorPickerVC, animated: true, completion: nil)
    }

    func didPickColor(color: UIColor?) {
        if let selectedColor = color {
            view.backgroundColor = selectedColor
        }
        dismissViewControllerAnimated(true, completion: nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;ColorPickerViewController&lt;/code&gt; we propagate the action of the user
clicking on the &amp;ldquo;Done&amp;rdquo; button to &lt;code&gt;ViewController&lt;/code&gt; by executing the
&lt;code&gt;doneHandler&lt;/code&gt; that was set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ColorPickerViewController: UIViewController {
    @IBOutlet weak var colorsSegmentedControl: UISegmentedControl!

    let colors = [(&amp;quot;Cyan&amp;quot;, UIColor.cyanColor()),  (&amp;quot;Magenta&amp;quot;, UIColor.magentaColor()), (&amp;quot;Yellow&amp;quot;, UIColor.yellowColor())]
    var doneHandler: ((UIColor?) -&amp;gt; Void)?

    override func viewDidLoad() {
        super.viewDidLoad()

        // initalize segmented control and select the starting color if it is one of our segments
        colorsSegmentedControl.removeAllSegments()
        var selectedIndex = UISegmentedControlNoSegment

        for (index, color) in enumerate(colors) {
            if color.1.isEqual(initialColor) {
                selectedIndex = index
            }
            colorsSegmentedControl.insertSegmentWithTitle(color.0, atIndex: index, animated: false)
        }
        colorsSegmentedControl.selectedSegmentIndex = selectedIndex
    }

    func colorFromSelection() -&amp;gt; UIColor? {
        let selectedIndex = colorsSegmentedControl.selectedSegmentIndex
        if selectedIndex != UISegmentedControlNoSegment {
            return colors[selectedIndex].1
        }
        return nil
    }

    @IBAction func doneButtonTapped(sender: AnyObject) {
        doneHandler?(colorFromSelection())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-target-action-pattern&#34;&gt;The target-action pattern&lt;/h2&gt;

&lt;p&gt;An another construct used to propagate events in iOS is the
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html&#34;&gt;target-action&lt;/a&gt; pattern.  This is an older Objective-C
pattern that allows a class to register a method (&lt;em&gt;action&lt;/em&gt; or
&lt;em&gt;selector&lt;/em&gt;) to be executed on some object (&lt;em&gt;target&lt;/em&gt;) at some point
later.  This pattern is used throughout many iOS libraries for example
the following code tells the &lt;code&gt;button&lt;/code&gt; to call &lt;code&gt;self.onButtonTap()&lt;/code&gt; when
it is tapped.&lt;/p&gt;

&lt;p&gt;This pattern is pretty much the same as creating an &lt;code&gt;@IBAction&lt;/code&gt;
from the interface builder in XCode; however, this is done in code.
It&amp;rsquo;s used when you have to dynamically create view objects in code
and add actions to it based on control events.&lt;/p&gt;

&lt;p&gt;In the following example, you&amp;rsquo;re creating a button dynamically in
code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class CodePathViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        let button = UIButton()
        button.addTarget(self, action: &amp;quot;onButtonTap&amp;quot;, forControlEvents: .TouchUpInside)
        button.frame = CGRectMake(0, 0, 300, 500)

        //Add button to the view
        self.view.addSubview(letterButton)
    }

    func onButtonTap() {
        print(&amp;quot;Button Tapped!&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the parameters of &lt;code&gt;addTarget&lt;/code&gt; method:
* target - (&lt;strong&gt;Who to tell&lt;/strong&gt;) The target parameter is the object that is going to respond to the control event.
           In this case, the event is &lt;code&gt;.TouchUpInside&lt;/code&gt; (Tap). Usually, the target is the
           object of the ViewController class in which the button was created.
           In the example, we reference the object of the ViewController class with the
           keyword &lt;code&gt;self&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;action - (&lt;strong&gt;What to tell them&lt;/strong&gt;) The action parameter is simply the name of the method that needs to be invoked in
       the target object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;forControlEvents - (&lt;strong&gt;When to tell them&lt;/strong&gt;) This is where you pass the type of event for your button.
                 Here&amp;rsquo;s a list of &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIControl_Class/index.html#//apple_ref/doc/constant_group/Control_Events&#34;&gt;events&lt;/a&gt; you can use for UIButton.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To simplify, in the above example, we let the button know that it has to call the instance
method &lt;code&gt;onButtonTap&lt;/code&gt; of the class &lt;code&gt;CodePathViewController&lt;/code&gt; when it is tapped.&lt;/p&gt;

&lt;p&gt;One downside is that its is not easy to use the target-action pattern to invoke methods
that require two or more parameters.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: rewrite example in Objective-C to use target-action pattern&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;broadcasting-messages-with-nsnotificationcenter&#34;&gt;Broadcasting messages with &lt;code&gt;NSNotificationCenter&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Finally, iOS provides a mechanism for implementing a basic
subcribe/publish message queue via &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationCenters.html&#34;&gt;notification
centers&lt;/a&gt;.  The basic usage is&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define an identifer to name this particular type of notification&lt;/li&gt;
&lt;li&gt;Subscribe to this kind of notification by adding an observer to a
notification center for notifications with the given name.  You can
instatiate new notification centers, but it is common to use
&lt;code&gt;NSNotificationCenter.defaultCenter&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Publish notifications to the notification center.  You might include
additional data in a &lt;code&gt;userInfo&lt;/code&gt; dictionary.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;NSNotificationCenter&lt;/code&gt; API is normally used to handle app-wide
events that may be relevant to multiple interested&amp;mdash;possibly
unrelated&amp;mdash;view controllers (e.g. the logged in state of a user).
It is not normally used to pass information between two specific view
controllers.  Nevertheless, we can adapt it our &lt;a href=&#34;#basic-example&#34;&gt;running
example&lt;/a&gt; as follows.&lt;/p&gt;

&lt;p&gt;We define &lt;code&gt;ColorPickerNotification&lt;/code&gt; as an identifier that will be used
as the name for notifications from our &lt;code&gt;ColorPickerViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;ViewController&lt;/code&gt;, before presenting the &lt;code&gt;ColorPickerViewController&lt;/code&gt;,
we register an observer for notifications with this name.  In the block
that is triggered when the notification fires, we extract the selected
color from the &lt;code&gt;userInfo&lt;/code&gt; dictionary and call &lt;code&gt;didPickColor&lt;/code&gt;.  The
&lt;code&gt;didPickColor&lt;/code&gt; method sets the background color and dismisses the
&lt;code&gt;ColorPickerViewController&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController {

    @IBAction func openColorPickerTapped(sender: AnyObject) {
        let storyboard = UIStoryboard(name: &amp;quot;Main&amp;quot;, bundle: NSBundle.mainBundle())
        let colorPickerVC = storyboard.instantiateViewControllerWithIdentifier(&amp;quot;ColorPicker&amp;quot;) as ColorPickerViewController
        colorPickerVC.initialColor = view.backgroundColor

        NSNotificationCenter.defaultCenter().addObserverForName(ColorPickerNotification, object: nil, queue: NSOperationQueue.mainQueue()) { (notification: NSNotification!) -&amp;gt; Void in
            let userInfo = notification?.userInfo
            let selectedColor: UIColor? = userInfo?[ColorPickerSelectedColorKey] as? UIColor
            self.didPickColor(selectedColor)

        }

        presentViewController(colorPickerVC, animated: true, completion: nil)
    }

    func didPickColor(color: UIColor?) {
        if let selectedColor = color {
            view.backgroundColor = selectedColor
        }
        dismissViewControllerAnimated(true, completion: nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;ColorPickerViewController&lt;/code&gt;, when the &amp;ldquo;Done&amp;rdquo; button is tapped we
construct a &lt;code&gt;userInfo&lt;/code&gt; dictionary containing the currently selected
color.  Then we fire a notification with the key
&lt;code&gt;ColorPickerNotification&lt;/code&gt; let all subscribers know that the a color has
been picked by the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let ColorPickerNotification = &amp;quot;com.codepath.ColorPickerViewController.didPickColor&amp;quot;
let ColorPickerSelectedColorKey = &amp;quot;com.codepath.ColorPickerViewController.selectedColor&amp;quot;

class ColorPickerViewController: UIViewController {
    @IBOutlet weak var colorsSegmentedControl: UISegmentedControl!

    let colors = [(&amp;quot;Cyan&amp;quot;, UIColor.cyanColor()),  (&amp;quot;Magenta&amp;quot;, UIColor.magentaColor()), (&amp;quot;Yellow&amp;quot;, UIColor.yellowColor())]
    var initialColor: UIColor?

    override func viewDidLoad() {
        super.viewDidLoad()

        // initalize segmented control and select the starting color if it is one of our segments
        colorsSegmentedControl.removeAllSegments()
        var selectedIndex = UISegmentedControlNoSegment

        for (index, color) in enumerate(colors) {
            if color.1.isEqual(initialColor) {
                selectedIndex = index
            }
            colorsSegmentedControl.insertSegmentWithTitle(color.0, atIndex: index, animated: false)
        }
        colorsSegmentedControl.selectedSegmentIndex = selectedIndex
    }

    func colorFromSelection() -&amp;gt; UIColor? {
        let selectedIndex = colorsSegmentedControl.selectedSegmentIndex
        if selectedIndex != UISegmentedControlNoSegment {
            return colors[selectedIndex].1
        }
        return nil
    }

    @IBAction func doneButtonTapped(sender: AnyObject) {
        var selectionInfo: [NSObject : AnyObject] = [:]
        if let selectedColor = colorFromSelection() {
            selectionInfo[ColorPickerSelectedColorKey] = selectedColor
        }
        NSNotificationCenter.defaultCenter().postNotificationName(ColorPickerNotification, object: self, userInfo: selectionInfo)
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Navigation Controller</title>
      <link>http://guides.peruzal.com/ios-guides/navigation-controller/</link>
      <pubDate>Mon, 12 Dec 2016 02:00:52 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/navigation-controller/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;In a typical iOS project you will create one view controller for each
&amp;ldquo;screen&amp;rdquo; in your application.  This means you need a way to coordinate
the interaction of these view controllers and the presentation of their
associated views.&lt;/p&gt;

&lt;p&gt;In this lesson we will show you how to
- Take the user to another screen (view controllers) within your application
- Pass data between view controllers
- Create a navigation flow with or without a storyboard&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/7STmvxL&#34;&gt;&lt;img src=&#34;http://i.imgur.com/7STmvxL.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;navigation-controller&#34;&gt;Navigation Controller&lt;/h2&gt;

&lt;p&gt;A common way to manage a group of view controllers that are associated
with a hierarchy of content is to use a
&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html&#34;&gt;&lt;code&gt;UINavigationController&lt;/code&gt;&lt;/a&gt;.  Navigation
controllers maintain a &lt;a href=&#34;http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29&#34;&gt;stack&lt;/a&gt; of view controllers that are pushed onto and
popped off of the top of the stack as the user browses through the
hierarchy.  Their behavior is somewhat similar to that of a web
browser&amp;rsquo;s history and &amp;ldquo;back button&amp;rdquo; functionality.&lt;/p&gt;

&lt;p&gt;The navigation controller is one example of a built-in UIKit &lt;a href=&#34;https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html&#34;&gt;container
view controller&lt;/a&gt;.  An in-depth guide by Apple covering
navigation controllers and all other built-in container view controllers
can be found &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewControllerCatalog/Introduction.html#//apple_ref/doc/uid/TP40011313-CH1-SW1&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;basic-use-of-the-navigation-controller&#34;&gt;Basic use of the navigation controller&lt;/h2&gt;

&lt;p&gt;This guide covers the most common use cases for navigation controllers
and how to pass data between view controllers managed by a navigation
controller.  To demonstrate this functionality, we will build a demo
application that presents the user with a table of names.  When the user
selects a name in the table we will show a detail view controller that
allows the user to edit the name.&lt;/p&gt;

&lt;p&gt;The process for using navigation controllers in storyboard applications
actually quite different than when using them programmatically since the
concept of a &lt;em&gt;segue&lt;/em&gt; does not exist outside the storyboard.  We&amp;rsquo;ll
create the example first with storyboards.  Then we&amp;rsquo;ll show how the same
example would be built without using storyboards.&lt;/p&gt;

&lt;h3 id=&#34;using-navigation-controllers-in-storyboards&#34;&gt;Using navigation controllers in storyboards&lt;/h3&gt;

&lt;p&gt;First we&amp;rsquo;ll set up our table to show the list of names.  Starting with
the Xcode &lt;code&gt;Single View Application&lt;/code&gt; template.  We add a table view to
the initial view controller that Xcode has generated and add a single prototype cell that just uses the built-in &lt;code&gt;UITableViewCell&lt;/code&gt;
class.  We hook up our Table View&amp;rsquo;s &lt;code&gt;dataSource&lt;/code&gt; property to finish the
initial setup.  If you are unfamiliar with table views please refer to
the [[table view guide|Table View Guide]].&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/WBH4TcV&#34;&gt;&lt;img src=&#34;http://i.imgur.com/WBH4TcV.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

class ViewController: UIViewController, UITableViewDataSource {

    let names = [&amp;quot;Brent Berg&amp;quot;, &amp;quot;Cody Preston&amp;quot;, &amp;quot;Kareem Dixon&amp;quot;, &amp;quot;Xander Clark&amp;quot;,
        &amp;quot;Francis Frederick&amp;quot;, &amp;quot;Carson Hopkins&amp;quot;, &amp;quot;Anthony Nguyen&amp;quot;, &amp;quot;Dean Franklin&amp;quot;,
        &amp;quot;Jeremy Davenport&amp;quot;, &amp;quot;Rigel Bradford&amp;quot;, &amp;quot;John Ball&amp;quot;, &amp;quot;Zachery Norman&amp;quot;,
        &amp;quot;Valentine Lindsey&amp;quot;, &amp;quot;Slade Thornton&amp;quot;, &amp;quot;Jelani Dickson&amp;quot;, &amp;quot;Vance Hurley&amp;quot;,
        &amp;quot;Wayne Ellison&amp;quot;, &amp;quot;Kasimir Mueller&amp;quot;, &amp;quot;Emery Pruitt&amp;quot;, &amp;quot;Lucius Lawrence&amp;quot;,
        &amp;quot;Kenneth Mendez&amp;quot;]

    @IBOutlet weak var tableView: UITableView!

    override func viewDidLoad() {
        tableView.dataSource = self
    }

    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return names.count
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;NameCell&amp;quot;) as UITableViewCell
        cell.textLabel?.text = names[indexPath.row]
        return cell
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/OuawCqi&#34;&gt;&lt;img src=&#34;http://i.imgur.com/OuawCqil.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;adding-the-navigation-controller-and-setting-the-root-view-controller&#34;&gt;Adding the navigation controller and setting the root view controller&lt;/h4&gt;

&lt;p&gt;Next we&amp;rsquo;ll need to add a navigation controller.  When we instantiate a
navigation controller, we must also set its &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html#//apple_ref/occ/instm/UINavigationController/initWithRootViewController:&#34;&gt;&lt;em&gt;root view
controller&lt;/em&gt;&lt;/a&gt;.  This is the first view controller that will be
shown when the navigation controller is loaded.  Think of it as the
&amp;ldquo;home page&amp;rdquo; in our web browser analogy.&lt;/p&gt;

&lt;p&gt;One way to add a navigation controller is by dragging a &lt;code&gt;Navigation
Controller&lt;/code&gt; from the object library into our storyboard.  You&amp;rsquo;ll notice
that if you do this, Xcode will automatically create a separate view
controller to act as the root view controller.  We&amp;rsquo;ll want to set the
root view controller to the one with our table and delete the other one.
This can be done by control dragging from the navigation controller to
our view controller and selecting the &lt;code&gt;root view controller&lt;/code&gt;
Relationship Segue.  If you haven&amp;rsquo;t worked with segues before, a segue
(pronounced &amp;ldquo;seg-way&amp;rdquo;) is a storyboard&amp;rsquo;s representation of a
relationship or transition between different view controllers.  We&amp;rsquo;ll
also need to set the &lt;em&gt;initial view controller&lt;/em&gt; to the navigation
controller by dragging the arrow that was pointing to the view
controller with our table.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/83IhGlK&#34;&gt;&lt;img src=&#34;http://i.imgur.com/83IhGlK.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In most cases if we have a view controller already set up that we want
to act as our root view controller, we can accomplish all the above
steps simply by selecting the menu item &lt;code&gt;Editor -&amp;gt; Embed In -&amp;gt;
Navigation Controller&lt;/code&gt;.  Running the app, we can see our navigation
controller&amp;rsquo;s translucent grey navigation bar at the top of the screen.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/5WtqwmM&#34;&gt;&lt;img src=&#34;http://i.imgur.com/5WtqwmMl.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;pushing-a-view-controller-onto-the-navigation-stack&#34;&gt;Pushing a view controller onto the navigation stack&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll need to create another view controller class to display and allow
the user to edit an individual name.  We do this by dragging another
view controller from the Object Library onto our storyboard.  We add two
text fields to this view controller to store the first and last parts of
the name the user will be editing.  We create a new subclass of
&lt;code&gt;UIViewController&lt;/code&gt; called &lt;code&gt;NameController&lt;/code&gt; and set the new view
controller&amp;rsquo;s &lt;code&gt;Custom Class&lt;/code&gt; property to be &lt;code&gt;NameController&lt;/code&gt; in our
storyboard.  Once the custom class is set, we can go ahead and create
outlets in our &lt;code&gt;NameController&lt;/code&gt; class corresponding to the two text
fields.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/UgE77Nm&#34;&gt;&lt;img src=&#34;http://i.imgur.com/UgE77Nm.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

class NameController: UIViewController {

    @IBOutlet weak var firstNameTextField: UITextField!
    @IBOutlet weak var lastNameTextField: UITextField!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the user selects name by tapping on a row in the table, we want to
display the &lt;code&gt;NameController&lt;/code&gt; by pushing it onto the navigation stack.
This can be done by control-dragging from the prototype cell to our name
controller and selecting &lt;code&gt;show&lt;/code&gt; under &lt;code&gt;Selection Segue&lt;/code&gt;.  Once this is
done, notice how our name controller now also shows the grey navigation
bar to indicate that it will be shown as part of the navigation stack.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/WqWi2kL&#34;&gt;&lt;img src=&#34;http://i.imgur.com/WqWi2kL.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is important that we select the &lt;code&gt;show&lt;/code&gt; segue since this corresponds
to the navigation controller pushing a new view controller onto the
stack.  The other segues correspond to other ways of transitioning to a
new view controller including presenting it modally.&lt;/p&gt;

&lt;p&gt;Since we initiated our control-drag from the prototype cell, the
&lt;code&gt;Selection Segue&lt;/code&gt; group was available.  Selecting a segue under this
group means &amp;ldquo;respond to the selection event with this transition.&amp;rdquo; Other
events could be available depending on the control that initiates the segue.
For example control-dragging from a button will show possible &lt;code&gt;Action
Segues&lt;/code&gt;.  Running our application right now shows the following.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/CmFK6Bw&#34;&gt;&lt;img src=&#34;http://i.imgur.com/CmFK6Bw.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;configuring-a-view-controller-before-it-is-pushed&#34;&gt;Configuring a view controller before it is pushed&lt;/h4&gt;

&lt;p&gt;You&amp;rsquo;ll notice at least one problem immediately with the current behavior:
the name we selected is not populated in first and last name fields of
our &lt;code&gt;NameController&lt;/code&gt;.  We&amp;rsquo;ll need to configure the name controller
before it gets displayed on the screen.  We do this by first providing
an identifier to our selection segue.  Next we write some code  in our
&lt;em&gt;root view controller&lt;/em&gt;&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/occ/instm/UIViewController/prepareForSegue:sender:&#34;&gt;&lt;code&gt;prepareForSegue&lt;/code&gt;&lt;/a&gt; method to
respond should a segue with this identifier be triggered.&lt;/p&gt;

&lt;p&gt;We give the segue an identifier by selecting the storyboard and using
the Attributes Inspector.  Notice that our prototype cell is also
highlighted to indicate that segue will be trigged by selecting a cell.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/Q71yKws&#34;&gt;&lt;img src=&#34;http://i.imgur.com/Q71yKws.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In our root view controller&amp;rsquo;s &lt;code&gt;prepareForSegue&lt;/code&gt; method, we check to see
if the segue that was triggered matches the identifier we gave our segue
in the storyboard.  If it does we know that the segue was trigged in
response a user selecting a cell, and thus the &lt;code&gt;sender&lt;/code&gt; parameter will
be the cell.  If for example the segue had been triggered by a button
tap, the &lt;code&gt;sender&lt;/code&gt; would be the button.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;segue&lt;/code&gt; parameter of &lt;code&gt;prepareForSegue&lt;/code&gt; gives us access to the
&lt;code&gt;destinationViewController&lt;/code&gt; so that we can configure the new view
controller before it is displayed.  In this case we know that for this
particular segue the &lt;code&gt;destinationViewController&lt;/code&gt; will be a
&lt;code&gt;NameController&lt;/code&gt;.  We&amp;rsquo;ll have to update our &lt;code&gt;NameController&lt;/code&gt; to have the
ability to set the name and have it displayed properly when the view is
loaded.  Finally, we also deselect the row since we won&amp;rsquo;t want it to be
selected once we go back from the name controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource {
    ...
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if segue.identifier == &amp;quot;showNameControllerSegue&amp;quot; {
            let cell = sender as UITableViewCell
            if let indexPath = tableView.indexPathForCell(cell) {
                let nameController = segue.destinationViewController as NameController
                nameController.fullName = names[indexPath.row]
                tableView.deselectRowAtIndexPath(indexPath, animated: true)
            }
        }
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class NameController: UIViewController {
    @IBOutlet weak var firstNameTextField: UITextField!
    @IBOutlet weak var lastNameTextField: UITextField!

    var fullName: String?

    override func viewDidLoad() {
        if let fullName = self.fullName? {
            let firstLast = fullName.componentsSeparatedByString(&amp;quot; &amp;quot;)
            firstNameTextField.text = firstLast[0]
            lastNameTextField.text = firstLast[1]
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/qWis8Ya&#34;&gt;&lt;img src=&#34;http://i.imgur.com/qWis8Ya.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;unwind-segues-and-passing-information-back-up-the-hierarchy&#34;&gt;Unwind segues and passing information back up the hierarchy&lt;/h4&gt;

&lt;p&gt;Next we&amp;rsquo;ll need a way for the user to save any changes to a name back to
our table.  We&amp;rsquo;ll do this by making use of an &lt;em&gt;unwind segue&lt;/em&gt;.  An unwind
segue is a way for a view controller to respond to an event by
navigating back to the view controller that caused it to be loaded.  In
the the context of navigation controllers, this means the view
controller that is one below the current view controller on the
navigation stack.&lt;/p&gt;

&lt;p&gt;First off, we&amp;rsquo;ll need a way for the user to indicate they want to save
the change.  We can add a button to the right side of the navigation bar
in our name controller by dragging a &lt;code&gt;Navigation Item&lt;/code&gt; and then a &lt;code&gt;Bar
Button Item&lt;/code&gt; from the Object Library.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/ScyeS2O&#34;&gt;&lt;img src=&#34;http://i.imgur.com/ScyeS2O.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To implement an unwind segue we create an &lt;code&gt;@IBAction&lt;/code&gt; method in the view
controller that will be &lt;em&gt;unwound to&lt;/em&gt; taking a single &lt;code&gt;UIStoryboardSegue&lt;/code&gt;
parameter.  In our case this means we added the below &lt;code&gt;saveName&lt;/code&gt; method
to our &lt;em&gt;root view controller&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource {
    ...
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if segue.identifier == &amp;quot;showNameControllerSegue&amp;quot; {
            let cell = sender as UITableViewCell
            if let indexPath = tableView.indexPathForCell(cell) {
                let nameController = segue.destinationViewController as NameController
                nameController.fullName = names[indexPath.row]
                tableView.deselectRowAtIndexPath(indexPath, animated: true)
            }
        }
    }

    @IBAction func saveName(segue: UIStoryboardSegue) {
        // add logic here to handle a transition back from the
        // name controller resulting from a user tapping on Save
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we&amp;rsquo;ll have to hook up our &lt;code&gt;Save&lt;/code&gt; button to this segue by
control-dragging from the button to the &lt;code&gt;Exit&lt;/code&gt; outlet and selecting the
&lt;code&gt;@IBAction&lt;/code&gt; we just created.  The &lt;code&gt;Exit&lt;/code&gt; outlet is the red exit door
that appears above of your active view controller in the storyboard.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/QusMqmi&#34;&gt;&lt;img src=&#34;http://i.imgur.com/QusMqmi.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally we&amp;rsquo;ll need to write the code in our root view controller to
handle updating the name once the &lt;code&gt;saveName&lt;/code&gt; method is called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource {

    var names = [&amp;quot;Brent Berg&amp;quot;, &amp;quot;Cody Preston&amp;quot;, &amp;quot;Kareem Dixon&amp;quot;, &amp;quot;Xander Clark&amp;quot;,
        &amp;quot;Francis Frederick&amp;quot;, &amp;quot;Carson Hopkins&amp;quot;, &amp;quot;Anthony Nguyen&amp;quot;, &amp;quot;Dean Franklin&amp;quot;,
        &amp;quot;Jeremy Davenport&amp;quot;, &amp;quot;Rigel Bradford&amp;quot;, &amp;quot;John Ball&amp;quot;, &amp;quot;Zachery Norman&amp;quot;,
        &amp;quot;Valentine Lindsey&amp;quot;, &amp;quot;Slade Thornton&amp;quot;, &amp;quot;Jelani Dickson&amp;quot;, &amp;quot;Vance Hurley&amp;quot;,
        &amp;quot;Wayne Ellison&amp;quot;, &amp;quot;Kasimir Mueller&amp;quot;, &amp;quot;Emery Pruitt&amp;quot;, &amp;quot;Lucius Lawrence&amp;quot;,
        &amp;quot;Kenneth Mendez&amp;quot;]
    var selectedIndexPath: NSIndexPath?

    @IBOutlet weak var tableView: UITableView!

    ...

    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if segue.identifier == &amp;quot;showNameControllerSegue&amp;quot; {
            let cell = sender as UITableViewCell
            if let indexPath = tableView.indexPathForCell(cell) {
                let namesController = segue.destinationViewController as NameController
                namesController.fullName = names[indexPath.row]
                tableView.deselectRowAtIndexPath(indexPath, animated: true)
                selectedIndexPath = indexPath
            }
        }
    }

    @IBAction func saveName(segue: UIStoryboardSegue) {
        let nameController = segue.sourceViewController as NameController
        let name = nameController.firstNameTextField.text + &amp;quot; &amp;quot; + nameController.lastNameTextField.text;

        if let indexPath = selectedIndexPath? {
            names[indexPath.row] = name
            tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic)
            selectedIndexPath = nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we were able to obtain a reference to the name controller in
&lt;code&gt;saveName&lt;/code&gt; by using &lt;code&gt;segue.sourceViewController&lt;/code&gt;.  This makes sense
because the name controller is the source of the &lt;em&gt;unwind segue&lt;/em&gt;, whereas
the destination controller is the root view controller.  The other thing
to note is that we had to maintain an additional state variable
&lt;code&gt;selectedIndexPath&lt;/code&gt; to help us remember which name it was we were
editing.  Putting everything together we get the following
functionality:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/t1krDPG&#34;&gt;&lt;img src=&#34;http://i.imgur.com/t1krDPG.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;using-navigation-controllers-without-storyboards&#34;&gt;Using navigation controllers without storyboards&lt;/h3&gt;

&lt;p&gt;We will now show how the same example would be built in a non-storyboard
application.  Conceptually, some of the steps will be the same.
However, since segues do not exist outside a storyboard, we will have to
set up more code ourselves to handle events and interface between view
controllers.&lt;/p&gt;

&lt;p&gt;As above we&amp;rsquo;ll first set up our table to show the list of names.  We&amp;rsquo;ll
start again with the Xcode &lt;code&gt;Single View Application&lt;/code&gt; template.  Xcode 6
and above will automatically create a &lt;code&gt;Main.storyboard&lt;/code&gt; file and include
it in our build settings.  We will go ahead and remove this file and
update &lt;code&gt;Info.plist&lt;/code&gt; file (under &lt;code&gt;Supporting Files&lt;/code&gt;) to remove the
reference to it by clicking on the minus sign after selecting &lt;code&gt;Main
storyboard file base name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/wTiqnWZ&#34;&gt;&lt;img src=&#34;http://i.imgur.com/wTiqnWZ.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Without the storyboard, we&amp;rsquo;ll have to set up our window and root view
controller manually by changing the &lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;
method in our &lt;code&gt;AppDelegate&lt;/code&gt;.  More on the &lt;code&gt;AppDelegate&lt;/code&gt; can be found in
the [[basic application architecture guide|Application Architecture]].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool {
        window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window?.rootViewController = ViewController()
        window?.makeKeyAndVisible()
        return true
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we made use of the main &lt;code&gt;ViewController&lt;/code&gt; class that Xcode
generated for us.  Now we can add our table of names to this view
controller.  We do everything programmatically here, but we could have
just as easily set up a separate &lt;code&gt;.xib&lt;/code&gt; file for this view controller.
If you are unfamiliar with table views please refer to
the [[table view guide|Table View Guide]].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

class ViewController: UIViewController, UITableViewDataSource {
    let names = [&amp;quot;Brent Berg&amp;quot;, &amp;quot;Cody Preston&amp;quot;, &amp;quot;Kareem Dixon&amp;quot;, &amp;quot;Xander Clark&amp;quot;,
        &amp;quot;Francis Frederick&amp;quot;, &amp;quot;Carson Hopkins&amp;quot;, &amp;quot;Anthony Nguyen&amp;quot;, &amp;quot;Dean Franklin&amp;quot;,
        &amp;quot;Jeremy Davenport&amp;quot;, &amp;quot;Rigel Bradford&amp;quot;, &amp;quot;John Ball&amp;quot;, &amp;quot;Zachery Norman&amp;quot;,
        &amp;quot;Valentine Lindsey&amp;quot;, &amp;quot;Slade Thornton&amp;quot;, &amp;quot;Jelani Dickson&amp;quot;, &amp;quot;Vance Hurley&amp;quot;,
        &amp;quot;Wayne Ellison&amp;quot;, &amp;quot;Kasimir Mueller&amp;quot;, &amp;quot;Emery Pruitt&amp;quot;, &amp;quot;Lucius Lawrence&amp;quot;,
        &amp;quot;Kenneth Mendez&amp;quot;]

    var tableView: UITableView!

    override func viewDidLoad() {
        super.viewDidLoad()
        tableView = UITableView(frame: view.frame)
        tableView.dataSource = self
        tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: &amp;quot;NameCell&amp;quot;)
        view.addSubview(tableView)
    }

    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return names.count
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;NameCell&amp;quot;) as UITableViewCell
        cell.textLabel?.text = names[indexPath.row]
        return cell
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the app at this point gives us:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/OuawCqi&#34;&gt;&lt;img src=&#34;http://i.imgur.com/OuawCqil.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;adding-the-navigation-controller-and-setting-its-root-view-controller&#34;&gt;Adding the navigation controller and setting its root view controller&lt;/h4&gt;

&lt;p&gt;Next we&amp;rsquo;ll need to add a navigation controller and set its &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html#//apple_ref/occ/instm/UINavigationController/initWithRootViewController:&#34;&gt;&lt;em&gt;root view
controller&lt;/em&gt;&lt;/a&gt;&amp;mdash;the first view controller that will be shown
when the navigation controller is loaded&amp;mdash;to be our main view
controller with the table.&lt;/p&gt;

&lt;p&gt;We can do this all in code by simply instantiating a
&lt;code&gt;UINavigationController&lt;/code&gt; and setting its properties.  Since we want the
navigation controller to be the first view controller shown when the app is
loaded, we can do this in our &lt;code&gt;AppDelegate&lt;/code&gt;&amp;rsquo;s
&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt; method where we also set the
&lt;em&gt;application window&lt;/em&gt;&amp;rsquo;s root view controller to be the navigation
controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool {
        window = UIWindow(frame: UIScreen.mainScreen().bounds)
        let mainVC = ViewController()
        let navigationVC = UINavigationController(rootViewController: mainVC)
        window?.rootViewController = navigationVC
        window?.makeKeyAndVisible()
        return true
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the application at this point will show the same table with a
grey navigation bar at the top.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/5WtqwmM&#34;&gt;&lt;img src=&#34;http://i.imgur.com/5WtqwmMl.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;initializing-and-pushing-a-view-controller-onto-the-stack&#34;&gt;Initializing and pushing a view controller onto the stack&lt;/h4&gt;

&lt;p&gt;As in our storyboard example, we&amp;rsquo;ll need to create another view
controller class to display and allow the user to edit an individual
name.  Instead of laying out our view programmatically as we did in the
main &lt;code&gt;ViewController&lt;/code&gt; class, we&amp;rsquo;ll create new class &lt;code&gt;NameController&lt;/code&gt; and
associated &lt;code&gt;.xib&lt;/code&gt; by selecting &lt;code&gt;File -&amp;gt; New -&amp;gt; File... -&amp;gt; iOS -&amp;gt; Source
-&amp;gt; Cocoa Touch Class&lt;/code&gt;.  Be sure to tick in the &lt;code&gt;Also Create XIB file&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/2LNtYpi&#34;&gt;&lt;img src=&#34;http://i.imgur.com/2LNtYpi.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NB: Most of the time you&amp;rsquo;ll want to be consistent and use only one
method of laying out your views (programmatic, separate &lt;code&gt;.xib&lt;/code&gt;s, or have
your app entirely within storyboards).  Here we use both &lt;code&gt;.xib&lt;/code&gt; and
programmatic layout to emphasize the point that anything outside a
storyboard cannot use segues and thus must programmatically manipulate
the navigation view controller.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We can now open up &lt;code&gt;NameController.xib&lt;/code&gt; in Interface Builder. As before,
we&amp;rsquo;ll add two text fields to this view controller to store the first and
last parts of the name the user will be editing. Using the Assistant
Editor (tuxedo) view we also create outlets in our &lt;code&gt;NameController&lt;/code&gt;
class corresponding to the two text fields by controlling dragging the
fields into the code view.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/bEH8mLO&#34;&gt;&lt;img src=&#34;http://i.imgur.com/bEH8mLO.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll go ahead and add the code that will allow us to configure the
&lt;code&gt;NameController&lt;/code&gt; to with the &lt;code&gt;fullName&lt;/code&gt; that it will display when
loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

class NameController: UIViewController {

    @IBOutlet weak var lastNameTextField: UITextField!
    @IBOutlet weak var firstNameTextField: UITextField!

    var fullName: String?

    override func viewDidLoad() {
        if let fullName = self.fullName? {
            let firstLast = fullName.componentsSeparatedByString(&amp;quot; &amp;quot;)
            firstNameTextField.text = firstLast[0]
            lastNameTextField.text = firstLast[1]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NB: The following only affects Swift projects:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Previously when initializing a view controller class named &lt;code&gt;Foo&lt;/code&gt; via the
default (argumentless) initializer, UIKit will look for a matching
&lt;code&gt;Foo.xib&lt;/code&gt; and load the UI elements from this file.  In the latest
versions of Xcode Apple has changed this behavior (for Swift classes
only) to look for an associated &lt;code&gt;.xib&lt;/code&gt; named &lt;code&gt;YourProjectName.Foo.xib&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;There are a few ways to work around this behavior discussed
&lt;a href=&#34;http://stackoverflow.com/a/25152545&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://stackoverflow.com/a/25539016&#34;&gt;here&lt;/a&gt;.  In this example we simply
renamed our &lt;code&gt;NameController.xib&lt;/code&gt; file to
&lt;code&gt;NavigationNoStoryboard.NameController.xib&lt;/code&gt; where
&lt;code&gt;NavigationNoStoryboard&lt;/code&gt; was the the name of our project.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Remember that we want to show the &lt;code&gt;NameController&lt;/code&gt; and add it to the
navigation stack when the user selects a name in our main
&lt;code&gt;ViewController&lt;/code&gt; containing the table of names.  By having our main
&lt;code&gt;ViewController&lt;/code&gt; implement the &lt;code&gt;UITableViewDelegate&lt;/code&gt; protocol we have a
convenient hook to respond to the row selection event by overriding the
&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UITableViewDelegate_Protocol/index.html#//apple_ref/occ/intfm/UITableViewDelegate/tableView:didSelectRowAtIndexPath:&#34;&gt;&lt;code&gt;didSelectRowAtIndexPath&lt;/code&gt;&lt;/a&gt; method.  Again, you should
refer to the [[table view guide|Table View Guide]] if you are unfamiliar with this aspect of
table views.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {
    ...

    override func viewDidLoad() {
        super.viewDidLoad()
        tableView = UITableView(frame: view.frame)
        tableView.dataSource = self
        tableView.delegate = self
        tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: &amp;quot;NameCell&amp;quot;)
        view.addSubview(tableView)
    }

    ...

    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        let nameVC = NameController()
        nameVC.fullName = names[indexPath.row]

        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        self.navigationController?.pushViewController(nameVC, animated: true)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we are able to obtain a reference to the navigation
controller via &lt;code&gt;self.navigationController&lt;/code&gt;.  This is set automatically
for us by UIKit when any view controller comes onto the navigation
stack.  In this case, it happened when we set this view controller as
our navigation controller&amp;rsquo;s root view controller in the &lt;code&gt;AppDelegate&lt;/code&gt;
above.&lt;/p&gt;

&lt;p&gt;We push &lt;code&gt;nameVC&lt;/code&gt; onto the navigation stack and display it as the top
view controller with &lt;code&gt;pushViewController&lt;/code&gt;.  After this call is made, the
&lt;code&gt;nameVC.navigationController&lt;/code&gt; property will also be automatically set to
the same navigation controller.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NB: Technically in Swift, prefixing a property with &lt;code&gt;self.&lt;/code&gt; is not
required and is specifically recommended against by both
&lt;a href=&#34;https://github.com/github/swift-style-guide#only-explicitly-refer-to-self-when-required&#34;&gt;github&amp;rsquo;s&lt;/a&gt; and &lt;a href=&#34;https://github.com/raywenderlich/swift-style-guide#use-of-self&#34;&gt;Ray
Wenderlich&amp;rsquo;s&lt;/a&gt; style guides.  We include it here
to emphasize that this is a built-in property on the view controller.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Running the application at this stage gives us the following behavior.&lt;/p&gt;

&lt;h4 id=&#34;passing-information-back-up-the-stack-with-a-delegate&#34;&gt;Passing information back up the stack with a delegate&lt;/h4&gt;

&lt;p&gt;We still need to implement the ability to save changes to a name in
&lt;code&gt;NameController&lt;/code&gt; back to the table view in the main &lt;code&gt;ViewController&lt;/code&gt;.
Since there&amp;rsquo;s no such thing as an &lt;em&gt;unwind segue&lt;/em&gt; without a storyboard,
we&amp;rsquo;ll have to implement our own mechanism for sending the new name back
to the main &lt;code&gt;ViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The typical pattern to accomplish this in iOS programmatically is to use a
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html&#34;&gt;delegate&lt;/a&gt;.  What this means in this case is that the
&lt;code&gt;NameController&lt;/code&gt; needs to keep a reference to the main &lt;code&gt;ViewController&lt;/code&gt;
so that it can inform the main &lt;code&gt;ViewController&lt;/code&gt; when the user has saved
changes to a name and what the new name is.&lt;/p&gt;

&lt;p&gt;However, since we defined our &lt;code&gt;NameController&lt;/code&gt; outside of a storyboard,
there is no way in general, to tell what view controller has
instantiated it and pushed it onto the navigation stack (if there is
even a navigation stack).  For example, later on, we might want to reuse
&lt;code&gt;NameController&lt;/code&gt; to edit names a different situation where we
instantiated it and presented it from a view controller class we haven&amp;rsquo;t
even created at this time.&lt;/p&gt;

&lt;p&gt;Thus maintaining a reference to something of type &lt;code&gt;ViewController&lt;/code&gt; would
unnecessarily couple the &lt;code&gt;ViewController&lt;/code&gt; and &lt;code&gt;NameController&lt;/code&gt; classes.
To solve this problem we can introduce a protocol (sometimes called
interface in other programming environments) &lt;code&gt;NameControllerDelegate&lt;/code&gt; to
represent something that is able to respond events from
&lt;code&gt;NameController&lt;/code&gt;.   We&amp;rsquo;ll make our main &lt;code&gt;ViewController&lt;/code&gt; implement
&lt;code&gt;NameControllerDelegate&lt;/code&gt; similar to how it implemented
&lt;code&gt;UITableViewDelegate&lt;/code&gt; in order to respond to events from the
&lt;code&gt;UITableView&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;NameControllerDelegate&lt;/code&gt; protocol defines a single method
&lt;code&gt;didSaveName&lt;/code&gt; that will be called when the user has initiated a save
action in our &lt;code&gt;NameController&lt;/code&gt;.  In order to call this method, we&amp;rsquo;ll need
to keep a reference to the &lt;code&gt;delegate&lt;/code&gt; in our &lt;code&gt;NameController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lastly, we need to add a save button to our navigation bar and set its
action to call a method &lt;code&gt;saveButtonTapped&lt;/code&gt; in our &lt;code&gt;NameController&lt;/code&gt; that
will propagate the event to our &lt;code&gt;NameControllerDelegate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After putting everything together the code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

protocol NameControllerDelegate: class {
    func nameController(nameVC: NameController, didSaveName name: String)
}

class NameController: UIViewController {

    @IBOutlet weak var lastNameTextField: UITextField!
    @IBOutlet weak var firstNameTextField: UITextField!

    weak var delegate: NameControllerDelegate?
    var fullName: String?

    override func viewDidLoad() {
        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: &amp;quot;Save&amp;quot;, style: .Plain, target: self, action: &amp;quot;saveButtonTapped&amp;quot;)
        self.navigationItem.title = &amp;quot;Edit Name&amp;quot;

        if let fullName = self.fullName? {
            let firstLast = fullName.componentsSeparatedByString(&amp;quot; &amp;quot;)
            firstNameTextField.text = firstLast[0]
            lastNameTextField.text = firstLast[1]
        }
    }

    func saveButtonTapped() {
        let name = firstNameTextField.text + &amp;quot; &amp;quot; + lastNameTextField.text
        delegate?.nameController(self, didSaveName: name)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, NameControllerDelegate {
    var names = [&amp;quot;Brent Berg&amp;quot;, &amp;quot;Cody Preston&amp;quot;, &amp;quot;Kareem Dixon&amp;quot;, &amp;quot;Xander Clark&amp;quot;,
        &amp;quot;Francis Frederick&amp;quot;, &amp;quot;Carson Hopkins&amp;quot;, &amp;quot;Anthony Nguyen&amp;quot;, &amp;quot;Dean Franklin&amp;quot;,
        &amp;quot;Jeremy Davenport&amp;quot;, &amp;quot;Rigel Bradford&amp;quot;, &amp;quot;John Ball&amp;quot;, &amp;quot;Zachery Norman&amp;quot;,
        &amp;quot;Valentine Lindsey&amp;quot;, &amp;quot;Slade Thornton&amp;quot;, &amp;quot;Jelani Dickson&amp;quot;, &amp;quot;Vance Hurley&amp;quot;,
        &amp;quot;Wayne Ellison&amp;quot;, &amp;quot;Kasimir Mueller&amp;quot;, &amp;quot;Emery Pruitt&amp;quot;, &amp;quot;Lucius Lawrence&amp;quot;,
        &amp;quot;Kenneth Mendez&amp;quot;]

    var tableView: UITableView!
    var selectedIndexPath: NSIndexPath?

    ...

    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        let nameVC = NameController()
        nameVC.fullName = names[indexPath.row]
        nameVC.delegate = self

        selectedIndexPath = indexPath
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        self.navigationController?.pushViewController(nameVC, animated: true)
    }

    func nameController(nameVC: NameController, didSaveName name: String) {
        if let indexPath = selectedIndexPath? {
            names[indexPath.row] = name
            tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic)
        }
        self.navigationController?.popViewControllerAnimated(true)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/t1krDPG&#34;&gt;&lt;img src=&#34;http://i.imgur.com/t1krDPG.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are quite a few things to note in the above code.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We restrict that only class types (as opposed to structs) can
implement our &lt;code&gt;NameControllerDelegate&lt;/code&gt; protocol by including the
&lt;code&gt;class&lt;/code&gt; keyword in the declaration in the inherited protocols list after
the colon.  This is so we can declare our &lt;code&gt;delegate&lt;/code&gt; property as a
&lt;code&gt;weak&lt;/code&gt; reference (since structs cannot be weak references).  This point
is language specific to Swift.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The reason we need our &lt;code&gt;delegate&lt;/code&gt; property to be a &lt;code&gt;weak&lt;/code&gt; reference is
due to the fact that iOS manages (and frees) memory by using a
technique called &lt;a href=&#34;http://en.wikipedia.org/wiki/Automatic_Reference_Counting&#34;&gt;automatic reference counting&lt;/a&gt; (ARC).  Since
delegates commonly refer back to objects that instantiated them (or
objects referred to by these objects), &lt;strong&gt;we&amp;rsquo;ll always want to declare
our delegate properties as &lt;code&gt;weak&lt;/code&gt;&lt;/strong&gt; in order to avoid strong reference
cycles that lead to memory leaks.  An extensive discussion of ARC can be
found &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;navigationItem&lt;/code&gt; property of &lt;code&gt;NameController&lt;/code&gt; is used by the
navigation controller to determine what to display in the
navigation bar when &lt;code&gt;NameController&lt;/code&gt; is on top of the navigation stack.
This provides us with a convenient hook to customize the content of the
navigation bar.  More on this can be found below in discussion of
customizing the navigation bar&amp;rsquo;s appearance
&lt;a href=&#34;#customizing-the-appearance-of-navigation-bar&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When creating the &lt;code&gt;Save&lt;/code&gt; button by instantiating a &lt;code&gt;UIBarButtonItem&lt;/code&gt;
we specified how to respond to the button being tapped with the
&lt;code&gt;target&lt;/code&gt; and &lt;code&gt;action&lt;/code&gt; parameters.  This is an example of &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html&#34;&gt;target-action
pattern&lt;/a&gt; (sometimes called target-selector).  This
invocation basically means &amp;ldquo;call the method identified by &lt;code&gt;action&lt;/code&gt; on
the &lt;code&gt;target&lt;/code&gt; object when the button is tapped&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;NB:  In Objective-C the &lt;code&gt;action&lt;/code&gt; parameter has to a be
&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/General/Conceptual/DevPedia-CocoaCore/Selector.html&#34;&gt;&lt;code&gt;selector&lt;/code&gt;&lt;/a&gt;.  In Swift, strings are automatically converted
to selectors when necessary.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;As before in our storyboard example, we need to maintain an additional
state variable &lt;code&gt;selectedIndexPath&lt;/code&gt; so that when the delegate method
&lt;code&gt;didSaveName&lt;/code&gt; is called, we can know which name to update.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Notice that we set &lt;code&gt;nameVC.delegate = self&lt;/code&gt; when configuring the
&lt;code&gt;NameController&lt;/code&gt; in &lt;code&gt;didSelectRowAtIndexPath&lt;/code&gt; since we implement
&lt;code&gt;NameControllerDelegate&lt;/code&gt; in &lt;code&gt;ViewController&lt;/code&gt;.  It is a common mistake
to forget to set the delegate.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We deselect the row in &lt;code&gt;didSelectRowAtIndexPath&lt;/code&gt; since we won&amp;rsquo;t want
it to be selected once we go back from the &lt;code&gt;NameController&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We follow delegate method &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-1001803-BCIDAIJE&#34;&gt;naming conventions&lt;/a&gt; by
passing the delegating object (&lt;code&gt;NameController&lt;/code&gt;) back as the first
argument in our &lt;code&gt;didSaveName&lt;/code&gt; method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Without an &lt;em&gt;unwind segue&lt;/em&gt; we have to manually pop top the view
controller in &lt;code&gt;didSaveName&lt;/code&gt;.  When this method is called, this will be
the &lt;code&gt;NameController&lt;/code&gt;.  Notice that we didn&amp;rsquo;t have to set up this action
for the &lt;code&gt;Back&lt;/code&gt; button due to a built-in behavior.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;customizing-the-appearance-of-navigation-bar&#34;&gt;Customizing the appearance of navigation bar&lt;/h2&gt;

&lt;p&gt;There are several ways to customize the appearance of the navigation bar
and control what items appear in it.&lt;/p&gt;

&lt;h3 id=&#34;understanding-navigation-bars-and-navigation-items&#34;&gt;Understanding navigation bars and navigation items&lt;/h3&gt;

&lt;p&gt;In order to know which object&amp;rsquo;s properties we need to change to get the
desired appearance, we first need to understand a bit about how
navigation bars and navigation items work.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;UINavigationController&lt;/code&gt; has a &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html#//apple_ref/occ/instp/UINavigationController/navigationBar&#34;&gt;&lt;code&gt;navigationBar&lt;/code&gt;&lt;/a&gt; of
type &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html&#34;&gt;&lt;code&gt;UINavigationBar&lt;/code&gt;&lt;/a&gt;.  Each &lt;code&gt;UIViewController&lt;/code&gt; has
an associated &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/occ/instp/UIViewController/navigationItem&#34;&gt;&lt;code&gt;navigationItem&lt;/code&gt;&lt;/a&gt; of type
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationItem_Class/index.html&#34;&gt;&lt;code&gt;UINavigationItem&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The navigation bar associated with a navigation controller maintains a
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/occ/instp/UINavigationBar/items&#34;&gt;stack of &lt;code&gt;UINavigationItems&lt;/code&gt;&lt;/a&gt; that is parallel to the
navigation stack of view controllers.  When a view controller is pushed
onto the navigation stack its &lt;code&gt;navigationItem&lt;/code&gt; gets pushed onto the
navigation bar&amp;rsquo;s stack of navigation items.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/occ/instp/UINavigationBar/topItem&#34;&gt;top&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/occ/instp/UINavigationBar/backItem&#34;&gt;second from top&lt;/a&gt; &lt;code&gt;UINavigationItems&lt;/code&gt;
in the navigation bar&amp;rsquo;s item stack are used to determine which
components are added to navigation bar.  Specifically the top navigation
item determines the title view and button(s) on the right hand side of
the nav bar.  It can also determine the button(s) on the left hand side
of the nav bar, but if no left-side button is set, the navigation bar
will use the &lt;em&gt;second from top navigation item&lt;/em&gt; in order to determine
what &amp;ldquo;Back&amp;rdquo; button to show.&lt;/p&gt;

&lt;p&gt;In some rarer cases you may want to use a &lt;code&gt;UINavigationBar&lt;/code&gt; without the
backing of a &lt;code&gt;UINavigationController&lt;/code&gt;.  In these instances, you may have
to manually manage the &lt;code&gt;UINavigationBar&lt;/code&gt;&amp;rsquo;s navigation item stack by
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/occ/instm/UINavigationBar/pushNavigationItem:animated:&#34;&gt;pushing&lt;/a&gt;/&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/occ/instm/UINavigationBar/popNavigationItemAnimated:&#34;&gt;popping&lt;/a&gt; navigation items in order
to achieve the appearance you want.&lt;/p&gt;

&lt;h3 id=&#34;customization-inside-a-storyboard&#34;&gt;Customization inside a storyboard&lt;/h3&gt;

&lt;p&gt;When working in a project with storyboards, many of the things you might
want to change about a navigation bar&amp;rsquo;s appearance can be edited in the
Attributes Inspector by selecting the navigation bar associated with
your navigation controller.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/judIATc&#34;&gt;&lt;img src=&#34;http://i.imgur.com/judIATc.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The navigation item with your view controller can also be edited
directly in the storyboard.  For example, to add more buttons to the
navigation item, you can simply drag buttons from the Object Library as
we did in our storyboard example
&lt;a href=&#34;#unwind-segues-and-passing-information-back-up-the-hierarchy&#34;&gt;above&lt;/a&gt;.
Note that a view controller&amp;rsquo;s the navigation item will not be an element
in your storyboard by default.  You must drag a navigation item from the
Object Library to your view controller (as we did in our storyboard
example above) in order to have access to it&amp;mdash;although, embedding
your view controller in a navigation controller will automatically add
the navigation item.&lt;/p&gt;

&lt;h3 id=&#34;navigation-bar-colors-background-image-and-text-attributes&#34;&gt;Navigation bar colors, background image, and text attributes&lt;/h3&gt;

&lt;p&gt;There are a &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/doc/uid/TP40006887-CH3-SW16&#34;&gt;few properties&lt;/a&gt; that you can manipulate in
order to control the appearance of a navigation bar.  Since a navigation
controller is associated with a single navigation bar, &lt;strong&gt;any change here
will be visible across all view controllers in a navigation controller&amp;rsquo;s
stack.&lt;/strong&gt;  Apple has been changing the behavior of these properties
somewhat frequently in recent iOS versions, so you may have to
experiment a bit to achieve the effect you want.&lt;/p&gt;

&lt;p&gt;Continuing with our example from above we can customize our navigation
bar as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, NameControllerDelegate {
    ...

    override func viewDidLoad() {
        ...

        self.navigationItem.title = &amp;quot;Names&amp;quot;
        if let navigationBar = navigationController?.navigationBar {
            navigationBar.setBackgroundImage(UIImage(named: &amp;quot;codepath-logo&amp;quot;), forBarMetrics: .Default)
            navigationBar.tintColor = UIColor(red: 1.0, green: 0.25, blue: 0.25, alpha: 0.8)

            let shadow = NSShadow()
            shadow.shadowColor = UIColor.grayColor().colorWithAlphaComponent(0.5)
            shadow.shadowOffset = CGSizeMake(2, 2);
            shadow.shadowBlurRadius = 4;
            navigationBar.titleTextAttributes = [
                NSFontAttributeName : UIFont.boldSystemFontOfSize(22),
                NSForegroundColorAttributeName : UIColor(red: 0.5, green: 0.15, blue: 0.15, alpha: 0.8),
                NSShadowAttributeName : shadow
            ]
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/AJjy8Nq&#34;&gt;&lt;img src=&#34;http://i.imgur.com/AJjy8Nq.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;title-text-and-view-of-a-navigation-item&#34;&gt;Title text and view of a navigation item&lt;/h3&gt;

&lt;p&gt;Notice that above we were able to set the navigation bar&amp;rsquo;s title text by
setting &lt;code&gt;navigationItem.title&lt;/code&gt; on our &lt;em&gt;view controller&lt;/em&gt;&amp;rsquo;s navigation
item.  Since the navigation item is distinct per view controller, we can
set separate titles for each view controller.&lt;/p&gt;

&lt;p&gt;In rare cases you may wish to replace a navigation item&amp;rsquo;s entire
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationItem_Class/index.html#//apple_ref/occ/instp/UINavigationItem/titleView&#34;&gt;&lt;code&gt;titleView&lt;/code&gt;&lt;/a&gt;.  This is useful for example if you need
customized styling of the title text only for a specific view
controller.  Continuing with our previous example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class NameController: UIViewController {
    ...

    override func viewDidLoad() {
        navigationItem.rightBarButtonItem = UIBarButtonItem(title: &amp;quot;Save&amp;quot;, style: .Plain, target: self, action: &amp;quot;saveButtonTapped&amp;quot;)

        let titleLabel = UILabel()

        let shadow = NSShadow()
        shadow.shadowColor = UIColor.redColor().colorWithAlphaComponent(0.5)
        shadow.shadowOffset = CGSizeMake(2, 2);
        shadow.shadowBlurRadius = 4;

        let titleText = NSAttributedString(string: &amp;quot;Edit Name&amp;quot;, attributes: [
            NSFontAttributeName : UIFont.boldSystemFontOfSize(28),
            NSForegroundColorAttributeName : UIColor(red: 0.5, green: 0.25, blue: 0.15, alpha: 0.8),
            NSShadowAttributeName : shadow
            ])

        titleLabel.attributedText = titleText
        titleLabel.sizeToFit()
        navigationItem.titleView = titleLabel

        ...
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/BYV6p9s&#34;&gt;&lt;img src=&#34;http://i.imgur.com/BYV6p9s.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;setting-bar-button-items-for-a-navigation-item&#34;&gt;Setting bar button items for a navigation item&lt;/h3&gt;

&lt;p&gt;You can also configure the button(s) that appear to the
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationItem_Class/index.html&#34;&gt;left&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationItem_Class/index.html#//apple_ref/occ/instp/UINavigationItem/rightBarButtonItems&#34;&gt;right&lt;/a&gt; of the title in a navigation
item by providing your own &lt;code&gt;UIBarButtonItem&lt;/code&gt; or array of
&lt;code&gt;UIBarButtonItems&lt;/code&gt;.  The &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIBarButtonItem_Class/index.html&#34;&gt;&lt;code&gt;UIBarButtonItem&lt;/code&gt;&lt;/a&gt; also has a
number of properties you can use to customize it.  Of particular note is
the fact that you can provide an arbitrary &lt;code&gt;UIView&lt;/code&gt; as a custom view.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class NameController: UIViewController {
    ...

    override func viewDidLoad() {
        let saveButton = UIBarButtonItem(title: &amp;quot;Save&amp;quot;, style: .Plain, target: self, action: &amp;quot;saveButtonTapped&amp;quot;)

        let segmentedControl = UISegmentedControl(items: [&amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;])
        segmentedControl.sizeToFit()
        let segmentedButton = UIBarButtonItem(customView: segmentedControl)

        let dummyButton = UIBarButtonItem(title: &amp;quot;Dummy&amp;quot;, style: .Plain, target: nil, action: nil)

        navigationItem.rightBarButtonItems = [saveButton, segmentedButton]
        navigationItem.leftBarButtonItem = dummyButton
        ...
   }
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/FptSf6y&#34;&gt;&lt;img src=&#34;http://i.imgur.com/FptSf6yl.png&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;the-back-button&#34;&gt;The Back button&lt;/h4&gt;

&lt;p&gt;Notice that above when we set the top navigation item&amp;rsquo;s
&lt;code&gt;leftBarButtonItem&lt;/code&gt;, the &amp;ldquo;Back&amp;rdquo; button no longer appeared.  In order to
customize the back button we have the &lt;code&gt;leftBarButtonItem&lt;/code&gt; and
&lt;code&gt;leftBarButtonItems&lt;/code&gt; properties set to &lt;code&gt;nil&lt;/code&gt; for top navigation item.
We must manipulate the navigation item that is &lt;em&gt;second from the top&lt;/em&gt; in
the stack.  This will generally be the navigation item associated with
the view controller that just pushed the current view controller on top
of the stack.&lt;/p&gt;

&lt;p&gt;By default the navigation bar will use the second from top navigation
item&amp;rsquo;s title text as the back button text for the top view controller.
We can customize this, for example, by having the back button say &amp;ldquo;Cancel&amp;rdquo;
instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, NameControllerDelegate {
     ...
     override func viewDidLoad() {
        ...

        self.navigationItem.title = &amp;quot;Names&amp;quot;
        self.navigationItem.backBarButtonItem = UIBarButtonItem(title: &amp;quot;Cancel&amp;quot;, style: .Plain, target: nil, action: nil)
        ...
    }

    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        let nameVC = NameController()
        nameVC.fullName = names[indexPath.row]
        nameVC.delegate = self

        selectedIndexPath = indexPath
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        self.navigationController?.pushViewController(nameVC, animated: true)

    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/W4XwDwF&#34;&gt;&lt;img src=&#34;http://i.imgur.com/W4XwDwF.gif&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;!-- TODO: ## Example: implementing a search bar in the navigation bar --&gt;
</description>
    </item>
    
    <item>
      <title>Swift and Objective-C in the Same Project</title>
      <link>http://guides.peruzal.com/ios-guides/swift-objective-c-interoperability/</link>
      <pubDate>Mon, 12 Dec 2016 01:55:55 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/swift-objective-c-interoperability/</guid>
      <description>

&lt;h2 id=&#34;swift-and-objective-c-in-the-same-project&#34;&gt;Swift and Objective-C in the Same Project&lt;/h2&gt;

&lt;p&gt;With some caveats, you can use Objective-C code in a Swift file and vice versa.&lt;/p&gt;

&lt;h3 id=&#34;using-objective-c-in-swift&#34;&gt;Using Objective-C in Swift&lt;/h3&gt;

&lt;p&gt;In order to use Objective-C in a Swift file, you have to create an Objective-C bridging header. While you can create this manually, the easiest way is to let Xcode do it for you.&lt;/p&gt;

&lt;h3 id=&#34;step-1-create-an-objective-c-file&#34;&gt;Step 1: Create an Objective-C file&lt;/h3&gt;

&lt;p&gt;In your Xcode project, create a new file and select &amp;ldquo;Objective-C&amp;rdquo; file in the wizard. It doesn&amp;rsquo;t matter what you name the file because you&amp;rsquo;ll delete it later anyway. When Xcode prompts you to create the bridging header, you should accept.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/0rzQCPM.png&#34; alt=&#34;Bridging header&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-2-import-objective-c-headers&#34;&gt;Step 2: Import Objective-C Headers&lt;/h3&gt;

&lt;p&gt;In the bridging header, import any Objective-C header file that you would like to access from Swift. Once you do that, the Objective-C objects are available for you to use in any Swift file using the Swift language syntax.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/swift/conceptual/buildingcocoaapps/MixandMatch.html&#34;&gt;Using Swift with Cocoa and Objective-C&lt;/a&gt; (apple.com)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Application Architecture</title>
      <link>http://guides.peruzal.com/ios-guides/application-architecture/</link>
      <pubDate>Mon, 12 Dec 2016 01:54:51 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/application-architecture/</guid>
      <description>

&lt;p&gt;An iOS project is composed of many files that define different aspects
the application.  This guide presents high level overview of the most
common components of an application and how they fit together.  A more
comprehensive guide by Apple can be found &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;structure-of-a-uiapplication&#34;&gt;Structure of a &lt;code&gt;UIApplication&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;All iOS applications are instances of &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/&#34;&gt;&lt;code&gt;UIApplication&lt;/code&gt;&lt;/a&gt;.
Each application has a number of events in its lifecycle (e.g. launched,
went into the background, terminated).  As with other classes in the
UIKit framework, you control how the application will respond to these
events by providing it with a &lt;a href=&#34;http://en.wikipedia.org/wiki/Delegation_pattern&#34;&gt;delegate&lt;/a&gt;.  A
&lt;code&gt;UIApplication&lt;/code&gt;&amp;rsquo;s delegate must implement the
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html&#34;&gt;&lt;code&gt;UIApplicationDelegate&lt;/code&gt;&lt;/a&gt; protocol.&lt;/p&gt;

&lt;p&gt;When you create a new application in Xcode, the IDE automatically sets
up the code to instantiate a &lt;code&gt;UIApplication&lt;/code&gt; when the project is run.
It also generates a class that implements &lt;code&gt;UIApplicationDelegate&lt;/code&gt; called
&lt;code&gt;AppDelegate&lt;/code&gt; and sets the application&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/#//apple_ref/occ/instp/UIApplication/delegate&#34;&gt;delegate
property&lt;/a&gt; to an instance of this class.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NB: In Swift projects this is done via the &lt;code&gt;@UIApplicationMain&lt;/code&gt;
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html&#34;&gt;attribute&lt;/a&gt;.  In Object-C projects the set up is explicitly done in the
&lt;code&gt;main.m&lt;/code&gt; file.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-entry-point-to-your-application&#34;&gt;The entry point to your application&lt;/h3&gt;

&lt;p&gt;Of the methods that you can implement in your &lt;code&gt;UIApplicationDelegate&lt;/code&gt;,
perhaps the most important is
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:didFinishLaunchingWithOptions:&#34;&gt;didFinishLaunchingWithOptions&lt;/a&gt;.  This method will
be called once iOS has done most of the system initialization for your
app.  It is commonly used as an entry point where you can implement
custom logic that initializes your application and sets up the first
view controller.  For example, in applications that require log ins,
this is a good place to check whether there is a current user and
initialize different view controllers depending on the &amp;ldquo;logged in&amp;rdquo; state.&lt;/p&gt;

&lt;h3 id=&#34;the-root-view-controller&#34;&gt;The root view controller&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;UIApplicationDelegate&lt;/code&gt; also provides a reference to the
application&amp;rsquo;s main &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html#//apple_ref/occ/intfp/UIApplicationDelegate/window&#34;&gt;window&lt;/a&gt; object.  Of particular
importance is the ability to set the main window&amp;rsquo;s &lt;em&gt;root view
controller&lt;/em&gt;.  This is the first view controller that will load and
present its view to the user.  More on root view controllers can be
found below.&lt;/p&gt;

&lt;h4 id=&#34;the-root-view-controller-in-storyboard-applications&#34;&gt;The root view controller in storyboard applications&lt;/h4&gt;

&lt;p&gt;In simple storyboard applications, you can avoid working with the
&lt;code&gt;UIApplicationDelegate&lt;/code&gt; and simply set the root view controller directly
in your &lt;code&gt;Main.storyboard&lt;/code&gt;.  By default Xcode will generate an initial
view controller for you and set it to be the root view controller.  This
is indicated by the arrow that points to the view controller.  Once you
start adding more view controllers to your application, you can change
the root view controller by dragging this arrow around.  You can
also select a view controller and set it to be the root view controller
by using the &lt;code&gt;Is Initial View Controller&lt;/code&gt; checkbox in the Attributes
Inspector.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/winIGnh&#34;&gt;&lt;img src=&#34;http://i.imgur.com/winIGnhl.png&#34; title=&#34;Setting Root View Controller&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;programatically-setting-the-root-view-controller&#34;&gt;Programatically setting the root view controller&lt;/h4&gt;

&lt;p&gt;In applications not using storyboards, you must programatically set the
root view controller.  This is done in your &lt;code&gt;UIApplicationDelegate&lt;/code&gt;
implementation&amp;rsquo;s &lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&amp;gt; Bool {
        let vc = UIViewController()

        let label = UILabel()
        label.text = &amp;quot;hello, world!&amp;quot;
        label.frame = vc.view.frame

        // by default a UIViewController&#39;s .view property is set to an instance of UIView
        // of course you can set this to any custom subclass of UIView
        // one way to do this is subclass UIViewController and override the loadView method
        vc.view.backgroundColor = UIColor.cyan
        vc.view.addSubview(label)

        window = UIWindow(frame: UIScreen.main.bounds)

        // This can be set to any subclass of UIViewController.  You can also use conditional
        // logic here to set up different view controllers depending on application state
        window?.rootViewController = vc
        window?.makeKeyAndVisible()

        return true
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/fXE9BWw&#34;&gt;&lt;img src=&#34;http://i.imgur.com/fXE9BWwl.png&#34; title=&#34;Setting Root View Controller Programatically&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;other-hooks-in-the-application-lifecycle&#34;&gt;Other hooks in the application lifecycle&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;UIApplicationDelegate&lt;/code&gt; protocol provides many other hooks into the
application&amp;rsquo;s lifecycle giving you opportunities to things like respond
differently depending on how your application was launched, set up and
tear down temporary state depending whether your app is in the
foreground, and persist data before exiting. A detailed discussion of
the application lifecycle can be found &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html#//apple_ref/doc/uid/TP40007072-CH2-SW3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;model-view-controller-in-ios&#34;&gt;Model-View-Controller in iOS&lt;/h2&gt;

&lt;p&gt;Most applications you write for iOS will use a model-view-controller
(MVC) architecture similar to the one described by Apple
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html&#34;&gt;here&lt;/a&gt;.  This is a proven design that helps to break up your
application into managable parts with clean separation of concerns.
What follows is a description of how each part of MVC typically
applies in iOS programming.&lt;/p&gt;

&lt;!--- TODO: build sample app here --&gt;

&lt;p&gt;&lt;em&gt;NB: This description of MVC is actually slightly different than the one
originally described by &lt;a href=&#34;https://www.lri.fr/~mbl/ENS/FONDIHM/2013/papers/Krasner-JOOP88.pdf&#34;&gt;Krasner and Pope&lt;/a&gt; in the 1980s,
and is probably closer to what some people would call a
model-view-presenter pattern.  An interesting discussion of the
evolution of MVC architecture over time by Martin Fowler can be found
&lt;a href=&#34;http://martinfowler.com/eaaDev/uiArchs.html&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;models&#34;&gt;Models&lt;/h3&gt;

&lt;p&gt;Model objects encapsulate a logical unit of domain specific data in your
application.  In a photo-sharing social network, they might include
entities like &amp;ldquo;Users&amp;rdquo; and &amp;ldquo;Photos&amp;rdquo;.  Models may have relationships with
other models.  For example, a &amp;ldquo;Photo&amp;rdquo; might have been &amp;ldquo;posted by&amp;rdquo; a
&amp;ldquo;User&amp;rdquo;.  The model layer will gerenally contain any domain specific
logic for manipulating your data and relationships.  For example if a
User has a field keeping track of the number of Photos she has posted,
this field will have to updated once she posts a new Photo.&lt;/p&gt;

&lt;p&gt;Often in an iOS application, much of the core logic around manipulating
models and their relationships is offloaded to a remote API (e.g. a REST
API).  In these cases, the models in your iOS project will generally be
some Swift (or Objective-C) representation of the resources defined by
the API.&lt;/p&gt;

&lt;p&gt;The model layer is responsible for knowing how to perform &lt;a href=&#34;http://en.wikipedia.org/wiki/Create,_read,_update_and_delete&#34;&gt;CRUD&lt;/a&gt;
operations on models.  This can include having Swift (or Objective-C)
bindings to right API endpoints and implementing logic to
serialize/deserialize models from/into the different data formats.
&lt;a href=&#34;https://github.com/Mantle/Mantle&#34;&gt;Mantle&lt;/a&gt; and
&lt;a href=&#34;https://github.com/RestKit/RestKit&#34;&gt;RestKit&lt;/a&gt; are two popular libraries
that help to define the model layer&amp;mdash;especially the
serialization/deserialization logic when working with REST APIs.&lt;/p&gt;

&lt;p&gt;In the model-view-controller pattern the model is responsible for
notifying related controllers that there has been a change in its state.
This happens for example when the model layer has finished loading
data from a remote service and informs the view controller so that it
can transition out of the loading state and notify the views to display
the data.&lt;/p&gt;

&lt;h3 id=&#34;views&#34;&gt;Views&lt;/h3&gt;

&lt;p&gt;Views are responsible for displaying data (literally &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/drawRect:&#34;&gt;drawing
themselves&lt;/a&gt; on the screen) and responding to user actions.  Every
view in an iOS application will be a subclass of
&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html&#34;&gt;&lt;code&gt;UIView&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;UIKit comes with a selection of &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/UIKitUICatalog/&#34;&gt;predefined views&lt;/a&gt; that are
fairly comprehensive and, used creatively, can implement many UI
designs.&lt;/p&gt;

&lt;p&gt;You can also create custom views by subclassing any &lt;code&gt;UIView&lt;/code&gt; class.
Custom views are generally composed of one or more built-in views.  If
this is the case, the layout for a custom view can be defined using
Interface Builder in a &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/Devpedia-CocoaApp/Storyboard.html&#34;&gt;storyboard&lt;/a&gt; or &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html&#34;&gt;nib&lt;/a&gt;, or done programatically in
the view&amp;rsquo;s class.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll find yourself working with two kinds of views: reusable
components that are fairly generic (e.g. &lt;code&gt;UITableView&lt;/code&gt;) and specific
views that meant for presenting a specific model (e.g. a &lt;a href=&#34;Table-View-Guide#creating-customized-cells&#34;&gt;custom cell
class&lt;/a&gt; in a &lt;code&gt;UITableView&lt;/code&gt;).
In the former case you&amp;rsquo;ll want to design a good interface so that your
view can be reused in many situations.  In the later case, it is OK for
your view to be tightly coupled to your model since its only purpose is
to present a visual representation of the model.&lt;/p&gt;

&lt;p&gt;A view may be responsible for managing the instantiation and layout of
its subviews. However as you traverse up the &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/CreatingViews/CreatingViews.html#//apple_ref/doc/uid/TP40009503-CH5-SW47&#34;&gt;view
hieararchy&lt;/a&gt; ultimately you&amp;rsquo;ll find some parent view that
was instatiated by and inserted into the view hieararchy by a view
controller.  View controllers are responsible for creating views and
notifying views when they need to refresh themselves with the latest
data from the model.&lt;/p&gt;

&lt;p&gt;Conversely, views are responsible for responding to user actions and
propagating events to view controllers so that they can handle them
appropriately, for example by updating the model.&lt;/p&gt;

&lt;p&gt;Often views will translate a low level event into a semantic event.  For
example a table cell view responsible for displaying a Tweet might
translate the low level of the event button tap on the &amp;ldquo;star button&amp;rdquo;
into the semantic event of &amp;ldquo;user favorited Tweet&amp;rdquo;.  The view would then
pass this high level message to the view controller who might then have
the model layer make an API call to complete the &amp;ldquo;favoriting&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html&#34;&gt;delegate pattern&lt;/a&gt; is useful for this kind of event propagation and
is used widely throughout iOS frameworks.&lt;/p&gt;

&lt;h3 id=&#34;view-controllers&#34;&gt;View Controllers&lt;/h3&gt;

&lt;p&gt;The controller sits between your model and view.  It coordinates the
interaction between the model and the view by passing on &lt;em&gt;state&lt;/em&gt; changes
from model to the view and propagating &lt;em&gt;events&lt;/em&gt; from the view to the
model.  This relationship can be summarized as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                             update view
     -- state change --&amp;gt;                 -- with new state --&amp;gt;
Model                     View Controller                     View
     &amp;lt;-- handle event --                 &amp;lt;-- interpret and ---
      by updating model                     propagate event

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your view controllers will always subclass from &lt;code&gt;UIViewController&lt;/code&gt;.
Each view controller usually manages one &amp;ldquo;screen&amp;rdquo; within your app.  For
instance, an email client might have an &lt;code&gt;AccountsListViewController&lt;/code&gt;. If
you clicked on an account, it would push in to an &lt;code&gt;InboxViewController&lt;/code&gt;,
which displays a list of emails. If you tapped an email, it would
display the full email within an &lt;code&gt;EmailDetailsViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There is a notion of &lt;a href=&#34;Container-View-Controllers#&#34;&gt;container view controllers&lt;/a&gt; that
manage the multiple view controllers and their interactions.  The most
common built-in container view controller is the [[navigation controller|Navigation Controller]].&lt;/p&gt;

&lt;!---
## Other
### Build settings
### Storyboards
### Assets catalogs
--&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Application Lifecycle</title>
      <link>http://guides.peruzal.com/ios-guides/application-lifecycle/</link>
      <pubDate>Mon, 12 Dec 2016 01:53:19 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/application-lifecycle/</guid>
      <description>

&lt;p&gt;TODO:
* Awaking from Push Notifications
* Awaking from Location Changes&lt;/p&gt;

&lt;h1 id=&#34;state-changes-in-an-ios-app&#34;&gt;State Changes in an iOS app&lt;/h1&gt;

&lt;p&gt;An iOS application can transition between the following states:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Not running&lt;/li&gt;
&lt;li&gt;Inactive (e.g. there is a phone call)&lt;/li&gt;
&lt;li&gt;Active&lt;/li&gt;
&lt;li&gt;Background&lt;/li&gt;
&lt;li&gt;Suspended&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/aeOPsHh.png&#34; alt=&#34;State Changes in an iOS App&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-application-delegate&#34;&gt;The application delegate&lt;/h1&gt;

&lt;p&gt;Most of the time, your app reacts to state changes through the application delegate. If you are not using storyboards you will need to set up the window and root view controller of your application in &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;    func application(application: UIApplication,
            didFinishLaunchingWithOptions launchOptions:[NSObject: AnyObject]?) -&amp;gt; Bool {
        
        self.window = UIWindow(frame: UIScreen.mainScreen().bounds)
        self.rootViewController = ViewController()
        self.window?.rootViewController = self.rootViewController
        self.window?.makeKeyAndVisible()
        
        return true
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are using a storyboard you simply specify specify the &amp;ldquo;main interface&amp;rdquo; in your project settings. (Remember to also set the initial view controller on the storyboard)&lt;/p&gt;

&lt;h2 id=&#34;viewcontroller-lifecycle&#34;&gt;ViewController lifecycle&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/g19fw.png&#34; alt=&#34;View Controller Life Cycle Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;init(coder:)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When it is called / When it is used :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;View controller are usually created from storyboards.When this is the case,init(coder:) is the initializer that gets called and you have to override.&lt;/li&gt;
&lt;li&gt;If provides an NSCoder instance as a parameter, which you need only if you are using iOS serialization APIs. This is not used often, so you can ignore the parameter. If you are curious, serialization transforms an object in a byte stream that you can save on disk or send over the network.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Application :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;During the initalization phase of a view controller, you usually allocate the resources that the view controller will need during its lifetime. These include model objects or other auxiliary controllers, like network controllers.&lt;/li&gt;
&lt;li&gt;Previous view controllers might also pass these objects to the current one, so you do not always need to instantiate them in every view controller.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Things to take care of :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Beware that the view of the view controller has still not been instantiated at this point. If you try to access it through the view property of UIViewController, the loadView() method will be called. This might create unexpected behavior and bugs, so it’s safer not to access the view until later in the lifecycle.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;init(nibName:bundle:)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When it is called / When it is used :

&lt;ul&gt;
&lt;li&gt;Sometimes you might decide to put your view controller’s interface in a separate nib file instead of a storyboard. This might happen, for example, to work in a larger team where different members need to be change view controller interfaces without affecting the work of others. You also might have a project that was created when storyboards did not exist yet, so every view controller had its own nib file.Keep in mind that if your main storyboard starts getting too big, you can split it into more storyboards. You do not need to move every view controller in a separate nib file.&lt;/li&gt;
&lt;li&gt;If you create a view controller from a nib file, this initializer is called instead of init(coder:).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;loadView()&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is the method that creates the view for the view controller. You override this method only in case you want to build the whole interface for the view controller from code. Don’t use this unless there is a valid reason.&lt;/li&gt;
&lt;li&gt;If you are working with storyboards or nib files you do not have to anything with this method and you can ignore it. Its implementation in UIVIewController loads the interface from the interface file and connects all the outlets and actions for you.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;viewDidLoad()&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When this method gets called, the view of the view controller has been created and you are sure that all the outlets are in place.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Application :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is common to use this method to populate the user interface of the view controller with data before the user sees it.&lt;/li&gt;
&lt;li&gt;It is also a good place where to start some background activity where you need to have the user interface in place at the end.&lt;/li&gt;
&lt;li&gt;A common case are network calls that you need to do only once when the screen is loaded.&lt;/li&gt;
&lt;li&gt;Good place to init and setup objects used in the viewController.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;viewDidLoad V/S viewDidAppear :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If you need to repeat them (background activity/ UI changes/ make network calls ) to update the data in the view controller ,viewDidAppear(_:) is more appropriate to do so.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Important thing to remember :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This method is called only once in the lifetime of a view controller, so you use it for things that need to happen only once. If you need to perform some task every time a view controller comes on screen, then you need the next method.&lt;/li&gt;
&lt;li&gt;Keep in mind that in this lifecycle step the view bounds are not final.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;viewWillAppear(_:)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You override this method for tasks that need you need to repeat every time a view controller comes on screen. This method can be called multiple times for the same instance of a view controller.&lt;/li&gt;
&lt;li&gt;Notifies the view controller that its view is about to be added to a view hierarchy&lt;/li&gt;
&lt;li&gt;Application :

&lt;ul&gt;
&lt;li&gt;Usually you use this method to update the user interface with data that might have changed while the view controller was not on the screen.&lt;/li&gt;
&lt;li&gt;You can also prepare the interface for animations you want to trigger when the view controller appears.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;viewDidLoad V/S viewDidAppear :

&lt;ul&gt;
&lt;li&gt;Code you need to execute only once should go into an initializer or viewDidLoad().&lt;/li&gt;
&lt;li&gt;In this step the view has bounds defined but the orientation is not applied&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;viewWillLayoutSubViews:&lt;/strong&gt;
- Called to notify the view controller that its view is about to layout its subviews.
- This method is called every time the frame changes like for example when rotate or it’s marked as needing layout. It’s the first step where the view bounds are final.
- If you are not using autoresizing masks or constraints and the view size changes you probably want to update the subviews here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;viewDidLayoutSubviews:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Called to notify the view controller that its view has just laid out its subviews.&lt;/li&gt;
&lt;li&gt;Make additional changes here after the view lays out its subviews.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;viewDidAppear(_:)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This method gets called after the view controller appears on screen.&lt;/li&gt;
&lt;li&gt;You can use it to start animations in the user interface, to start playing a video or a sound, or to start collecting data from the network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;viewWillDisappear(_:)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Before the transition to the next view controller happens and the origin view controller gets removed from screen, this method gets called.&lt;/li&gt;
&lt;li&gt;You rarely need to override this method since there are few common tasks that need to be performed at this point, but you might need it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;viewDidDisappear(_:)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;After a view controller gets removed from the screen, this method gets called.&lt;/li&gt;
&lt;li&gt;You usually override this method to stop tasks that are should not run while a view controller is not on screen.&lt;/li&gt;
&lt;li&gt;For example, you can stop listening to notifications, observing other objects properties, monitoring the device sensors or a network call that is not needed anymore.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;deinit()&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Like every other object, before a view controller is removed from memory, it gets deinitialized.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Application :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You usually override deinit() to clean resources that the view controller has allocated that are not freed by ARC.&lt;/li&gt;
&lt;li&gt;You can also stop tasks you did not stop in the previous method because you wanted to keep them in the background.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Beware :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A view controller going out of the screen does not mean that it will be deallocated afterwards. Many containers keep view controllers in memory. For example, as you go deeper in a navigation controller, all the previous view controllers stay in memory. A navigation controller releases view controllers only when navigating back up the hierarchy. For this reason, you have to keep in mind that a view controller that is not on the screen still works normally and receives notifications. Sometimes this is desiderable, other times it isn’t, so you need to keep this in mind while developing your app.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;didReceiveMemoryWarning()&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;iOS devices have a limited amount of memory and power. When the memory starts to fill up, iOS does not use its limited hard disk space to move data out of the memory like a computer does. For this reason you are responsible to keep the memory footprint of your app low. If your app starts using too much memory, iOS will notify it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since view controllers perform resource management, these notifications are delivered to them through this method. In this way you can take actions to free some memory. Keep in mind that if you ignore memory warnings and the memory used by your app goes over a certain threshold, iOS will end your app. This will look like a crash to the user and should be avoided.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Objective-C Fundamentals</title>
      <link>http://guides.peruzal.com/ios-guides/objective-c/</link>
      <pubDate>Mon, 12 Dec 2016 00:55:19 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/objective-c/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;This guide covers the main Objective-C concepts you&amp;rsquo;ll need as you start building apps. It is meant to introduce each topic in a way that provides enough background to get you started.&lt;/p&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;It is common to start any tutorial for a new language with the &lt;strong&gt;Hello World&lt;/strong&gt; example so we&amp;rsquo;ll start out by showing how easy this is to do in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSLog(@&amp;quot;Hello World&amp;quot;);    // Prints &amp;quot;Hello World!&amp;quot; to the output window in Xcode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s is not &lt;code&gt;interplocation&lt;/code&gt; in Objective-C, the string&amp;rsquo;s format are used to format the numbers or strings accordinly.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;@&lt;/code&gt; is required and tells the compiler that the string might contain other characters that needs to be interpreted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;    NSString * firstName = @&amp;quot;Joseph&amp;quot;;
    NSLog(@&amp;quot;Hello World %@&amp;quot;, firstName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have used the &lt;code&gt;%@&lt;/code&gt; to replace the with the contents of the variable &lt;code&gt;firstName&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;common-format-specifiers&#34;&gt;Common format specifiers&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data type&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Format specifier&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NSInteger&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%li&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Signed integer, integer numbers that can hold a negative and positive value&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;NSUInteger&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%lu&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Unsigned integer, integer numbers that hold only positive numbers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BOOL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%i&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Boolean value, YES/NO&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CGFloat&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%f&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Floating point number&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;NSString  *firstName = @&amp;quot;Joseph&amp;quot;;
CGFloat  age = 33.5;
NSLog(@&amp;quot;Hello World my name is %@ and am %.f age years old&amp;quot;, firstName, age);
//Prints Hello World my name is Joseph and am 33.5 age years old
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;working-with-strings&#34;&gt;Working with Strings&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll notice in the example above we&amp;rsquo;ve used &lt;code&gt;NSString *&lt;/code&gt; to create the new variable for the name &amp;ldquo;Joseph&amp;rdquo;. In Objective-C, you use pointer types, that is variables followed by &lt;code&gt;*&lt;/code&gt; character to store objects.
NSString is the class used in Objective-C to work with strings. NSString objects can be created with many different constructors, but the most common way you’ll see &lt;code&gt;NSString&lt;/code&gt; objects created is with the &lt;code&gt;@&lt;/code&gt; symbol followed by quotes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSString  *firstName = @&amp;quot;Joseph&amp;quot;;
NSString  *lastName = @&amp;quot;Kandi&amp;quot;;
NSString *n = [NSString stringWithFormat:@&amp;quot;%@ %@&amp;quot;, firstName, lastName];
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;String don&amp;#39;t change&lt;/p&gt;
&lt;p&gt;In Objective-C an &lt;code&gt;NSString&lt;/code&gt; does not change, if you want to be able to modify the string, you need to create an &lt;code&gt;NSMutableString&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;strings-that-change&#34;&gt;Strings that change&lt;/h2&gt;

&lt;p&gt;Use an &lt;code&gt;NSMutableString&lt;/code&gt; for efficiency when you need strings that can be changed in place. The &lt;code&gt;NSMutableString&lt;/code&gt; is created the same way as an &lt;code&gt;NSString&lt;/code&gt; only that you can change
the string in place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSMutableString *alpha = [NSMutableString stringWithString:@&amp;quot;A&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;numbers&#34;&gt;Numbers&lt;/h2&gt;

&lt;p&gt;NSNumber is the class used in Objective-C to work with numbers. NSNumber gives you a way to turn floating point and integer values into object-oriented number objects.
You can use all the primitive types in the C-programming language since Objective-C is just a superset of the C-programming language.&lt;/p&gt;

&lt;p&gt;Integers are whole numbers with no fractional component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSInteger minValue = -42; // NSInteger is wrapper of the int type
NSInteger maxValue =  55;
int total = 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doubles can have a fractional component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;double pi = 3.14159;
float billAmount  = 10.25;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can create &lt;code&gt;NSNumber&lt;/code&gt; using special constructors as well&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSNumber *num3 = [NSNumber numberWithInteger:3];
NSNumber *num4 = [NSNumber numberWithFloat:4.44];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;converting-nsnumber-to-primitive-types&#34;&gt;Converting NSNumber to primitive types&lt;/h3&gt;

&lt;p&gt;You can convert the &lt;code&gt;NSNumber&lt;/code&gt; to its equivalent primitive type.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;floatValue&lt;/code&gt; convert to the primitive float.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intValue&lt;/code&gt; to primitive C integer value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doubleValue&lt;/code&gt; to the primitive C double value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stringValue&lt;/code&gt; converts to the formatted string.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;CGFloat result = [num1 floatValue] + [num2 floatValue];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;formatting-numbers&#34;&gt;Formatting Numbers&lt;/h3&gt;

&lt;p&gt;When used with the NSNumberFormatter class you can output numbers as localized currency, scientific notation, and they can even be spelled out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];
formatter.numberStyle = NSNumberFormatterCurrencyStyle;

NSLog(@&amp;quot;Formatted num2 = %@&amp;quot;, [formatter stringFromNumber:num2]);
//This will output R2.25 in South Africa
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;booleans&#34;&gt;Booleans&lt;/h2&gt;

&lt;p&gt;Boolean is a very simple type in Objective-C as it can only ever be &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let swiftIsCool: Bool = true
let iMissObjectiveC: Bool = false 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arrays&#34;&gt;Arrays&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;NSArray&lt;/code&gt; is a class used to organize objects in lists. NSArray can maintain an index of objects, search for objects, and enumerate through the list.
Any object can be put into an NSArray object, but not primitives like &lt;code&gt;NSInteger&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Careful when retrieving from an NSArray&lt;/p&gt;
&lt;p&gt;In Objective-C an &lt;code&gt;NSArray&lt;/code&gt; can contain any type of objects, when you retrieve the objective you need to check the type before using them.
Use the method &lt;code&gt;isKindOfClass:&lt;/code&gt; to check the kind of the class.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;creating-arrays&#34;&gt;Creating Arrays&lt;/h3&gt;

&lt;p&gt;Using the new syntax you can create arrays using literal types :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NArray *numbers = @[@-2, @-1, @0, @1, @2]; //An array wit numbers
NSArray *letters = @[@&amp;quot;A&amp;quot;, @&amp;quot;B&amp;quot;, @&amp;quot;C&amp;quot;, @&amp;quot;D&amp;quot;, @&amp;quot;E&amp;quot;, @&amp;quot;F&amp;quot;]; //Create an array of string
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Notice how we&#39;ve used &amp;quot;var&amp;quot; here since we want to append new items to the array
NSArray *previousBillAmounts = @[@10.25, @21.32, @15.54];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;an-array-that-can-be-changed&#34;&gt;An Array that can be changed&lt;/h2&gt;

&lt;p&gt;To create an array that can be changed we use the &lt;code&gt;NSMutableArray&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To add a new bill to the array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSMutableArray *mutableBillAmount = [previousBillAmounts mutableCopy];
[mutableBillAmount addObject:@&amp;quot;34&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check on how many bills there are in the array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;NSLog(@&amp;quot;Count %lu&amp;quot;, [mutableBillAmount count]);          // Result: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get the last object :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSLog(@&amp;quot;%@&amp;quot;, [previousBillAmounts lastObject]);    // Result: 34
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dictionaries&#34;&gt;Dictionaries&lt;/h2&gt;

&lt;p&gt;Much like you might use a real world dictionary to look up the definition for a word, you can use the dictionary data structure in Swift to create associations between keys (the word in the real world dictionary) and values (the definition in the real world dictionary).&lt;/p&gt;

&lt;p&gt;This is easiest seen using an example. Let&amp;rsquo;s say we want to keep track of the ages of people that are using our app. This would be best done using the following dictionary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var people: [String: Int] = [
                              &amp;quot;Bob&amp;quot;: 32,
                              &amp;quot;Cindy&amp;quot;: 25
                            ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the &lt;strong&gt;key&lt;/strong&gt; is the name of the person and the &lt;strong&gt;value&lt;/strong&gt; is the person&amp;rsquo;s age.&lt;/p&gt;

&lt;p&gt;Later on if we want to find out Bob&amp;rsquo;s age, we can look it up by doing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bobsAge = people[&amp;quot;Bob&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we get a new user we can easily add them to our dictionary using the following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;people[&amp;quot;Dan&amp;quot;] = 56
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;specifying-types&#34;&gt;Specifying Types&lt;/h2&gt;

&lt;p&gt;In most of the examples in this guide, we are explicit with the types of our constants and variables. Explicit typing looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let name: String = &amp;quot;Bob&amp;quot;   // Explicitly designating &amp;quot;name&amp;quot; to be of type &amp;quot;String&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Swift is smart enough to infer the type for us in a lot of cases. The previous example can be shortened to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let name = &amp;quot;Bob&amp;quot;   // Swift infers &amp;quot;name&amp;quot; is of type &amp;quot;String&amp;quot; since &amp;quot;Bob&amp;quot; is a String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In cases where Swift can infer the type, it&amp;rsquo;s not necessary to be explicit with the types for your constants and variables. We just do it in this guide so that the examples are easier to follow.&lt;/p&gt;

&lt;h2 id=&#34;any-and-anyobject&#34;&gt;Any and AnyObject&lt;/h2&gt;

&lt;p&gt;Swift has two special &amp;ldquo;catch all types&amp;rdquo; that come in handy when a more specific type cannot be determined.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AnyObject&lt;/code&gt; can represent an instance of &lt;strong&gt;any class type&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any&lt;/code&gt; can represent an instance of &lt;strong&gt;any type at all&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general it&amp;rsquo;s a best practice to be as specific with your types as possible and avoid the use of &lt;code&gt;AnyObject&lt;/code&gt; and &lt;code&gt;Any&lt;/code&gt;, but they become particularly helpful when interacting with Objective-C code that is less strict on typing.&lt;/p&gt;

&lt;h2 id=&#34;optionals&#34;&gt;Optionals&lt;/h2&gt;

&lt;p&gt;Optionals is a very important concept in Swift and is meant to improve the safety of Swift code. By simply placing a question mark (?) after any type, it declares that variable to be optional. An optional type allows that variable to exist in one of the following two states:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;There &lt;strong&gt;is a value and it equals x&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;There &lt;strong&gt;isn&amp;rsquo;t a value at all&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s look at an example to make this more clear. Consider the following 2 examples where we are trying to convert a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Example 1 (Conversion succeeds)
let input: String = &amp;quot;123&amp;quot;
let optionalConvertedInput: Int? = Int(input)  // optionalConvertedInput = 123

// Example 2 (Conversion fails - input is not a number)
let input: String = &amp;quot;123abc&amp;quot;
let optionalConvertedInput: Int? = Int(input)  // optionalConvertedInput = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift requires &lt;code&gt;optionalConvertedInput&lt;/code&gt; to be of type &lt;code&gt;Int?&lt;/code&gt; (or &amp;ldquo;optional Int&amp;rdquo;) so that it is explicit that convertedInput &lt;em&gt;might&lt;/em&gt; not contain a value (in the case when the conversion fails). If we were to declare &lt;code&gt;convertedInput&lt;/code&gt; as simply &lt;code&gt;Int&lt;/code&gt;, we&amp;rsquo;d get a compile error.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a handy syntax in Swift that you&amp;rsquo;ll use quite often when working with optionals. If we wanted to use the value of &lt;code&gt;optionalConvertedInput&lt;/code&gt; later on in our code, we&amp;rsquo;d have to first check to make sure it&amp;rsquo;s not &lt;code&gt;nil&lt;/code&gt;. We can do so using the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let convertedInput = optionalConvertedInput {
   // Code that gets executed when optionalConvertedInput is NOT nil
} else {
   // OptionalConvertedInput IS nil, do something else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other languages like Java, NullPointerException&amp;rsquo;s (exceptions that are fired when a null reference is accessed) are a common source of crashes. Swift&amp;rsquo;s Optionals goes a long way to reduce this type of programming error.&lt;/p&gt;

&lt;h2 id=&#34;functions&#34;&gt;Functions&lt;/h2&gt;

&lt;p&gt;Functions in Swift are very similar to other languages. The simplest function in Swift can be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This prints &amp;quot;Hello!&amp;quot; to the output window
func printHello() {
    print(&amp;quot;Hello!&amp;quot;)
}

// Calls this function
printHello()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can extend this function to be a little more personable by taking in a name and returning the greeting instead of printing it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Takes in a &amp;quot;personName&amp;quot; parameter of type String and returns the greeting as a String
func sayHello(personName: String) -&amp;gt; String {
    return &amp;quot;Hello \(personName)!&amp;quot;
}

// Calls this function
let greeting: String = sayHello(&amp;quot;Bob&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Things get a little more interesting when you start to have multiple parameters as Swift has the concept of &lt;strong&gt;external&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt; parameter names. An external parameter name is used to label arguments passed to a function call. A local parameter name is the name used in the implementation of the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// &amp;quot;to&amp;quot; + &amp;quot;and&amp;quot; are the external parameter names
// &amp;quot;person&amp;quot; + &amp;quot;anotherPerson&amp;quot; are the local parameter names
func sayHello(to person: String, and anotherPerson: String) -&amp;gt; String {
    return &amp;quot;Hello \(person) and \(anotherPerson)!&amp;quot;
}

// Calls this function using the &amp;quot;external&amp;quot; parameter names
let greeting: String = sayHello(to: &amp;quot;Bill&amp;quot;, and: &amp;quot;Ted&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;control-flow&#34;&gt;Control Flow&lt;/h2&gt;

&lt;h3 id=&#34;conditional-statements&#34;&gt;Conditional Statements&lt;/h3&gt;

&lt;p&gt;If statements are very similar to other languages and can be expressed as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let temperatureInFahrenheit: Int = 90

if temperatureInFahrenheit &amp;lt;= 32 {
    print(&amp;quot;It&#39;s very cold. Consider wearing a scarf.&amp;quot;)
} else if temperatureInFahrenheit &amp;gt;= 86 {
    print(&amp;quot;It&#39;s really warm. Don&#39;t forget to wear sunscreen.&amp;quot;)
} else {
    print(&amp;quot;It&#39;s not that cold. Wear a t-shirt.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;loops&#34;&gt;Loops&lt;/h3&gt;

&lt;p&gt;The two most common types of loops you&amp;rsquo;ll need in Swift are &lt;strong&gt;for loops&lt;/strong&gt; and &lt;strong&gt;for-in loops&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For loops&lt;/strong&gt; work well when you want to do something until a particular condition is met (in the case below until &lt;code&gt;index &amp;gt;= 3&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Simple for loop that prints &amp;quot;Hello&amp;quot; 3 times
for var index = 0; index &amp;lt; 3; index++ {
    print(&amp;quot;Hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C-style &lt;strong&gt;for loops&lt;/strong&gt; are deprecated and will be removed in future versions of Swift, more info available on the &lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&#34;&gt;SE-0007 Proposal&lt;/a&gt;.  &lt;strong&gt;For-in loops&lt;/strong&gt; are preferred instead. The above example could be re-written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        for _ in 0..&amp;lt;3 {
            print(&amp;quot;Hello&amp;quot;)
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;For-in loops&lt;/strong&gt; come in really handy when you want to do something to each item in a collection (such as an array):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let names = [&amp;quot;Anna&amp;quot;, &amp;quot;Alex&amp;quot;, &amp;quot;Brian&amp;quot;, &amp;quot;Jack&amp;quot;]

// Loops over each name in &amp;quot;names&amp;quot; and prints out a greeting for each person
for name in names {
    print(&amp;quot;Hello, \(name)!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes you want to loop over each item in an array and also keep track of the index of the item. Array&amp;rsquo;s &lt;code&gt;enumerate()&lt;/code&gt; method can help you achieve this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let names = [&amp;quot;Anna&amp;quot;, &amp;quot;Alex&amp;quot;, &amp;quot;Brian&amp;quot;, &amp;quot;Jack&amp;quot;]

for (index, value) in names.enumerate() {
    print(&amp;quot;Item \(index + 1): \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;classes&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;Classes are the building blocks of your app’s code. You define properties and methods to add functionality to your classes by using the same syntax as for variables and functions.&lt;/p&gt;

&lt;p&gt;Below you can find a &lt;code&gt;Person&lt;/code&gt; class that is meant to show an example of the types of things you&amp;rsquo;ll want to do when building your classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Person {
	
    // Custom initializer - takes in firstName and lastName
    init(firstName: String, lastName: String) {
        self.firstName = firstName
        self.lastName = lastName

        // Increment type property each time a new person is created
        Person.numberOfPeople++
    }
	
    // *** Properties ***
	
    // Stored Property - Stored as part of the current instance of the class
    var firstName: String
    var lastName: String

    // Computed Property - computes &amp;quot;fullName&amp;quot; from &amp;quot;firstName&amp;quot; and &amp;quot;lastName&amp;quot;
    var fullName: String {
    	get {
            return &amp;quot;\(firstName) \(lastName)&amp;quot;
    	}
    }

    // Type Property - Single instance for all instances of the class,
    // similar to a static property in Java
    static var numberOfPeople = 0   
    
    // *** Methods ***
    
    // Instance Method
    func greet() {
    	// Notice the use of &amp;quot;self&amp;quot; - self refers to the current instance and 
        // is similar to &amp;quot;this&amp;quot; in Java
    	print (&amp;quot;Hello \(self.firstName)&amp;quot;)
    }
    
    // Type Method
    class func printNumberOfPeople() {
    	print(&amp;quot;Number of people = \(Person.numberOfPeople)&amp;quot;)
    }
}

// ... Using the Person Class ...

// Create a new instance of the Person class
let bob = Person(firstName: &amp;quot;Bob&amp;quot;, lastName: &amp;quot;Smith&amp;quot;)

// Call instance method
bob.greet()   // Prints &amp;quot;Hello Bob&amp;quot;

// Accessing properies
print(&amp;quot;Bob&#39;s first name is: \(bob.firstName)&amp;quot;)  // Prints &amp;quot;Bob&#39;s first name is: Bob&amp;quot;
print(&amp;quot;Bob&#39;s full name is: \(bob.fullName)&amp;quot;)    // Prints &amp;quot;Bob&#39;s full name is: Bob Smith&amp;quot;

// Call type method
// Prints &amp;quot;Number of people = 1&amp;quot; (since we&#39;ve only created one Person)
Person.printNumberOfPeople()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;protocols&#34;&gt;Protocols&lt;/h2&gt;

&lt;p&gt;Protocols are similar to interfaces in other languages. Think about a protocol as a contract. The contract includes a set of methods that must be implemented. Any classes that choose to implement a protocol sign this contract and implement all the methods that are in the protocol.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have the following protocol (&lt;code&gt;MyFriendlyGreeterProtocol&lt;/code&gt;) that defines 2 methods &lt;code&gt;sayHello()&lt;/code&gt; and &lt;code&gt;sayBye()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol MyFriendlyGreeterProtocol {
    func sayHello()
    func sayBye()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any classes that implement this protocol (you implement a protocol by adding its name after the class defintion as shown below), must implement both of these methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyEnglishPerson: MyFriendlyGreeterProtocol {
    func sayHello() {
        print(&amp;quot;Hello!&amp;quot;)
    }

    func sayBye() {
        print(&amp;quot;Bye!&amp;quot;)
    }
	
    // ... other methods for this class ...

}

class MySpanishPerson: MyFriendlyGreeterProtocol {
    func sayHello() {
        print(&amp;quot;Hola!&amp;quot;)
    }

    func sayBye() {
        print(&amp;quot;Adios!&amp;quot;)
    }
	
    // ... other methods for this class ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot more you can do with protocols as they form one of the key design patterns in iOS. The code above merely shows how to get started with the syntax for protocols.&lt;/p&gt;

&lt;h2 id=&#34;closures&#34;&gt;Closures&lt;/h2&gt;

&lt;p&gt;Closures are self-contained blocks of code that can be passed around and used in your code. Closures in Swift are similar to blocks in Objective-C and lambdas in other programming languages.&lt;/p&gt;

&lt;p&gt;Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as &amp;ldquo;closing&amp;rdquo; over those constants and variables. Swift handles all of the memory management of capturing for you.&lt;/p&gt;

&lt;p&gt;Here’s an example of a function called &lt;code&gt;makeIncrementer&lt;/code&gt;, which contains a nested function called &lt;code&gt;incrementer&lt;/code&gt;. The nested &lt;code&gt;incrementer()&lt;/code&gt; function captures two values, &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt;, from its surrounding context. After capturing these values, &lt;code&gt;incrementer&lt;/code&gt; is returned by &lt;code&gt;makeIncrementer&lt;/code&gt; as a closure that increments &lt;code&gt;runningTotal&lt;/code&gt; by amount each time it is called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func makeIncrementer(forIncrement amount: Int) -&amp;gt; () -&amp;gt; Int {
    var runningTotal = 0
    func incrementer() -&amp;gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type of &lt;code&gt;makeIncrementer&lt;/code&gt; is &lt;code&gt;() -&amp;gt; Int&lt;/code&gt;. This means that it returns a function, rather than a simple value. The function it returns has no parameters, and returns an Int value each time it is called.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;makeIncrementer(forIncrement:)&lt;/code&gt; function defines an integer variable called &lt;code&gt;runningTotal&lt;/code&gt;, to store the current running total of the incrementer that will be returned. This variable is initialized with a value of 0.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;makeIncrementer(forIncrement:)&lt;/code&gt; function has a single Int parameter with an external name of &lt;code&gt;forIncrement&lt;/code&gt;, and a local name of &lt;code&gt;amount&lt;/code&gt;. The argument value passed to this parameter specifies how much &lt;code&gt;runningTotal&lt;/code&gt; should be incremented by each time the returned &lt;code&gt;incrementer&lt;/code&gt; function is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;makeIncrementer&lt;/code&gt; defines a nested function called &lt;code&gt;incrementer&lt;/code&gt;, which performs the actual incrementing. This function simply adds &lt;code&gt;amount&lt;/code&gt; to &lt;code&gt;runningTotal&lt;/code&gt;, and returns the result.&lt;/p&gt;

&lt;p&gt;When considered in isolation, the nested &lt;code&gt;incrementer()&lt;/code&gt; function might seem unusual:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func incrementer() -&amp;gt; Int {
    runningTotal += amount
    return runningTotal
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;incrementer()&lt;/code&gt; function doesn’t have any parameters, and yet it refers to &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt; from within its function body. It does this by capturing a reference to &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt; from the surrounding function and using them within its own function body. Capturing by reference ensures that &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt; do not disappear when the call to &lt;code&gt;makeIncrementer&lt;/code&gt; ends, and also ensures that &lt;code&gt;runningTotal&lt;/code&gt; is available the next time the &lt;code&gt;incrementer&lt;/code&gt; function is called.&lt;/p&gt;

&lt;p&gt;Here’s an example of &lt;code&gt;makeIncrementer&lt;/code&gt; in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This example sets a constant called incrementByTen to refer to an incrementer function that
// adds 10 to its runningTotal variable each time it is called.
let incrementByTen = makeIncrementer(forIncrement: 10)

incrementByTen()  // returns a value of 10
incrementByTen()  // returns a value of 20
incrementByTen()  // returns a value of 30
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-casting-as-as-as&#34;&gt;Type Casting (as, as?, as!)&lt;/h2&gt;

&lt;p&gt;Type casting changes the type of a particular instance to another compatible type. There are 3 ways to accomplish this with Swift:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Guaranteed conversion&lt;/strong&gt; with &lt;code&gt;as&lt;/code&gt; =&amp;gt; This is the safest cast. It will never fail since the compiler can guarantee the cast will work. Use this when you are upcasting from a child class to its parent or doing something like &lt;code&gt;1 as Float&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // Guaranteed conversion as the compiler can verify this will succeed
  let myFloat = 1 as Float

  // Guaranteed conversion as upcasting from a type to its parent type is safe 
  // UIView is a parent of UITableView
  let myView = myTableView as UIView
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Conditional conversion&lt;/strong&gt; with &lt;code&gt;as?&lt;/code&gt; =&amp;gt; This is a cautious cast. If the cast fails, it will return &lt;code&gt;nil&lt;/code&gt;. This is needed when downcasting from a parent type to a child type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // If myView is actually a tableView, the downcast will succeed, otherwise it will fail safely
  if let myTableView = myView as? UITableView {
      print(&amp;quot;The downcast succeeded!&amp;quot;)
  } else {
      print(&amp;quot;The downcast failed!&amp;quot;)        
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Forced conversion&lt;/strong&gt; with &lt;code&gt;as!&lt;/code&gt; =&amp;gt; This is a dangerous cast that you should avoid using. If the cast fails, this will crash your app. Use this cast carefully.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // DANGEROUS: If myView is actually a tableView, the downcast will succeed
  // Otherwise it will crash the app
  let myTableView = myView as! UITableView
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;understanding-the-question-mark&#34;&gt;Understanding the Question Mark (?)&lt;/h2&gt;

&lt;p&gt;There are various places where you&amp;rsquo;ll come across the need for using question marks in your code. The following examples are meant to capture the major types of use cases for the question mark operator that can cause confusion when first learning Swift.&lt;/p&gt;

&lt;p&gt;When defining a type as &lt;strong&gt;optional&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Designates that optionalName can either have a value or be nil
var optionalName: String? = &amp;quot;Hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When safely accessing methods or properties (called &lt;strong&gt;optional chaining&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// When myInstance IS nil, x = nil
// When myInstance is NOT nil, x = myInstance.count
// If any part of the chain is nil, it stops evaluating and returns
// nil, ignoring everything to the right.
let x = myInstance?.count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When type casting (called &lt;strong&gt;safe conditional conversion&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If myView is actually a tableView the downcast will succeed, otherwise it will fail safely
if let myTableView = myView as? UITableView {
    print(&amp;quot;The downcast succeeded!&amp;quot;)
} else {
    print(&amp;quot;The downcast failed!&amp;quot;)   	   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using the &lt;strong&gt;nil coalescing operator&lt;/strong&gt; (&lt;code&gt;??&lt;/code&gt;) to provide a default value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let nickName: String? = nil  // nickName is an optional that might be nil
let fullName: String = &amp;quot;Bob Smith&amp;quot;

// prints the nickName if it is NOT nil, otherwise prints fullName
let informalGreeting = &amp;quot;Hi \(nickName ?? fullName)&amp;quot;   // Prints &amp;quot;Hi Bob Smith&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;understanding-the-exclamation-mark&#34;&gt;Understanding the Exclamation Mark (!)&lt;/h2&gt;

&lt;p&gt;There are various places you might come across an exclamation mark in Swift code. The following examples are meant to capture the major types of use cases for the exclamation mark operator that can cause confusion when first learning Swift.&lt;/p&gt;

&lt;p&gt;When getting the actual value out of an optional (called &lt;strong&gt;unwrapping an optional&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let possibleString: String? = &amp;quot;An optional string.&amp;quot;

// DANGEROUS: possibleString must NOT be nil or this will crash
let forcedString: String = possibleString! 

// SAFE: Will only enter the if clause if possibleString is NOT nil
if let actualString = possibleString {
    // do something with actualString
}

// SAFE: Generally preferred alternate syntax to &amp;quot;if let&amp;quot; that can exit early
guard let actualString = possibleString else {
    // exit early or throw exception
}
// do something with actualString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When type casting (called &lt;strong&gt;forced conversion&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// DANGEROUS: If myView is actually a tableView, the downcast will succeed
// Otherwise it will crash the app
let myTableView = myView as! UITableView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When defining variables that are initially &lt;code&gt;nil&lt;/code&gt; but get set soon afterwards and are guaranteed not to be nil after that (called &lt;strong&gt;implicitly unwrapped optionals&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let assumedString: String! = &amp;quot;An implicitly unwrapped optional string.&amp;quot;

// no need for an exclamation mark since assumedString is an implicitly unwrapped optional
let implicitString: String = assumedString
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;working-with-json&#34;&gt;Working with JSON&lt;/h2&gt;

&lt;p&gt;A lot of the time when working with REST API&amp;rsquo;s (like Instagram, Twitter, etc), the data that comes back will be JSON. JSON is a human readable data format (very similar to XML).&lt;/p&gt;

&lt;p&gt;Below is an example of JSON that simulates the type of JSON you might get back when using an endpoint that returns movies and their ratings:
  * An open curly brace means the start of a dictionary
  * An open bracket means the start of an array&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;status&amp;quot;: &amp;quot;OK&amp;quot;,
    &amp;quot;movies&amp;quot;: [
        {
            &amp;quot;title&amp;quot;: &amp;quot;Whiplash&amp;quot;,
            &amp;quot;rating&amp;quot;: 8.5
        }, 
        {
            &amp;quot;title&amp;quot;: &amp;quot;Feast&amp;quot;,
            &amp;quot;rating&amp;quot;: 5.2
        }, 
        {
            &amp;quot;title&amp;quot;: &amp;quot;Kung Fury&amp;quot;,
            &amp;quot;rating&amp;quot;: 7.1
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is an example of how&amp;rsquo;d you extract the movies and ratings out of that response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// data returned from the network response will typically be of type
// NSData (which is a buffer of bytes)
let responseData: NSData = // ... some value retrieved from the network response ...

// Wrap our code in a do catch as our code might throw an exception which we need to handle
do {
    // Start by converting the NSData to a dictionary - a dictionary for the entire response
    if let responseDictionary = try NSJSONSerialization.JSONObjectWithData(responseData,
        options:NSJSONReadingOptions(rawValue:0)) as? [String:AnyObject] {

            // Dip inside the response to find the &amp;quot;movies&amp;quot; key and get the array of movies
            if let movies = responseDictionary[&amp;quot;movies&amp;quot;] as? [AnyObject] {

                // Get each movie dictionary from the array of movies
                for movie in movies {
                
                    // Use the movie &amp;quot;title&amp;quot; key and &amp;quot;rating&amp;quot; key to get their values
                    if let title = movie[&amp;quot;title&amp;quot;] as? String {
                        if let rating = movie[&amp;quot;rating&amp;quot;] as? Double {
                            print(&amp;quot;Title:\(title), rating:\(rating)&amp;quot;)
                        }
                    }
                }
            }
    }
} catch {
    print(&amp;quot;Error parsing JSON&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;playgrounds&#34;&gt;Playgrounds&lt;/h2&gt;

&lt;p&gt;Xcode includes a very useful tool for learning Swift called &amp;ldquo;Playgrounds&amp;rdquo;. It&amp;rsquo;s very easy to &lt;a href=&#34;https://developer.apple.com/library/ios/recipes/Playground_Help/Chapters/CreateAndEdit.html#//apple_ref/doc/uid/TP40015166-CH36-SW1&#34;&gt;create a new playground&lt;/a&gt; through Xcode.&lt;/p&gt;

&lt;p&gt;Once inside of a playground, you can write Swift code and see it run immediately (without needing to build and run a project each time). This allows you to try out different syntax and test out your code before including it into your app.&lt;/p&gt;

&lt;p&gt;We highly recommend checking out Playgrounds while you are learning Swift.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/wwdc/2014/#402&#34;&gt;WWDC 2014: Introduction to Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html&#34;&gt;iOS Developer Library: A Swift Tour&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itunes.apple.com/us/book/swift-programming-language/id881256329&#34;&gt;iBooks: The Swift Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.murage.ca/downcasting-in-swift-1-2-with-as-exclamation&#34;&gt;Swift Type Casting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift Fundamentals</title>
      <link>http://guides.peruzal.com/ios-guides/swift/</link>
      <pubDate>Mon, 12 Dec 2016 00:55:08 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/swift/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;This guide covers the main Swift concepts you&amp;rsquo;ll need as you start building apps. It is meant to introduce each topic in a way that provides enough background to get you started and defers to the &lt;a href=&#34;https://itunes.apple.com/us/book/swift-programming-language/id881256329&#34;&gt;iBook on Swift&lt;/a&gt; for more in depth coverage.&lt;/p&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;It is common to start any tutorial for a new language with the &lt;strong&gt;Hello World&lt;/strong&gt; example so we&amp;rsquo;ll start out by showing how easy this is to do in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;print(&amp;quot;Hello World!&amp;quot;)      // Prints &amp;quot;Hello World!&amp;quot; to the output window in Xcode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make this a little more personal, let&amp;rsquo;s look at one of the handy features of Swift (called &lt;strong&gt;string interpolation&lt;/strong&gt;) where we can insert values into strings using the &lt;code&gt;\(...)&lt;/code&gt; syntax. Below, we&amp;rsquo;ve inserted &lt;code&gt;name&lt;/code&gt; into the middle of our string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let name: String = &amp;quot;Bob&amp;quot;
print(&amp;quot;Hello \(name)!&amp;quot;)     // Prints &amp;quot;Hello Bob!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;when-to-use-let-vs-var&#34;&gt;When to use let vs var&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll notice in the example above we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; to create the new variable for the name &amp;ldquo;Bob&amp;rdquo;. In Swift, you&amp;rsquo;ll choose from the following 2 options when creating a new variable:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;let&lt;/code&gt; =&amp;gt; Use &lt;code&gt;let&lt;/code&gt; when you are defining a &lt;strong&gt;constant&lt;/strong&gt; (a value that will not change)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let numberOfContinents: Int = 7   // Seven continents will not change so we&#39;ve used &amp;quot;let&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;var&lt;/code&gt; =&amp;gt; Use &lt;code&gt;var&lt;/code&gt; when you are defining a &lt;strong&gt;variable&lt;/strong&gt; (a value that might change)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var continentsVisited: Int = 2   // Continents visited increases over time so we&#39;ve used &amp;quot;var&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general, it is considered a best practice to use constants (&lt;code&gt;let&lt;/code&gt;) whenever possible.&lt;/p&gt;

&lt;h2 id=&#34;numbers&#34;&gt;Numbers&lt;/h2&gt;

&lt;p&gt;The two most common types of numbers you&amp;rsquo;ll use in Swift are integers (&lt;code&gt;Int&lt;/code&gt;) and doubles (&lt;code&gt;Double&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;Integers are whole numbers with no fractional component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let minValue: Int = -42
let maxValue: Int = 55 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doubles can have a fractional component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let pi: Double = 3.14159
let billAmount: Double = 10.25
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;strings&#34;&gt;Strings&lt;/h2&gt;

&lt;p&gt;Strings represent a series of characters:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let hello: String = &amp;quot;Hello&amp;quot;
let world: String = &amp;quot;World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;strong&gt;string interpolation&lt;/strong&gt; to construct new strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let helloWorld: String = &amp;quot;\(hello) \(world)&amp;quot;    // &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can use the &lt;code&gt;+&lt;/code&gt; operator to combine strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let helloWorld: String = hello + &amp;quot; &amp;quot; + world    // &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;booleans&#34;&gt;Booleans&lt;/h2&gt;

&lt;p&gt;Boolean is a very simple type in Swift as it can only ever be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let swiftIsCool: Bool = true
let iMissObjectiveC: Bool = false 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arrays&#34;&gt;Arrays&lt;/h2&gt;

&lt;p&gt;Arrays store a list of values that must be of the same type. Below we&amp;rsquo;ve kept track of the previous bill amounts (which is a list of doubles):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Notice how we&#39;ve used &amp;quot;var&amp;quot; here since we want to append new items to the array
var previousBillAmounts: [Double] = [10.25, 21.32, 15.54]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To add a new bill to the array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;previousBillAmounts.append(52.45)    // Result: [10.25, 21.32, 15.54, 52.45]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check on how many bills there are in the array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let count = previousBillAmounts.count            // Result: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or to check the first bill amount in the array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let firstBillAmount = previousBillAmounts[0]    // Result: 10.25
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dictionaries&#34;&gt;Dictionaries&lt;/h2&gt;

&lt;p&gt;Much like you might use a real world dictionary to look up the definition for a word, you can use the dictionary data structure in Swift to create associations between keys (the word in the real world dictionary) and values (the definition in the real world dictionary).&lt;/p&gt;

&lt;p&gt;This is easiest seen using an example. Let&amp;rsquo;s say we want to keep track of the ages of people that are using our app. This would be best done using the following dictionary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var people: [String: Int] = [
                              &amp;quot;Bob&amp;quot;: 32,
                              &amp;quot;Cindy&amp;quot;: 25
                            ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the &lt;strong&gt;key&lt;/strong&gt; is the name of the person and the &lt;strong&gt;value&lt;/strong&gt; is the person&amp;rsquo;s age.&lt;/p&gt;

&lt;p&gt;Later on if we want to find out Bob&amp;rsquo;s age, we can look it up by doing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bobsAge = people[&amp;quot;Bob&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we get a new user we can easily add them to our dictionary using the following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;people[&amp;quot;Dan&amp;quot;] = 56
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;specifying-types&#34;&gt;Specifying Types&lt;/h2&gt;

&lt;p&gt;In most of the examples in this guide, we are explicit with the types of our constants and variables. Explicit typing looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let name: String = &amp;quot;Bob&amp;quot;   // Explicitly designating &amp;quot;name&amp;quot; to be of type &amp;quot;String&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Swift is smart enough to infer the type for us in a lot of cases. The previous example can be shortened to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let name = &amp;quot;Bob&amp;quot;   // Swift infers &amp;quot;name&amp;quot; is of type &amp;quot;String&amp;quot; since &amp;quot;Bob&amp;quot; is a String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In cases where Swift can infer the type, it&amp;rsquo;s not necessary to be explicit with the types for your constants and variables. We just do it in this guide so that the examples are easier to follow.&lt;/p&gt;

&lt;h2 id=&#34;any-and-anyobject&#34;&gt;Any and AnyObject&lt;/h2&gt;

&lt;p&gt;Swift has two special &amp;ldquo;catch all types&amp;rdquo; that come in handy when a more specific type cannot be determined.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AnyObject&lt;/code&gt; can represent an instance of &lt;strong&gt;any class type&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any&lt;/code&gt; can represent an instance of &lt;strong&gt;any type at all&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general it&amp;rsquo;s a best practice to be as specific with your types as possible and avoid the use of &lt;code&gt;AnyObject&lt;/code&gt; and &lt;code&gt;Any&lt;/code&gt;, but they become particularly helpful when interacting with Objective-C code that is less strict on typing.&lt;/p&gt;

&lt;h2 id=&#34;optionals&#34;&gt;Optionals&lt;/h2&gt;

&lt;p&gt;Optionals is a very important concept in Swift and is meant to improve the safety of Swift code. By simply placing a question mark (?) after any type, it declares that variable to be optional. An optional type allows that variable to exist in one of the following two states:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;There &lt;strong&gt;is a value and it equals x&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;There &lt;strong&gt;isn&amp;rsquo;t a value at all&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s look at an example to make this more clear. Consider the following 2 examples where we are trying to convert a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Example 1 (Conversion succeeds)
let input: String = &amp;quot;123&amp;quot;
let optionalConvertedInput: Int? = Int(input)  // optionalConvertedInput = 123

// Example 2 (Conversion fails - input is not a number)
let input: String = &amp;quot;123abc&amp;quot;
let optionalConvertedInput: Int? = Int(input)  // optionalConvertedInput = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift requires &lt;code&gt;optionalConvertedInput&lt;/code&gt; to be of type &lt;code&gt;Int?&lt;/code&gt; (or &amp;ldquo;optional Int&amp;rdquo;) so that it is explicit that convertedInput &lt;em&gt;might&lt;/em&gt; not contain a value (in the case when the conversion fails). If we were to declare &lt;code&gt;convertedInput&lt;/code&gt; as simply &lt;code&gt;Int&lt;/code&gt;, we&amp;rsquo;d get a compile error.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a handy syntax in Swift that you&amp;rsquo;ll use quite often when working with optionals. If we wanted to use the value of &lt;code&gt;optionalConvertedInput&lt;/code&gt; later on in our code, we&amp;rsquo;d have to first check to make sure it&amp;rsquo;s not &lt;code&gt;nil&lt;/code&gt;. We can do so using the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let convertedInput = optionalConvertedInput {
   // Code that gets executed when optionalConvertedInput is NOT nil
} else {
   // OptionalConvertedInput IS nil, do something else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other languages like Java, NullPointerException&amp;rsquo;s (exceptions that are fired when a null reference is accessed) are a common source of crashes. Swift&amp;rsquo;s Optionals goes a long way to reduce this type of programming error.&lt;/p&gt;

&lt;h2 id=&#34;functions&#34;&gt;Functions&lt;/h2&gt;

&lt;p&gt;Functions in Swift are very similar to other languages. The simplest function in Swift can be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This prints &amp;quot;Hello!&amp;quot; to the output window
func printHello() {
    print(&amp;quot;Hello!&amp;quot;)
}

// Calls this function
printHello()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can extend this function to be a little more personable by taking in a name and returning the greeting instead of printing it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Takes in a &amp;quot;personName&amp;quot; parameter of type String and returns the greeting as a String
func sayHello(personName: String) -&amp;gt; String {
    return &amp;quot;Hello \(personName)!&amp;quot;
}

// Calls this function
let greeting: String = sayHello(&amp;quot;Bob&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Things get a little more interesting when you start to have multiple parameters as Swift has the concept of &lt;strong&gt;external&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt; parameter names. An external parameter name is used to label arguments passed to a function call. A local parameter name is the name used in the implementation of the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// &amp;quot;to&amp;quot; + &amp;quot;and&amp;quot; are the external parameter names
// &amp;quot;person&amp;quot; + &amp;quot;anotherPerson&amp;quot; are the local parameter names
func sayHello(to person: String, and anotherPerson: String) -&amp;gt; String {
    return &amp;quot;Hello \(person) and \(anotherPerson)!&amp;quot;
}

// Calls this function using the &amp;quot;external&amp;quot; parameter names
let greeting: String = sayHello(to: &amp;quot;Bill&amp;quot;, and: &amp;quot;Ted&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;control-flow&#34;&gt;Control Flow&lt;/h2&gt;

&lt;h3 id=&#34;conditional-statements&#34;&gt;Conditional Statements&lt;/h3&gt;

&lt;p&gt;If statements are very similar to other languages and can be expressed as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let temperatureInFahrenheit: Int = 90

if temperatureInFahrenheit &amp;lt;= 32 {
    print(&amp;quot;It&#39;s very cold. Consider wearing a scarf.&amp;quot;)
} else if temperatureInFahrenheit &amp;gt;= 86 {
    print(&amp;quot;It&#39;s really warm. Don&#39;t forget to wear sunscreen.&amp;quot;)
} else {
    print(&amp;quot;It&#39;s not that cold. Wear a t-shirt.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;loops&#34;&gt;Loops&lt;/h3&gt;

&lt;p&gt;The two most common types of loops you&amp;rsquo;ll need in Swift are &lt;strong&gt;for loops&lt;/strong&gt; and &lt;strong&gt;for-in loops&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For loops&lt;/strong&gt; work well when you want to do something until a particular condition is met (in the case below until &lt;code&gt;index &amp;gt;= 3&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Simple for loop that prints &amp;quot;Hello&amp;quot; 3 times
for var index = 0; index &amp;lt; 3; index++ {
    print(&amp;quot;Hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C-style &lt;strong&gt;for loops&lt;/strong&gt; are deprecated and will be removed in future versions of Swift, more info available on the &lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&#34;&gt;SE-0007 Proposal&lt;/a&gt;.  &lt;strong&gt;For-in loops&lt;/strong&gt; are preferred instead. The above example could be re-written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        for _ in 0..&amp;lt;3 {
            print(&amp;quot;Hello&amp;quot;)
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;For-in loops&lt;/strong&gt; come in really handy when you want to do something to each item in a collection (such as an array):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let names = [&amp;quot;Anna&amp;quot;, &amp;quot;Alex&amp;quot;, &amp;quot;Brian&amp;quot;, &amp;quot;Jack&amp;quot;]

// Loops over each name in &amp;quot;names&amp;quot; and prints out a greeting for each person
for name in names {
    print(&amp;quot;Hello, \(name)!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes you want to loop over each item in an array and also keep track of the index of the item. Array&amp;rsquo;s &lt;code&gt;enumerate()&lt;/code&gt; method can help you achieve this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let names = [&amp;quot;Anna&amp;quot;, &amp;quot;Alex&amp;quot;, &amp;quot;Brian&amp;quot;, &amp;quot;Jack&amp;quot;]

for (index, value) in names.enumerate() {
    print(&amp;quot;Item \(index + 1): \(value)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;classes&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;Classes are the building blocks of your app’s code. You define properties and methods to add functionality to your classes by using the same syntax as for variables and functions.&lt;/p&gt;

&lt;p&gt;Below you can find a &lt;code&gt;Person&lt;/code&gt; class that is meant to show an example of the types of things you&amp;rsquo;ll want to do when building your classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Person {
	
    // Custom initializer - takes in firstName and lastName
    init(firstName: String, lastName: String) {
        self.firstName = firstName
        self.lastName = lastName

        // Increment type property each time a new person is created
        Person.numberOfPeople++
    }
	
    // *** Properties ***
	
    // Stored Property - Stored as part of the current instance of the class
    var firstName: String
    var lastName: String

    // Computed Property - computes &amp;quot;fullName&amp;quot; from &amp;quot;firstName&amp;quot; and &amp;quot;lastName&amp;quot;
    var fullName: String {
    	get {
            return &amp;quot;\(firstName) \(lastName)&amp;quot;
    	}
    }

    // Type Property - Single instance for all instances of the class,
    // similar to a static property in Java
    static var numberOfPeople = 0   
    
    // *** Methods ***
    
    // Instance Method
    func greet() {
    	// Notice the use of &amp;quot;self&amp;quot; - self refers to the current instance and 
        // is similar to &amp;quot;this&amp;quot; in Java
    	print (&amp;quot;Hello \(self.firstName)&amp;quot;)
    }
    
    // Type Method
    class func printNumberOfPeople() {
    	print(&amp;quot;Number of people = \(Person.numberOfPeople)&amp;quot;)
    }
}

// ... Using the Person Class ...

// Create a new instance of the Person class
let bob = Person(firstName: &amp;quot;Bob&amp;quot;, lastName: &amp;quot;Smith&amp;quot;)

// Call instance method
bob.greet()   // Prints &amp;quot;Hello Bob&amp;quot;

// Accessing properies
print(&amp;quot;Bob&#39;s first name is: \(bob.firstName)&amp;quot;)  // Prints &amp;quot;Bob&#39;s first name is: Bob&amp;quot;
print(&amp;quot;Bob&#39;s full name is: \(bob.fullName)&amp;quot;)    // Prints &amp;quot;Bob&#39;s full name is: Bob Smith&amp;quot;

// Call type method
// Prints &amp;quot;Number of people = 1&amp;quot; (since we&#39;ve only created one Person)
Person.printNumberOfPeople()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;protocols&#34;&gt;Protocols&lt;/h2&gt;

&lt;p&gt;Protocols are similar to interfaces in other languages. Think about a protocol as a contract. The contract includes a set of methods that must be implemented. Any classes that choose to implement a protocol sign this contract and implement all the methods that are in the protocol.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have the following protocol (&lt;code&gt;MyFriendlyGreeterProtocol&lt;/code&gt;) that defines 2 methods &lt;code&gt;sayHello()&lt;/code&gt; and &lt;code&gt;sayBye()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol MyFriendlyGreeterProtocol {
    func sayHello()
    func sayBye()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any classes that implement this protocol (you implement a protocol by adding its name after the class defintion as shown below), must implement both of these methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyEnglishPerson: MyFriendlyGreeterProtocol {
    func sayHello() {
        print(&amp;quot;Hello!&amp;quot;)
    }

    func sayBye() {
        print(&amp;quot;Bye!&amp;quot;)
    }
	
    // ... other methods for this class ...

}

class MySpanishPerson: MyFriendlyGreeterProtocol {
    func sayHello() {
        print(&amp;quot;Hola!&amp;quot;)
    }

    func sayBye() {
        print(&amp;quot;Adios!&amp;quot;)
    }
	
    // ... other methods for this class ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot more you can do with protocols as they form one of the key design patterns in iOS. The code above merely shows how to get started with the syntax for protocols.&lt;/p&gt;

&lt;h2 id=&#34;closures&#34;&gt;Closures&lt;/h2&gt;

&lt;p&gt;Closures are self-contained blocks of code that can be passed around and used in your code. Closures in Swift are similar to blocks in Objective-C and lambdas in other programming languages.&lt;/p&gt;

&lt;p&gt;Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as &amp;ldquo;closing&amp;rdquo; over those constants and variables. Swift handles all of the memory management of capturing for you.&lt;/p&gt;

&lt;p&gt;Here’s an example of a function called &lt;code&gt;makeIncrementer&lt;/code&gt;, which contains a nested function called &lt;code&gt;incrementer&lt;/code&gt;. The nested &lt;code&gt;incrementer()&lt;/code&gt; function captures two values, &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt;, from its surrounding context. After capturing these values, &lt;code&gt;incrementer&lt;/code&gt; is returned by &lt;code&gt;makeIncrementer&lt;/code&gt; as a closure that increments &lt;code&gt;runningTotal&lt;/code&gt; by amount each time it is called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func makeIncrementer(forIncrement amount: Int) -&amp;gt; () -&amp;gt; Int {
    var runningTotal = 0
    func incrementer() -&amp;gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type of &lt;code&gt;makeIncrementer&lt;/code&gt; is &lt;code&gt;() -&amp;gt; Int&lt;/code&gt;. This means that it returns a function, rather than a simple value. The function it returns has no parameters, and returns an Int value each time it is called.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;makeIncrementer(forIncrement:)&lt;/code&gt; function defines an integer variable called &lt;code&gt;runningTotal&lt;/code&gt;, to store the current running total of the incrementer that will be returned. This variable is initialized with a value of 0.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;makeIncrementer(forIncrement:)&lt;/code&gt; function has a single Int parameter with an external name of &lt;code&gt;forIncrement&lt;/code&gt;, and a local name of &lt;code&gt;amount&lt;/code&gt;. The argument value passed to this parameter specifies how much &lt;code&gt;runningTotal&lt;/code&gt; should be incremented by each time the returned &lt;code&gt;incrementer&lt;/code&gt; function is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;makeIncrementer&lt;/code&gt; defines a nested function called &lt;code&gt;incrementer&lt;/code&gt;, which performs the actual incrementing. This function simply adds &lt;code&gt;amount&lt;/code&gt; to &lt;code&gt;runningTotal&lt;/code&gt;, and returns the result.&lt;/p&gt;

&lt;p&gt;When considered in isolation, the nested &lt;code&gt;incrementer()&lt;/code&gt; function might seem unusual:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func incrementer() -&amp;gt; Int {
    runningTotal += amount
    return runningTotal
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;incrementer()&lt;/code&gt; function doesn’t have any parameters, and yet it refers to &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt; from within its function body. It does this by capturing a reference to &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt; from the surrounding function and using them within its own function body. Capturing by reference ensures that &lt;code&gt;runningTotal&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt; do not disappear when the call to &lt;code&gt;makeIncrementer&lt;/code&gt; ends, and also ensures that &lt;code&gt;runningTotal&lt;/code&gt; is available the next time the &lt;code&gt;incrementer&lt;/code&gt; function is called.&lt;/p&gt;

&lt;p&gt;Here’s an example of &lt;code&gt;makeIncrementer&lt;/code&gt; in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This example sets a constant called incrementByTen to refer to an incrementer function that
// adds 10 to its runningTotal variable each time it is called.
let incrementByTen = makeIncrementer(forIncrement: 10)

incrementByTen()  // returns a value of 10
incrementByTen()  // returns a value of 20
incrementByTen()  // returns a value of 30
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-casting-as-as-as&#34;&gt;Type Casting (as, as?, as!)&lt;/h2&gt;

&lt;p&gt;Type casting changes the type of a particular instance to another compatible type. There are 3 ways to accomplish this with Swift:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Guaranteed conversion&lt;/strong&gt; with &lt;code&gt;as&lt;/code&gt; =&amp;gt; This is the safest cast. It will never fail since the compiler can guarantee the cast will work. Use this when you are upcasting from a child class to its parent or doing something like &lt;code&gt;1 as Float&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // Guaranteed conversion as the compiler can verify this will succeed
  let myFloat = 1 as Float

  // Guaranteed conversion as upcasting from a type to its parent type is safe 
  // UIView is a parent of UITableView
  let myView = myTableView as UIView
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Conditional conversion&lt;/strong&gt; with &lt;code&gt;as?&lt;/code&gt; =&amp;gt; This is a cautious cast. If the cast fails, it will return &lt;code&gt;nil&lt;/code&gt;. This is needed when downcasting from a parent type to a child type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // If myView is actually a tableView, the downcast will succeed, otherwise it will fail safely
  if let myTableView = myView as? UITableView {
      print(&amp;quot;The downcast succeeded!&amp;quot;)
  } else {
      print(&amp;quot;The downcast failed!&amp;quot;)        
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Forced conversion&lt;/strong&gt; with &lt;code&gt;as!&lt;/code&gt; =&amp;gt; This is a dangerous cast that you should avoid using. If the cast fails, this will crash your app. Use this cast carefully.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // DANGEROUS: If myView is actually a tableView, the downcast will succeed
  // Otherwise it will crash the app
  let myTableView = myView as! UITableView
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;understanding-the-question-mark&#34;&gt;Understanding the Question Mark (?)&lt;/h2&gt;

&lt;p&gt;There are various places where you&amp;rsquo;ll come across the need for using question marks in your code. The following examples are meant to capture the major types of use cases for the question mark operator that can cause confusion when first learning Swift.&lt;/p&gt;

&lt;p&gt;When defining a type as &lt;strong&gt;optional&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Designates that optionalName can either have a value or be nil
var optionalName: String? = &amp;quot;Hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When safely accessing methods or properties (called &lt;strong&gt;optional chaining&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// When myInstance IS nil, x = nil
// When myInstance is NOT nil, x = myInstance.count
// If any part of the chain is nil, it stops evaluating and returns
// nil, ignoring everything to the right.
let x = myInstance?.count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When type casting (called &lt;strong&gt;safe conditional conversion&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If myView is actually a tableView the downcast will succeed, otherwise it will fail safely
if let myTableView = myView as? UITableView {
    print(&amp;quot;The downcast succeeded!&amp;quot;)
} else {
    print(&amp;quot;The downcast failed!&amp;quot;)   	   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using the &lt;strong&gt;nil coalescing operator&lt;/strong&gt; (&lt;code&gt;??&lt;/code&gt;) to provide a default value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let nickName: String? = nil  // nickName is an optional that might be nil
let fullName: String = &amp;quot;Bob Smith&amp;quot;

// prints the nickName if it is NOT nil, otherwise prints fullName
let informalGreeting = &amp;quot;Hi \(nickName ?? fullName)&amp;quot;   // Prints &amp;quot;Hi Bob Smith&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;understanding-the-exclamation-mark&#34;&gt;Understanding the Exclamation Mark (!)&lt;/h2&gt;

&lt;p&gt;There are various places you might come across an exclamation mark in Swift code. The following examples are meant to capture the major types of use cases for the exclamation mark operator that can cause confusion when first learning Swift.&lt;/p&gt;

&lt;p&gt;When getting the actual value out of an optional (called &lt;strong&gt;unwrapping an optional&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let possibleString: String? = &amp;quot;An optional string.&amp;quot;

// DANGEROUS: possibleString must NOT be nil or this will crash
let forcedString: String = possibleString! 

// SAFE: Will only enter the if clause if possibleString is NOT nil
if let actualString = possibleString {
    // do something with actualString
}

// SAFE: Generally preferred alternate syntax to &amp;quot;if let&amp;quot; that can exit early
guard let actualString = possibleString else {
    // exit early or throw exception
}
// do something with actualString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When type casting (called &lt;strong&gt;forced conversion&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// DANGEROUS: If myView is actually a tableView, the downcast will succeed
// Otherwise it will crash the app
let myTableView = myView as! UITableView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When defining variables that are initially &lt;code&gt;nil&lt;/code&gt; but get set soon afterwards and are guaranteed not to be nil after that (called &lt;strong&gt;implicitly unwrapped optionals&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let assumedString: String! = &amp;quot;An implicitly unwrapped optional string.&amp;quot;

// no need for an exclamation mark since assumedString is an implicitly unwrapped optional
let implicitString: String = assumedString
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;working-with-json&#34;&gt;Working with JSON&lt;/h2&gt;

&lt;p&gt;A lot of the time when working with REST API&amp;rsquo;s (like Instagram, Twitter, etc), the data that comes back will be JSON. JSON is a human readable data format (very similar to XML).&lt;/p&gt;

&lt;p&gt;Below is an example of JSON that simulates the type of JSON you might get back when using an endpoint that returns movies and their ratings:
  * An open curly brace means the start of a dictionary
  * An open bracket means the start of an array&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;status&amp;quot;: &amp;quot;OK&amp;quot;,
    &amp;quot;movies&amp;quot;: [
        {
            &amp;quot;title&amp;quot;: &amp;quot;Whiplash&amp;quot;,
            &amp;quot;rating&amp;quot;: 8.5
        }, 
        {
            &amp;quot;title&amp;quot;: &amp;quot;Feast&amp;quot;,
            &amp;quot;rating&amp;quot;: 5.2
        }, 
        {
            &amp;quot;title&amp;quot;: &amp;quot;Kung Fury&amp;quot;,
            &amp;quot;rating&amp;quot;: 7.1
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is an example of how&amp;rsquo;d you extract the movies and ratings out of that response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// data returned from the network response will typically be of type
// NSData (which is a buffer of bytes)
let responseData: NSData = // ... some value retrieved from the network response ...

// Wrap our code in a do catch as our code might throw an exception which we need to handle
do {
    // Start by converting the NSData to a dictionary - a dictionary for the entire response
    if let responseDictionary = try NSJSONSerialization.JSONObjectWithData(responseData,
        options:NSJSONReadingOptions(rawValue:0)) as? [String:AnyObject] {

            // Dip inside the response to find the &amp;quot;movies&amp;quot; key and get the array of movies
            if let movies = responseDictionary[&amp;quot;movies&amp;quot;] as? [AnyObject] {

                // Get each movie dictionary from the array of movies
                for movie in movies {
                
                    // Use the movie &amp;quot;title&amp;quot; key and &amp;quot;rating&amp;quot; key to get their values
                    if let title = movie[&amp;quot;title&amp;quot;] as? String {
                        if let rating = movie[&amp;quot;rating&amp;quot;] as? Double {
                            print(&amp;quot;Title:\(title), rating:\(rating)&amp;quot;)
                        }
                    }
                }
            }
    }
} catch {
    print(&amp;quot;Error parsing JSON&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;playgrounds&#34;&gt;Playgrounds&lt;/h2&gt;

&lt;p&gt;Xcode includes a very useful tool for learning Swift called &amp;ldquo;Playgrounds&amp;rdquo;. It&amp;rsquo;s very easy to &lt;a href=&#34;https://developer.apple.com/library/ios/recipes/Playground_Help/Chapters/CreateAndEdit.html#//apple_ref/doc/uid/TP40015166-CH36-SW1&#34;&gt;create a new playground&lt;/a&gt; through Xcode.&lt;/p&gt;

&lt;p&gt;Once inside of a playground, you can write Swift code and see it run immediately (without needing to build and run a project each time). This allows you to try out different syntax and test out your code before including it into your app.&lt;/p&gt;

&lt;p&gt;We highly recommend checking out Playgrounds while you are learning Swift.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/wwdc/2014/#402&#34;&gt;WWDC 2014: Introduction to Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html&#34;&gt;iOS Developer Library: A Swift Tour&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itunes.apple.com/us/book/swift-programming-language/id881256329&#34;&gt;iBooks: The Swift Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.murage.ca/downcasting-in-swift-1-2-with-as-exclamation&#34;&gt;Swift Type Casting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Starting a New Project in Xcode</title>
      <link>http://guides.peruzal.com/ios-guides/setup/</link>
      <pubDate>Mon, 12 Dec 2016 00:33:52 +0200</pubDate>
      
      <guid>http://guides.peruzal.com/ios-guides/setup/</guid>
      <description>

&lt;h2 id=&#34;1-create-the-project&#34;&gt;1. Create the Project&lt;/h2&gt;

&lt;p&gt;Click on File -&amp;gt; New -&amp;gt; Project and create a &amp;ldquo;Single View&amp;rdquo; project, and click &lt;em&gt;Next&lt;/em&gt;. You&amp;rsquo;ll be presented with a number of options.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Product Name&lt;/strong&gt; - The product name is just the name of your app, e.g., &amp;ldquo;Flicks&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Organization Name&lt;/strong&gt; - This is the name of your company, e.g. &amp;ldquo;Peruzal&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Company Identifier&lt;/strong&gt; - With the above values, this becomes &lt;code&gt;com.peruzal.Flicks&lt;/code&gt;. By convention, iOS uses &lt;a href=&#34;http://en.wikipedia.org/wiki/Reverse_domain_name_notation&#34;&gt;reverse domain name notation&lt;/a&gt; for identifiers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Devices&lt;/strong&gt; - This determines if your app is for the iPhone, iPad, or Universal (both). Use Universal.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Language&lt;/strong&gt; - Use Swift or Objective-C&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use Core Data&lt;/strong&gt; - It will add the boilerplate Core Data setup code for you. Leave it unchecked.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you click &lt;em&gt;Next&lt;/em&gt;, you&amp;rsquo;ll be prompted for a location to save it. Enable &amp;ldquo;Create a Git respository.&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;2-add-gitignores&#34;&gt;2. Add .gitignores&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;.DS_Store
xcuserdata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.DS_Store&lt;/code&gt; files are used by OS X to remember information about the current folder&amp;rsquo;s window location.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;xcuserdata&lt;/code&gt; folder stores you local Xcode data, such as the breakpoints you&amp;rsquo;ve set.&lt;/p&gt;

&lt;h2 id=&#34;3-use-a-shared-scheme&#34;&gt;3. Use a shared scheme&lt;/h2&gt;

&lt;p&gt;As you change build configurations, you want those changes shared with your team. Click the Application icon drop-down, and choose &lt;em&gt;Manage Schemes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the new window, there is one scheme bundled with your app. Check the &lt;em&gt;Shared&lt;/em&gt; box.&lt;/p&gt;

&lt;p&gt;You will now have an &lt;code&gt;MyProjectName.xcodeproj/xcshareddata&lt;/code&gt; folder in your app. Add this file to git.&lt;/p&gt;

&lt;h2 id=&#34;setup-up-cocoapods&#34;&gt;Setup up CocoaPods&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/&#34;&gt;Cocoapods&lt;/a&gt;, enables easy addition of libraries into your iOS project. You can use Cocoapods for both managing
Swift and Objective-C libraries in the same project.&lt;/p&gt;

&lt;h3 id=&#34;install-cocoapods&#34;&gt;Install Cocoapods&lt;/h3&gt;

&lt;p&gt;To install Cocoapods Ruby is required. By default OS X comes with Ruby installed.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Open &lt;code&gt;terminal&lt;/code&gt;. You can serach for terminal from the Spotlight.&lt;/li&gt;
&lt;li&gt;Run the following command &lt;code&gt;sudo gem install cocoapods&lt;/code&gt;. Enter your system password and press &lt;code&gt;Enter&lt;/code&gt; to continue.&lt;/li&gt;
&lt;li&gt;Once finished, navigate to the project root directory and run &lt;code&gt;pod init&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Podfile&lt;/code&gt; will be created together with a  folder &lt;code&gt;Pods&lt;/code&gt; that will holds the installed Cocoapods.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can add CocoaPods to be installed by editing the Podfile e.g. to install &lt;code&gt;SDWebImage&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    # Uncomment the next line to define a global platform for your project
    source &#39;https://github.com/CocoaPods/Specs.git&#39;
    platform :ios, &#39;9.0&#39;

    target &#39;Rotten Tomatoes&#39; do
    # Uncomment the next line if you&#39;re using Swift or would like to use dynamic frameworks
    use_frameworks!
    pod &#39;SDWebImage&#39;, &#39;~&amp;gt;3.8&#39;
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run the command &lt;code&gt;pod install&lt;/code&gt; to install the Cocoapods.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;setting-up-cocoapods-for-the-first-time&#34;&gt;Setting up Cocoapods for the first time&lt;/h2&gt;

&lt;p&gt;It might take a while to setup Cocoapods for the first time since the gem need to clone the whole CocoaPods repo.
The quickest way to setup CocoaPods is to use the following commands :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Open the terminal&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;sudo gem install cocoapods&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pod setup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+C&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pod repo remove master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd ~/.cocoapods/repos&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone --depth 1 https://github.com/CocoaPods/Specs.git master&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This should not take long to download the required setup to be able to install new Cocoapods.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/21022638/pod-install-is-staying-on-setting-up-cocoapods-master-repo&#34;&gt;http://stackoverflow.com/questions/21022638/pod-install-is-staying-on-setting-up-cocoapods-master-repo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>